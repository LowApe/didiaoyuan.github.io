<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最近的感悟]]></title>
    <url>%2F2019%2F05%2F29%2F%E8%87%AA%E6%88%91%E6%84%9F%E6%82%9F-19-5-29%2F</url>
    <content type="text"><![CDATA[自我反思-19-5-29不知不觉从我进入大学到真正入门编程已经四年过去了,从一个不知天高地厚的小子,到一个知道低调学习积累经验。期间经历了太多的事情,感谢这一路遇到的人,没有他们我可能还不能认清自己,也不会知道自己想要什么东西。 关于现在还有一年就要毕业,前几天也结束了软考中级,其实心情不怎么好,因为感觉这次考完佷有信息,考后对过答案,感觉心里没底。可能还是准备的不够充分,还有考试的时候也没好好检查,唉,现在脱离九年义务教育,连怎么考试都忘记了。总的来说我还是知道自己在做什么。知道以后的目标成为一个厉害的程序员,不管自己有没有天赋成为什么架构师,还是 CEO,但是我想先跨过第一个程序员的坎再说,之后工程师什么的在想吧… 其实,现在的自己虽然入门了,但是还是存在一些问题,我想好好列出来慢慢改变自己吧: 学习方法、学习效率 自控力 实战开发能力 团队合作、沟通能力 时间管理 需要锻炼这些东西一直是我做不好,知道如果完善这些,自己的综合素质肯定能上一个高度,当然还有我自己没有意识到的问题。 规划目前一直的规划就是,系统的学习每一点。我的规划和别人不一样我是先广度然后深度.以至于我现在一直没有开始钻研到某一个领域,我总觉得工作了,才没办法去走广度,你只能成为公司的螺丝钉,去做有限的事情.我其实对自己也没底气(可能学的还是不好),反正什么都学过,看过一点,前端什么H5,JS,JQuery,boostrap,vue,react,es6,后端从java se 基础(感觉基础还是不好),java ee 的servlet,jsp,tomcat部署，结构,spring,spring mvc,spring boot,操作系统 linux ,容器 docker ,数据库 mysql,Orcale,计算机网络,软件工程,uml,软件测试,Android ,python,C,等等一些其他概念.虽然列出来那么多技术,然而自己清楚上面的好多内容都没有吃透,比较高中数学没打好,基础什么的 算法,数据结构都没怎么学好… 说了一堆废话,说说目前的规划,目前买了几本书,准备好好啃书,在做项目之前好好大好基础,系统的复习为了不成为代码五分钟,debug 一小时,出现问题,应为基础的原因,连错误都找不出来,这样太可悲,而且也会打击自己对编程的热爱。 在下学期开学前,把 spring 和 spring 源码吃透,java 基础打好,其他的算法慢慢一点学吧,到块面试再花大块时间去学习,争取在实习前,通过所学得能独立完成一个项目吧。 关于未来毕业了,想去阿里！！！可能这个目标有点大,但是这就是我未来的目标.我想一定要进入大企业,好好感受和学习大厂的不同,不止是为了工资,就像做了程序员就像成为像比尔盖茨,那样自己一个产品改变世界的人.梦想还是有的,万一那条打破梦境,有了那样的基础和实力了呢！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gtihub中README相对路径]]></title>
    <url>%2F2019%2F05%2F08%2FGtihub%E4%B8%ADREADME%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[场景:在写 github 中README想添加路径访问到github其他文件,出现 404 错误 使用绝对路径,类似(https://github.com/LowApe/Study-Notes) 使用相对路径 文件夹使用,例如:[document](document/) 文件使用,例如:[file.txt](file.txt)]]></content>
      <categories>
        <category>问题汇总</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP字符串搜索算法]]></title>
    <url>%2F2019%2F04%2F10%2FKMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这个算法总结梳理了半个月,虽然痛苦但是打通了好多个点,我认为最难的点在如何求最大长度值表,不管是PMT表还是next表,都是辅助我们求解问题,如果能看懂主要原理和流程的同学,我认为其实理解了KMP 就是不知道怎么实现?为什么这样实现? 暴力匹配 最简单的是使用暴力匹配,也就是不管前面匹配了多少位,只要发生了不匹配,主串(指针) i 就要回溯到开始的下一位继续匹配,这边代码就不放了=&gt;暴力破解字符串匹配代码 KMP 算法 KMP 算法通过匹配要搜索字符串的子串寻找不匹配前相同前缀的位置来提高效率,利用已经部分匹配这个有效信息，保持i指针不回溯，通过修改j指针，让模式串尽量地移动到有效的位置。下面举个例子 例如: 主串: asdasdasdadasda搜索字符串:asdasb 那么什么是最大长度串?基本流程通过上面了解,我们首先需要找到不匹配位置前,子串的一个规律,从图中我们发现,这个子串有相同的内容,而我们需要移动的就是第二个相同的位置, 不着急,我还需要通过具体描述来说明.根据上图具体说明:当 i 和 j 下标的数据不相等(s[i]!=p[j]) 具体值使 d!=c,然后找到子串”a s d a s”,有个相同连续且最长字符串的地方”as”,这个子串(说的是”a s d a s”)已经是匹配了的,所以整个搜索串移动到第二个”as”的位置. 那么也就是说,当我们发生不匹配的时候,就要查看子串有没有这个最大长度串,如果没有,整体移动到 i 之后,如果有,j 就移动到最大长度串之后的位置(因为最大长度串是匹配的,所以从它后以为开始比较) 整个流程得到一个小公式 1234j=PMT[j-1]j:需要比较的位置(下一个比较的位置)PMT:理解为发生不匹配位置前的`匹配串`最大长度值的数组(后面会说怎么求)j-1:失配前的最大长度值下标 综上我们需要得到一个数组,存放最大长度值,这个数组就是核心部分.有了这个表,就能知道比较的下一个位置,所有问题好解决了 部分匹配表-PMT那如何求这个最大长度的串呢?从而求出最大长度值呢?:通过前后缀匹配的方式:正确前缀: “ababa” 的正确前缀除最后一个之前的分解字符串:”a”,”ab”,”aba”,”abab”;正确后缀:”ababa” 的正确后缀除第一个之前的分解字符串:”a”,”ba”,”aba”,”baba”; 部分匹配值=前后缀交集最长那个字符串的个数(上面的前后缀匹配得有”a”,”aba” 最大那个长度就是 3) 前缀和后缀数组交集中最长的串的个数,就是最大长度值,那如何求这个集合?下面是代码,其中有一个概念在代码之后讲解. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class PMT &#123; static int[] pmt; public static int getPMT(char[] s,char[] p)&#123; int i=0; int j=0; int sLen = s.length; int pLen = p.length; while (i&lt;sLen&amp;&amp;j&lt;pLen)&#123; //j==0 遗漏第一位没有比较// 表示没有最大长度值,整体 i 和 j 向后移 if(j==-1||s[i]==p[j])&#123; i++; j++; &#125;else&#123; //如果 s[i]!=p[j] 查看最大长度值 j--; if(j==-1)&#123; continue; &#125;else&#123; j=pmt[j]; &#125; &#125; &#125; if(j==pLen)&#123; return i-j; &#125; return -1; &#125; public static void getMatchLength(char[] p,int pmt[])&#123; //k是最大长度值 初始值0表示没有最大长度值 int k=0; int pLen = p.length; //j初识下标为1,因为第一位没有前后缀,p[k],p[j]指向同一个数 int j= 1; pmt[0]=0; //循环目的是把整个搜素串的各个位置的最大长度值求出来 while(j&lt;pLen)&#123; if(p[j]==p[k])&#123; //如果 p[j]==p[k],表示当前符合前后缀k++,赋值 k++; pmt[j]=k; &#125;else &#123; //如果 p[j]!=p[k],表示没有最大长度值,赋值k k=pmt[k]; &#125; j++; &#125; &#125; public static class TestPMT&#123; public static void main(String[] args) &#123; String s="dabadcabecbaabadcabfasdads"; String p="abadcabf"; pmt = new int[p.length()]; getMatchLength(p.toCharArray(),pmt); System.out.println("PMT 局部匹配表"); for (int i = 0; i &lt; pmt.length; i++) &#123; System.out.print(pmt[i]+"\t"); &#125; System.out.print("\n"); System.out.println("首次出现的位置"+getPMT(s.toCharArray(),p.toCharArray())); &#125; &#125;&#125; 为什么进行p[k]==p[j]判断?假设存在 k 值,k为所求最大长度值,则应该满足 p[0~k-1]==p[j-k~j-1],如果p[k]==p[j] 说明前面那个式子 k 不是最大长度值,如果 p[k]!=p[j] ,k就是最大长度值,有点绕口,为什么是这个等式:我们思考上面的特点,不管这个最大长度串有多长,前后缀都是相同,连续且最长,p[0~k-1]为前缀p[j-k~j-1]为后缀,注意j是不匹配位置所以这里是 j-1,p[k] 就是前缀下一个位置,p[j] 就是后缀下一个位置. 通过下图理解上面的公式: 说明:图上的例子很短,所以造成 k 值并不在前后缀中间,这没关系,一定要理解,我们是要求出最大长度值,也就是到 p[k]!=p[j] 从部分匹配表推出 next 数组上面就是 kmp 的一个核心思想,那现在优化这个 pmt 数组 通过部分匹配表 我们觉得每次去找上一个的最大长度值比较麻烦,于是我们直接将PMT数组整体后移1位(且首值赋值为-1)得到next数组, 1. j 从0开始计数,所以j就是已经匹配的个数 2. 当具体某个位置不匹配,通过next数组对应的值,就是失配前一个的最大长度值 这两个也就是为什么 PMT 转换成 next 的主要原因,我认为还是因为这样好算,不用考虑向前移动一个得到值 3. 具体代码实现过程下面给出原理的代码,先忽略next数组(把他理解为求得我们要移动的位置),还有一个j==-1 先理解为没有可匹配的子串1234567891011121314151617181920public static int KMPSearch(char[] s,char[] p)&#123; int i=0; int j=0; int sLen=s.length; int pLen=p.length; while (i&lt;sLen &amp;&amp; j&lt;pLen)&#123; if(j==-1 || p[j]==s[i])&#123; i++; j++; &#125;else&#123; //关键词比较的位置 j=next[j]; &#125; &#125; if(j==pLen)&#123; return i-j; &#125; return -1; &#125; 123456789101112131415161718public static void getNext(char[] p,int next[])&#123; // k 是最大长度值,通过下面求出k的值并存入数组 int k=-1; int pLen=p.length; next[0]=-1; int j=0; while (j&lt;pLen-1)&#123; //当前或 if(k==-1||p[j]==p[k])&#123; ++k; ++j; next[j]=k; &#125;else&#123; k = next[k]; &#125; &#125; &#125; 1. 为什么是 j=next[j]?之前的公式123j=PMT[j-1]因为next 数组整体后移一位,所有j刚好就是失配前最大长度值j=next[j] 2. 为什么next[0]= -1 ? next 数组[0] 索引下的值为 -1,我是这样理解的,当整体向后移动,第一位的值表示的含义就不是失配前最大长度值,因为在它前面没有子串,所有这表示没有可以匹配的子串,也就是意味无法找子串的移动位置,那找不到,就整体向后移,所有next[0]= -1是一个标志量,标志我们主串 i 向后移动. 别人的解释:当有匹配的位置就返回它的具体位置，否则返回-1（常用手段） 3. 如何理解next 优化 next[j]=next[k]? 12345678910111213141516171819202122232425public static void getNext(char[] p,int next[])&#123; // k 是最大长度值,通过下面求出k的值并存入数组 int k=-1; int pLen=p.length; next[0]=-1; int j=0; while (j&lt;pLen-1)&#123; //当前或 if(k==-1||p[j]==p[k])&#123; ++k; ++j; /* next 优化 */ if (p[j]!=p[k])&#123; next[j]=k; &#125;else&#123; next[j]=next[k]; &#125; &#125;else&#123; k = next[k]; &#125; &#125; &#125; 这可能是本文我最不理解的地方,如果有弄懂的小伙伴,可以在博客留言板留言,谢谢了(^__^) 嘻嘻…… 难点 list1. 局部匹配值的理解2. 注意移动位数与直接指向位置(本文全为指向位置)3. 为什么 next 数组整体向后移位4. 为什么 next 数组[0] 索引下的值为 -15. *获取最大长度值的过程 参考连接: 所有代码 GitHub blogcode.top jakeboxer 英文理解 阮一峰的理解 从头到尾彻底理解KMP（2014年8月22日版）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Object类(一)]]></title>
    <url>%2F2019%2F03%2F28%2FJava%20Object%E7%B1%BB(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Object类(一)第一次很正式的把一个类拿出来分析,虽然很多人说应该具体项目遇到的问题再去研读源码,但是总觉得你先得知道有什么,问题能通过对源码的熟悉程度能被解决把.. registerNatives1234private static native void registerNatives(); static &#123; registerNatives(); &#125; 问题:native 是什么? 这个方法是干什么的? Java native方法详解 getClass1public final native Class&lt;?&gt; getClass(); 获取运行时类的 Class 对象 hashCode1public native int hashCode(); Q:Object 中的hashCode() 与 System 中静态方法 identityHashCode(Object obj) 区别?12345678910111213141516171819202122Student student = new Student(); String a= new String("123"); String v= new String("123"); System.out.println("o-a:"+a.hashCode()); System.out.println("i-a:"+System.identityHashCode(a)); System.out.println(); System.out.println("o-student:"+student.hashCode()); System.out.println("i-student:"+System.identityHashCode(student)); System.out.println(); System.out.println("o-v:"+v.hashCode()); System.out.println("i-v:"+System.identityHashCode(v));// 打印的值// o-a:48690// i-a:21685669//// o-student:2133927002// i-student:2133927002//// o-v:48690// i-v:1836019240 Object 中的 hashCode() 是对象内存地址计算哈希值;String 类复写了 Object 的 hashCode() 所以它的 hashCode是另一种计算;System.identityHashCode()是对象内存地址计算哈希值;所以从上图可以看出,student 对象的 hashCode 相同 123public boolean equals(Object obj) &#123; return (this == obj); &#125; Q:’==’ 和 equals方法区别 ?==:判断两个变量之间的值是否相等,变量可以分为基本数据类型,和引用数据类型 基本数据类型直接比较值 引用类型比较对应的引用内存的首地址 equals:判断两个对象的特征是否一样;这个存在与 equals 方法的复写方法的比较方式; 123456789101112131415161718192021int a=7; int b=7; Integer one=new Integer(7); Integer two=new Integer(7); System.out.println(a==b); System.out.println(one==two); System.out.println(one.hashCode()); System.out.println(two.hashCode()); System.out.println(one.equals(two)); System.out.println(System.identityHashCode(one)); System.out.println(System.identityHashCode(two));// 打印 // true // false // 7 // 7 // true // 21685669 // 2133927002 稍微解读一下:上面的前两个打印,可以说明我们所说的基本数据类型和引用数据类型;我查看了一下源码,Integer 分装类的 hashCode 就是数值,equals 的比较方法是比较两个值;还有就是基本数据类型没有 equals 方法; clone1protected native Object clone() throws CloneNotSupportedException; 可以看出这是一个 protected 修饰,也就是只能同一包下的子类内部能使用,不同包下必须复写方法,才能使用;1234567891011121314151617181920212223242526public class Student implements Cloneable &#123; String name; int age = 5; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; try &#123; Student a= new Student(); System.out.println(a.clone().equals(a)); System.out.println(a.age); Student b = (Student) a.clone(); System.out.println(b.age); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 打印// false// 5// 5 前面我一直没有复写方法,然后在思考 protected 不是继承的子类可以调用吗?由于 Object 默认所有类继承,所有我一直以为他们在同一个包下,其实他们不同包,所有 protected 限制了子类调用不同包下的父类方法;还有就是复制的类实际上开辟了新的堆空间; 浅克隆定义:浅克隆仅仅复制了这个对象本身的成员变量; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Teacher &#123; public String name; public Teacher(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Student implements Cloneable &#123; Teacher teacher; int age = 5; public Student(Teacher teacher) &#123; this.teacher = teacher; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; try &#123; Teacher t=new Teacher("Tom"); Student a= new Student(t); Student b= (Student) a.clone(); System.out.println(System.identityHashCode(a)+"-"+System.identityHashCode(b)); System.out.println(System.identityHashCode(a.teacher)+"-"+System.identityHashCode(b.teacher)); System.out.println(a.teacher.name); System.out.println(b.teacher.name); t.setName("Jerry"); System.out.println(a.teacher.name); System.out.println(b.teacher.name); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 打印// 21685669-2133927002// 1836019240-1836019240// Tom// Tom// Jerry// Jerry 我先口述一下上面的过程(画图还没有找到好的工具);先看 main 方法,先创建一个 被克隆对象的成员变量 t,然后赋值;然后创建一个 a 对象,然后复制 a,当改变 t的值,被克隆和克隆对象成员都发生变化; 小总结:从hashcode 可以看出,克隆前后两个对象有自己独立的空间,但是赋值后的成员变量并没有克隆; 深克隆定义:会复制这个对象和它所引用的对象的成员变量;需要在覆写 clone() 方法中添加对成员变量的克隆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Teacher &#123; public String name; public Teacher(String name) &#123; this.name = name; &#125; /** * 调用这个方法可以实现对此类的克隆 * @return */ @Override public Teacher clone() &#123; return new Teacher(getName()); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class Student implements Cloneable &#123; Teacher teacher; private int age = 5; public Student(Teacher teacher) &#123; this.teacher = teacher; &#125; @Override protected Student clone() throws CloneNotSupportedException &#123; Student student = (Student) super.clone(); student.teacher = teacher.clone(); return student; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; try &#123; Teacher t=new Teacher("Tom"); Student a= new Student(t); Student b= a.clone(); System.out.println(System.identityHashCode(a)+"-"+System.identityHashCode(b)); System.out.println(System.identityHashCode(a.teacher)+"-"+System.identityHashCode(b.teacher)); System.out.println(a.teacher.name); System.out.println(b.teacher.name); a.getTeacher().setName("Jerry"); System.out.println(a.teacher.name); System.out.println(b.teacher.name); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 打印// 21685669-2133927002// 1836019240-325040804// Tom// Tom// Jerry// Tom 实现深克隆,需要注意两个地方,一个是要在克隆类的成员变量实体类实现一个 public 的克隆方法,用来返回一个新的成员变量,这个用于改变克隆的成员变量;上面的hashcode 表明创建了新的空间; clone() 的参考连接 toString123public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; 得到 对象名+@+十六进制的hasCode; 一旦编译器碰到一个字串，后面跟随一个“+”，就一旦编译器碰到一个字串，后面跟随一个“+”，就 123456789101112class TestOne&#123;&#125;public class ToStringP &#123; public static void main(String[] args) &#123; System.out.println("显示"+(new TestOne())); &#125;&#125;//打印// 显示eight.TestOne@1540e19d 12345678910111213class TestOne&#123; public String toString()&#123; return "aaaa"; &#125;&#125;public class ToStringP &#123; public static void main(String[] args) &#123; System.out.println("显示"+(new TestOne())); &#125;&#125;// 打印// 显示aaaa]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我反思-17-12-9]]></title>
    <url>%2F2017%2F12%2F09%2F%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D-17-12-9%2F</url>
    <content type="text"><![CDATA[很久没有写博客了，因为一直忙着比赛的事情，所以一段时间不断的练习，不断的敲代码，今天终于是结束了，再过一个星期就要考六级了，之后又要考专业课了。今天算是小阶段的休息，顺便反思总结最近的状态，并把最近的感受记录下来。 知识需要在不断地实践中巩固应该很多人都会遇到过这种情况，自己学了很久的东西，当需要用的时候，却不知道如何下手。经过这次综合的练习，我认识到其实知识是需要不断的实践与练习中巩固。而这一过程还需要自己思考。只有完成理论-实践-思考，这三步骤，才能将知识逐渐转换成自己的东西。 你只是看起来很努力回想以前的自己，每天学习，敲代码到十一点才结束，每天感觉到很累，以为自己努力的学到了东西，事实，一次实践项目练习暴露出自己学习不精，不牢的现象。每天看似很忙，其实在瞎忙。很多次遇到这种情况都感到小愤怒。后来通过读书慢慢找到了方法，知道了原因。读书，看起来没什么用，其实是因为没有在正确的情况下读正确的书。 推荐书籍《精进：如何变成一个厉害的人》 效率很重要知道自己的问题，我开始调整自己的作息时间，以及修改自己的学习方式。第一步作息时间很重要。发现自己越来越懒，早上起不来，晚上睡不着觉。这种状态持续很久，最近发现一本书，慢慢改善自己的睡眠。学习方式，从以前的逼迫是转变为效率最高学习，当出现注意了不集中的情况下，就进行短暂的休息。最关键的还是要思考，不能总跟这书中，视频的了进度走，因为很容易，我们从学知识，变成了抄知识，到最后还是没学会，没学好。做笔记方面，从以前的电脑笔记，转换为手写笔记。虽然电脑笔记有方便，以及方便查看的优点。但是不得不吐槽，在查询知识的同时，很容易让广告，或者其他链接忘记自己要做的正事。每次游览网页，很容易被带到别的内容上，这就是互联网，信息大量出现的弊端。我们很难再一大堆东西选出自己想要的东西。顺便说一下，目前本人十分看好大数据….哈哈哈，扯远了。最后就是你每一步的学习，都会给你一点反馈，注意你的反馈，适当的调整自己的策略… 推荐书籍《这本书能让你睡得好》 长路漫漫以后一定是从事软件开发这一行了，入行两年，学的也只是皮毛，年轻人太浮躁，看着这个行业的工资那么诱人，总是急急忙忙投入，能早日实现经济独立，早日证明自己，有时候会迷失自己。只有慢慢的努力，扎扎实实的才能走的长久，现已看透，决定慢慢走这一条路…最后，不愿当一条咸鱼，因为我是一个有梦想的人，我要改变世界！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Atom中实时协作]]></title>
    <url>%2F2017%2F11%2F17%2F%E5%9C%A8Atom%E4%B8%AD%E5%AE%9E%E6%97%B6%E5%8D%8F%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[官网地址插件地址 安装 安装 Atom 安装 teletype 插件1apm install teletype atom中安装 具体操作 准备点击 小信号塔，会发现跟 gif 出现的不同，我们需要先进入那个网站，进行授权 然后得到这串 token 输入到刚才的位置，就可以进行正常操作了]]></content>
      <categories>
        <category>Atom</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慢慢]]></title>
    <url>%2F2017%2F11%2F15%2F%E6%85%A2%E6%85%A2%2F</url>
    <content type="text"><![CDATA[连续几天没有写博客，也没有去敲代码，这几天状态超级差，逃避的在宿舍呆了三天，这三天什么都不想，就是各种耗时间。 窒息每天都很忙的去学习，喜欢的东西又不能真正的去认真花时间研究，本以为上了大学能有自己的空间，其实就是扯淡，我很庆幸自己上的专科，没有本科那种各种课程，唯一遗憾的就是确实没有本科学的那么扎实，教学质量那么好，好了不吐槽了。知道我自己在专科的劣势，我每天都希望自己过的很充实，最起码毕业了能学到点东西，可是，都大三了，每天还是那么多事，不是学校让干这个就是自己需要准备这个那个的，这几天我真的逼疯了。我不想考虑学习的事情，不想考虑比赛，不想考虑六级考试，不想考虑升学考试…..我就这样在宿舍呆了三天，没有出去，吃饭都让舍友带饭，自己就不断地打游戏，看电影，明明很累了，头疼我都不停下来。 逃避三天，我没有理任何人，然后，第一次被女朋友狠狠的训斥了一番，点醒了自己。从小到大，每当我遇到无法解决的问题，我总是逃避，虽然我一直不承认自己是在逃避么我总觉得是我累了，需要好好放松一下就好了，可是往往就是让自己越来越累，我根本就没有想着如何处理，只是觉得休息一下就好。说到底，就是适应能力太差，从第一次经历喜欢的老师走了，然后开始不好好学习，更新老师对着干，到高中不喜欢高中的人与人之间冷漠的关系，自己跟自己赌气，明明不瞌睡，却就是不想听课。不喜欢宿舍生活，各种闹腾想回家，这些年让父母操碎了心，可是这个问题我一直逃避。结果就是没隔一段是时间我总是发一阵分，对任何人不理不睬，只想逃避，只想着找个安静的地方。可是每次发泄完，我又开始重复的那些工作，然后等待下一次爆发。 反思当被她说出自己最关键的问题，我才真的觉得自己真是在逃避现实。我无法解决现实生活中看不惯，不喜欢的事情，我总是在挣扎，可能想我这样年龄的都有吧，没想要玩着度过自己的大学，却总是在挣扎想要实现自己肩负改变整个家庭命运的使命，没有人逼迫自己，就是自己想要未来的生活，每次你感觉自己已经很努力的，但是总是抓不住你想要的结果，就非常苦恼，常常质问自己，每当你学的东西被遗忘的时候，总是感觉以前的时光被虚度了，虽然我也常常安慰自己，最后总是被现实的人或事让你觉得这个世界是多么的冷漠，是多么可笑…..可能这本身就是成长的烦恼，但是我觉得自己就是太想改变世界了，哈哈哈。 慢慢你热爱生活吗？当我遇到这个问题，我才觉得我现在一点都不热爱生活，我被生活囚禁了。感谢小天使在我人生中出现，让我改变了很多。感谢有你在我身边不断的鼓励我。感谢有你每天都对我笑。感谢有你让我正视自己的问题….我会慢慢理解生活，享受生活，热爱生活。其实我也没有那么急，每天忙忙碌碌的人，你是否知道自己忙什么吗？如果像我这样这是为了一个未来的蓝图，天天忙的只会吐槽生活，那最后收获的也仅仅是最后那一瞬间的快乐。为什么不让自己慢下来，慢慢享受生活呢？谁说输在起跑线上的人一定会比抢跑的人过的好？ 最后我可能改变不了世界，但是我可以改变我自己，不想忙忙碌碌最后才发现，拼搏那那么久原来得到的不是正真想要的生活！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习(六)]]></title>
    <url>%2F2017%2F11%2F09%2FC%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[其他类型C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。 小节-关键字： 基本数据类型由 11 个关键字组成: int、long、short、unsigned、char、float、double、signed、_Bool、_Complex 和 _Imaginary 有符号整型 表示正整数和负整数， int 为系统给定的基本整数类型。C语言规定int 类型不少于 16位 short或 short int 最大的 short 整数小于或等于最大的int类型整数。C语言规定 short 类型至少占32位。 long long 或 long long int 该类型整数大于或等于最大的int 类型整数。C语言规定 long long 类型至少占 32位 无符号整型 无符号整型表示零或正整数。无符号整型表示方法 unsignedint unsigned long unsigned short 字符类型 打印出来的符号(A、&amp;he1+)都是字符 char 布尔类型 C语言用 1表示 true，0 表示 false。 _Bool 类型是无符号int 类型 实浮点类型 float 可精确至少位有效数字 double 存储浮点数范围大，至少10位有效数字和更大指数 long long 存储浮点数 的范围比 double 更大，能把表示比 double 更多的邮箱数字和更大的指数。 类型大小使用 sizeof()内置运算符 知道指定类型的大小。打印类型大小使用 %zd 占位符表示（C99）12345678910111213#include &lt;stdio.h&gt;int main(void)&#123; printf("%zd \n",sizeof(int)); printf("%zd \n",sizeof(char)); printf("%zd \n",sizeof(long)); printf("%zd \n",sizeof(long long)); printf("%zd \n",sizeof(float)); printf("%zd \n",sizeof(double)); printf("%zd \n",sizeof(long double)); getchar(); return 0;&#125; 输出结果表示的是不同类型的字节，比如 char 一定为 1 字节 ，char 类型 为 16 位 ，double 为 64 位的系统中，sizeof 给出的 double 字节为 4。（4*16=64） 参数和陷阱printf(),””里面的内容表示参数，一般参数都用 ， 分割。一般注意，使用数据类型要判断具体使用哪一种，在使用 printf 还要注意参数匹配问题，有些会出现参数多了，参数少了，匹配的占位符与参数类型不同的等问题，会根据不同的编译器，报不同的错误！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习总结(二)]]></title>
    <url>%2F2017%2F11%2F09%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[四、系统设计理解面向对象的设计原则（7个） 单一职责原则 解释：可以降低类的复杂度，一个类只负责一项职责 里氏替换原则 解释：超类存在的地方，子类是可以替换的。 依赖倒置原则 解释：尽量依赖抽象，不依赖具体实现 接口隔离原则 解释：为客户端提供尽可能小的单独的接口，而不是提供大的总的接口 迪米特法则 解释：最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。 开闭原则 解释：面向扩展开发，面向修改关闭 组合/聚合复用原则 解释：尽量使用合成/聚合达到复用，尽量少用继承。原则：一个类中有另一个类的对象。 明确概要(系统)设计阶段的任务 制定软件系统的总体设计，确定了各个模块的功能及模块之间的联系，再进一步就要考虑如何实现各个模块所规定的功能 掌握数据库设计方法（E-R图–与关系模型） 实体-联系图的数据模型 1.实体(数据对象)2.属性是实体或联系所具有的性质，一个实体对应多个属性3.联系 一对一的关系映射为数据库表的主外键关联，在任意端的属性中加入另一端的主键做外键； 一对多的关系映射为数据库表的主外键关联，一端的主键加入n端成为外键； 多对多的关系映射为一个单独的表，两个多端的主键成为该表的外键，两个外键的组合成为该表的主键。 E-R图 矩形为实体，菱形表示联系，属性表示椭圆 MVC 设计模式 模型层、视图层、控制层使用MVC的目的是增强代码的重用性，降低数据描述和应用操作的可耦合度，提高代码可读性，及软件的可维护性、可修复性、灵活性和封装性。 软件体系结构的特点（C/S与B/S） C/S（Client/Server）结构，即客户机和服务器结构，客户端实现绝大多数数业务逻辑处理和界面显示，客户端复杂度大于服务器端。 B/S（Browser/Server）结构，即浏览器和服务器结构，用户工作界面通过浏览器实现，主要事务逻辑在服务器端实现，简化了客户端电脑载荷。 理解软件结构设计原则 模块化：将功能相同或相近的代码写成模块， 便于分工合作，便于调试，便于移植，便于改进； 抽象：抽取事务最基本的特征和行为，忽略非本质细节； 逐步求精：即将系统功能按层次进行分解，每一层不断将功能细化，到最后一层都是功能单一、简单易实现的模块。 信息隐藏：采用封装技术，将程序模块的实现细节隐藏起来，使模块接口尽量简单； 局部化：保证模块之间具有松散的耦合关系，使模块内部具有较高的内聚性； 高内聚低耦合：主要是看类的内聚性是否高，耦合度是否低。 理解模块内聚性 内聚性又称快内联系，指模块的功能强度的度量，模块中组成元素结合得越紧密，内聚性越高，模块的独立性也就越高。理想的类聚性要求模块的功能应明确、单一，一个模块只做一件事。耦合性又称块间联系，模块之间联系越紧密，耦合性越强。 偶然内聚：指一个模块内的各处理元素之间没有任何联系； 逻辑内聚：模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能； 时间内聚：把需要同时执行的动作合在一起形成的模块为时间内聚模块； 通信内聚（信息内聚）：指模块内所有处理元素都在同一个数据结构上操作，或指各处理使用相同的输入数据或者产生相同的输出数据； 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入； 功能内聚：最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。 理解模块间的耦合性（6）及原则 非直接耦合：如果两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，这就是非直接耦合。这种耦合的模块独立性最强。 数据耦合：如果一个模块访问另一个模块时，彼此之间是通过数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的，则称这种耦合为数据耦合。 印记耦合：如果一组模块通过参数表传递记录信息，就是标记耦合。 控制耦合：如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。 外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。 公共耦合：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 这种耦合会引起下列问题：所有公共耦合模块都与某一个公共数据环境内部各项的物理安排有关，若修改某个数据的大小，将会影响到所有的模块。无法控制各个模块对公共数据的存取，严重影响软件模块的可靠性和适应性。公共数据名的使用，明显降低了程序的可读性。公共耦合的复杂程度随耦合模块的个数增加而显着增加。若只是两个模块之间有公共数据环境，则公共耦合有两种情况。若一个模块只是往公共数据环境里传送数据，而另一个模块只是从公共数据环境中取数据，则这种公共耦合叫做松散公共耦合。若两个模块都从公共数据环境中取数据，又都向公共数据环境里送数据，则这种公共耦合叫做紧密公共耦合。只有在模块之间共享的数据很多，且通过参数表传递不方便时，才使用公共耦合。否则，还是使用模块独立性比较高的数据耦合好些。 内容耦合：如果发生下列情形，两个模块之间就发生了内容耦合。一个模块直接访问另一个模块的内部数据；一个模块不通过正常入口转到另一模块内部；两个模块有一部分程序代码重叠(只可能出现在汇编语言中)；一个模块有多个入口。在内容耦合的情形，所访问模块的任何变更，或者用不同的编译器对它再编译，都会造成程序出错。好在大多数高级程序设计语言已经设计成不允许出现内容耦合。它一般出现在汇编语言程序中。这种耦合是模块独立性最弱的耦合。]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习(五)]]></title>
    <url>%2F2017%2F11%2F08%2FC%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[float、double、long double浮点数多用于金融和数学的程序。浮点数类型能表示包括小数在内更大范围的数。浮点数表示类似于科学记数法(即用小数乘以10的幂来表示数字)。 float C标准规定，float 类型必须至少能表示6位有效数字，且取值范围至少是10^-37~10^38。系统要存储一个浮点数要占用32位。其中8位表示指数的值和符号，剩下24位用于表示非指数部分(也叫做尾数或有效数)及其符号。 double 双精度。double 类型和 float 类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double 占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数(即提高了精度)，减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double 类型的值至少有 13位有效数字，超过了标准的最低位数规定。 long double 比满足比 double 类型更高的精度要求。C只保证long double 类型至少与 double 类型的精度相同。 声明浮点变量float a;double b;float c=6.63e-34;long double d; 浮点常量的表示 有符号的数字，后面紧跟 e 或 E,可以省略小数部分，或者整数部分123456-1.56E+122.87e-3.24e16.8E-5100. 不要在浮点型常量中间加空格 如：1.56 E+12 (错误) 默认情况下，编译器假定浮点型常量为 double 类型的精度1float abc= 4.0 * 2.0; 其中的 4.0 和 2.0 常数默认为 double 类型计算后截断为float 类型。这样的程序运行速度会缓慢。使用 f 或 F 常量后缀，可以覆盖默认模式，比如：4.0f 或 2.0f 如果添加 l 或 F 可以变为 long double 类型 如：54.3L 和34.1l 建议使用大写，因为l小写与数字1 相似。 C99 标准添加了一种新的浮点型常量格式–用十六进制表示浮点型常量，即添加 Ox 或 OX ,用 p 和 P 分别代替 e 和 E，用 2的幂代替10的幂(p 计数法)。如: 1Oxa.1fp10 a 十进制表示 10，.1f 是 1/16，f是15所以 为15/256， 加上 p10 表示 2^10或1024。Oxa.1fp10 表示（10+1/16+15/256）* 1024 注意：并非所有编译器都支持 C99 打印浮点值123456789101112#include &lt;stdio.h&gt;int main (void)&#123; float a=32000.0; double b=2.14e9; long double c=5.5e-6; printf("%f &amp; %e \n",a,a); printf("%f &amp; %e \n",b,b); printf("%Lf &amp; %Le \n",c,c); getchar(); return 0;&#125; 第三个显示我有点费解，后来想到保证 6位有效数字，就可以理解了 浮点数的上溢和下溢上溢12float toobig = 3.4E38 * 100.0f；printf("%e \n",toobig); 以上 3.4E38 float 最大范围值*正数，超过最大值，会出现上溢，打印显示 inf 或 infinity (或者无穷含义) 下溢 以 十 进 制 为 例， 把 一 个 有 4 位 有 效 数 字 的 数（ 如， 0.1234E-10） 除 以 10， 得 到 的 结 果 是 0.0123E-10。 虽 然 得 到 了 结 果， 但 是 在 计 算 过 程 中 却 损 失 了 原 末 尾 有 效 位 上 的 数 字。 这 种 情 况 叫 作 下 溢（ underflow）。 NaNNOT a number 例 如， 给 asin() 函 数 传 递 一 个 值， 该 函 数 将 返 回 一 个 角 度， 该 角 度 的 正 弦 就 是 传 入 函 数 的 值。 但 是 正 弦 值 不 能 大 于 1， 因 此， 如 果 传 入 的 参 数 大 于 1， 该 函 数 的 行 为 是 未 定 义 的。 在 这 种 情 况 下， 该 函 数 将 返 回 NaN 值， printf() 函 数 可 将 其 显 示 为 nan、 NaN 或 其 他 类 似 的 内 容。[美]史蒂芬·普拉达（Stephen Prata）. CPrimer Plus（第6版）中文版 (Kindle 位置 1840-1842). 人民邮电出版社. 浮点数的舍入错误12345678910#include &lt;stdio.h&gt;int main(void)&#123; float a,b; a=2.0e20 +1.0; b=a-2.0e20; printf("%f \n",b); getchar(); return 0;&#125; 出现这种问题的原因：flaot 的数字只能存储按指数比例缩放或放大的 6或7位有效数字。上面是20位，如果加1就是21位，所以出现错误 大部分总结的内容出自《C Primer Plus 》 书中。总结是为了方便本人理解与学习]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程复习总结]]></title>
    <url>%2F2017%2F11%2F08%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、软件工程概述什么是软件，软件与程序的区别 软件=程序+数据结构+文档 程序是一系列命令代码的集合软件是指一个计算机系统有关程序、过程和有关文档的完整集合 什么是软件危机？其产生的原因 软件危机泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题 用户需求不明确 缺乏正确的理论指导 软件开发规模越来越大 软件开发复杂度越来越高 软件工程的概念及研究内容 软件工程是采用工程的概念、原理、技术、和方法，并结合正确的管理技术和当前能够得到的最先进的技术方法，经济高效地开发和维护软件的一门工程学科。 研究的内容主要是软件开发技术和软件开发管理 软件生存周期的概念及划分 从形成开发软件概念起，所开发的软件使用以后，直到失去使用价值消亡为止的整个过程，成为软件生命周期 定义时期 问题定义 可行性研究 需求分析 开发时期 总体设计 详细设计 编码和单元测试 综合测试 维护时期 维护 常见的软件生存周期模型(各个模型特点) 瀑布模型 快速原型 增量模型 螺旋模型 喷泉模型 变换模型和基于组件的模型 传统软件工程与面向对象软件工程的各自特点 传统软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件。 面向对象软件工程把对象作为融合了数据及在数据上的操作行为的统一的软件构件，把所有对象都划分成了类，按照父类（基类）与子类（派生类）的关系，把若干个相关类组成一个层次结构的系统，对象彼此之间仅能通过发送消息相互联系。 二、可行性研究可行性研究的任务 可行性研究最根本的任务是对以后的行动方针提出建议，若问题值得解，则推荐一个好的解决方案，并制定一个初步的工程计划。若问题没有可行的解，则建议停止开发工程。可行性研究的步骤 （1）分析系统的目的； （2）分析当前系统的状况； （3）当前系统的业务流程； （4）分析当前系统的不足； （5）提出新的目标系统； （6）检查目标系统是否满足要求； （7）制定新系统的技术方案； （8）方案分析比较，对不同的系统开发方案进行分析、比较和论证，选择合理的方案； （9）推荐方案； （10）编制新系统的开发计划； （11）编制可执行的研究报告。 典型的可行性研究： 复查并确定系统规模和目标 研究目前正在使用的系统 建立新系统的高层逻辑模型 导出和评价各种方案 推荐可行的方案 草拟初步的开发计划 编写可行性研究报告提交审查 会绘制业务流程图 三、需求分析需求分析的任务是什么? 确定对目标系统提出的完整、真确、清晰、而且具体的需求 需求分析的步骤 - 确定系统的综合需求 - 分析系统的数据要求 - 创建软件的逻辑模型 - 编写软件需求规格说明书 - 需求验证 结构化分析方法(SA)的要点 结构化分析方法使用简单易读的符号，根据软件内部数据传递、变更的关系，以“分解”和“抽象”为基本原则，按照自顶向下、逐层分解的分析策略，描绘满足功能要求的软件模型。适用于数据处理类型软件，利用半形式化工具“数据流图”和“数据字典”表达需求，简明易懂。 数据流图的作用及绘制要领 数据流图描绘数据在软件中从输入移动到输出的过程中所经受的变换，没有任何具体的物理元素。 分层绘制，采用自顶向下、逐层分解的原则，直到功能细化为止，形成若干层次的数据流图。 面向对象的分析方法（OOA） 是把实体-联系图中的概念与面向对象程序设计语言中的概念结合在一起，形成一种分析方法。面向对象分析的关键是识别、定义问题域内的类与对象，并分析它们之间的关系，根据问题域中的操作规则建立模型。 掌握用例图建模方法 用例模型的建立是由开发者和客户共同协商完成的，通过讨论需求的规格说明达成共识，明确系统的基本功能。 数据字典概念 数据字典是描述数据的信息的集合，是对系统中使用的所有数据元素的定义的集合，是数据流图的补充工具。]]></content>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习(四)]]></title>
    <url>%2F2017%2F11%2F07%2FC%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[_Bool类型c99标准添加了 _Bool 类型，用于表示布尔值（true 和 false）。因为 C 语言用值 1 表示 true，值 0 表示 false，所以 _Bool类型实际上也是一种整数类型 可移植类型: stdint.h和 inttypes.hc99提供了两个头文件 stdint.h 和 inttypes.h 以确保 C语言的类型在各系统中的功能相同。 C语言为现有类型创建了很多类型名。 精确宽度整数类型 int32_t 最小宽度类型 int_least8_t 最快的类型 int_fast8_t 最大的有符号整数类型 intmax_t printf() 打印特定类型时要求与相应的转换说明匹配。1234567891011#include &lt;stdio.h&gt;#include &lt;inttypes.h&gt; //支持可移植整数类型名int main(void)&#123; int32_t me32; //me32是一个32位有符号整型变量 me32=45933945; printf("%d \n",me32); printf("%" PRId32"",me32); //PRId32字符串宏 getchar(); return 0;&#125; printf(“%” PRId32””,me32);等价于 printf(“%”d””,me32); c99/c11 的支持中，一些编译器任未实现 inttypes.h 头文件及其相关功能 扩展整数类型stdint.h和inttypes.h]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习(三)]]></title>
    <url>%2F2017%2F11%2F04%2FC%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[使用字符: char 类型char 类型存储字符(8位存储单元)，从技术层面看，char 是整数类型。ASCII(0~127;只需 8 位的存储单元) 编码 比如：A用整数 65 代表。因此，存储字母 A 实际上存储的是整数 65 字符常量和初始化 如果要把一个字符常量初始化为字母A，不必背下 ASCII 码。用单引号括起来的单个字符被称为字符常量，编译器一发现’A’，就会将其转换成相应的代码值。单引号必不可少1234char abc; //声明char 类型abc='A' //正确abc=A //错误 A 现在是一个变量；abc="A" //错误 A 现在是一个字符串 非打印字符单引号只适用于字符、数字、标点符号 使用 ASCII 转义序列 打印警报12345678#include &lt;stdio.h&gt;int main(void)&#123; char a; a='\a'; printf("%c",a); //打印峰鸣声 return 0;&#125; %c 和 %d 有符号还是无符号 有些 C编译器把 char 实现为有符号类型，表示范围 -128~127 有些 C编译器把 char 实现为无符号类型，表示范围 0~255]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习(二)]]></title>
    <url>%2F2017%2F11%2F03%2FC%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[其他整数类型修饰基本整数类型 short long unsigned short int 或者 short 占用存储空间可能比 int 类型少 long int 或者 long 占用存储空间比 int 多 long long int 或 long long (C99标准加入) 占用的存储空间可能比 long 多。至少占用 64 位。 unsigned int 或 unsigned 只用于非负数的场合。例如 16位 unsigned int 允许取值范围是 0~65535 ，而不是 -32768~32767 。 使用多种整数类型的原因 C语言规定了 short 占用的存储空间不能多于 int long 占用的存储空间不能少于 int 这样的规定是为了适应不同的机器。例如：早期电脑中 int 和 short 类型都占 16 位，long 类型占 32，后来系统都是用 16位存储 short 类型。32位存储 int 类型和 long 类型。现在，计算机普遍为 64 位处理器，为了存储 64 位的整数，才引入了 long long 整型 现在个人计算机最常见的设置是: long long 占 64 位 long 占 32位 short 占 16位 int 占 16位或者 32位(依计算机的自然字长而定) 原则上，这 4 种类型代表 4 种不同的大小，但是实际使用中，有些类型之间通常有重叠 对于 16 位机，short 和 int 的最小取值范围是 [-32767,32767] 对于 32 位机, long 的最小取值范围 [-2147483647,2147483647] unsigned int 和 unsigned short 最小取值范围是[0,65535] unsigned long 最小取值范围 [0,4294967295] 对于 64位 long long 类型比较大，就不说了 long 常量和 long long 常量 当整型存储的数值很大，编译器会一次尝试使用： unsigned int long unsigned long long long unsigned long long 如果要把一个较小的常量当做 long 类型。在值得末尾加上l或L 整数溢出 如果整数超出类型的取值范围会怎么样？ 123456789#include &lt;stdio.h&gt;int main(void)&#123; int i=2147483647; unsigned int j = 4294967295; printf("%d %d %d \n",i,i+1,i+2 ); printf("%u %u %u \n",j,j+1,j+2 ); return 0;&#125; 打印 short、long、long long和 unsigned 打印 unsigned 类型的值，使用 %u 转换说明 打印 long 类型的值，使用 %ld 转换说明 打印 short 类型的值，%hd 表示以十进制显示 short 类型的整数 对于 long long 类型，%lld 和%llu 分别表示有符号和无符号类型 具体代码：123456789101112131415#include &lt;stdio.h&gt;int main(void)&#123; unsigned int un = 3000000000;//int 为 32 位 short 为16 位的系统 short end =200; long big = 65537; long long verybig=12345678909; printf("un = %u and not %d\n",un,un); printf("end = %hd and end %d\n",end,end); printf("big = %ld and big %hd\n",big,big); printf("verybig = %lld and not %ld\n",verybig,verybig); getchar(); return 0;&#125; 在使用 printf() 函数时，切记检查每一个待打印都有对应的转换说明，还要检查转换说明的类型是否与待打印值得类型相匹配]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我反思(17-11-2)]]></title>
    <url>%2F2017%2F11%2F02%2F%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D-17-11-2%2F</url>
    <content type="text"><![CDATA[这两个星期，可能因为面试的事情，没有过多的时间去学习，今天可以算告别面试，最近的事情比较多，需要思考这一段时间出现的问题，以及对以后的路进行反思。 技术是王道 不管你的简历排版有多好，在技术面试的时候总是谈的技术，所以技术才是王道，其他的只不过是给你添加加分项，毕竟一个企业招人，还是为了招能做事的人，能为这个企业带来利益的员工，一般学生素质都差不多，唯一不同的就是学习能力的多少。 学历很重要 不管技术有多强，这个社会总是人外有人，天外有天，学历就是把人化成了三流九等，问题不在于我们排斥这样的社会现状，而是对自己能力的一个质疑，如果比别人弱，我们到底弱到那里，为什么会产生这样的差异，一般来说人都是很了解自己的，唯一不同的是不同的人自制力不同，越是自制力强的人，做事越有条理性。专科的自己，如果现在就职了，很可能一旦跳槽就会面临学历太低，年龄太高，对方不想要的情况，我想自己现在还是又能力继续深造，如果现在放弃了，以后可能就没机会了，毕竟社会的有色眼镜太多。 社会情况 通过这次面试，大概了解了目前还是缺 java 工程师，Android 火爆的情况已经成为过去式，java 那么多年技术也走向成熟了，虽然新兴语言也有些不错，可能目前使用还不够普及，以及文档还不够完善。所以目前需要学习 java 相关的一些知识。当然其他的也不能拉下。 对自己说的 不管以后有多难找工作，在校的时候，坚持学习总是没有错的，我们在学习技术同时，也要关注未来的一个趋势，比较我们需要同过自己喜欢的技术养活自己，才能在这条路上走得更远，要想出了社会让别人尊重自己，就需要先让自己变得很强大，接下来的日子里，需要以专升本为主学习，并把比赛的事情好好准备，空闲的时间 看一下 java 和 算法 、数据结构的知识，先打好地基，否则很难有太高的成就。 作息时间安排 这两个星期，没有很好的安排作息时间，很明显感到身体的疲惫，今天上去谈 offer 吐了三次，熬夜还是不要了，以后要想过得很好，还得需要很长的一段路去走，坚持！！！ 总有一天实现梦想！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Gson学习]]></title>
    <url>%2F2017%2F10%2F30%2FAndroid-Gson%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[GsonGson 是 google 推出的工具库(JSON解析库)。不用写任何解析代码，Gson 就能自动把 JSON 数据映射到 Java 对象 官方文档官方用户指南 使用 Gson官方使用指南 导入依赖 123dependencies &#123; compile 'com.google.code.gson:gson:2.8.2'&#125; Gson 基本用法 创建 Gson 对象1Gson gson=new Gson(); 主要用法 123456789101112131415// Serialization(序列化)Gson gson = new Gson();gson.toJson(1); // ==&gt; 1gson.toJson("abcd"); // ==&gt; "abcd"gson.toJson(new Long(10)); // ==&gt; 10int[] values = &#123; 1 &#125;;gson.toJson(values); // ==&gt; [1]// Deserialization(反序列化)int one = gson.fromJson("1", int.class);Integer one = gson.fromJson("1", Integer.class);Long one = gson.fromJson("1", Long.class);Boolean false = gson.fromJson("false", Boolean.class);String str = gson.fromJson("\"abc\"", String.class);String[] anotherStr = gson.fromJson("[\"abc\"]", String[].class); toJson()：用于将Java对象转换为相应的JSON数据fromJson：用于将JSON数据转换为相应的Java对象 对象用法123456789101112131415161718class BagOfPrimitives &#123; private int value1 = 1; private String value2 = "abc"; private transient int value3 = 3; BagOfPrimitives() &#123; // no-args constructor &#125;&#125;// Serialization(序列化)BagOfPrimitives obj = new BagOfPrimitives();Gson gson = new Gson();String json = gson.toJson(obj); // ==&gt; json is &#123;"value1":1,"value2":"abc"&#125;//Deserialization(反序列化)BagOfPrimitives obj2=gson.fromJson(json,BagOfPrimitives.class); 数组用法1234567891011Gson gson = new Gson();int[] ints = &#123;1, 2, 3, 4, 5&#125;;String[] strings = &#123;"abc", "def", "ghi"&#125;;// Serialization序列化gson.toJson(ints); // ==&gt; [1,2,3,4,5]gson.toJson(strings); // ==&gt; ["abc", "def", "ghi"]// Deserialization反序列化int[] ints2 = gson.fromJson("[1,2,3,4,5]", int[].class);// ==&gt; ints2 will be same as ints json原先是数组对象，反序列化为java数组对象 集合用法 123456789Gson gson = new Gson();//创建 Gson 对象Collection&lt;Integer&gt; ints = Lists.immutableList(1,2,3,4,5); //创建一个int 的集合清单后面表示，创建一个不可变集合// SerializationString json = gson.toJson(ints); // ==&gt; json is [1,2,3,4,5]// DeserializationType collectionType = new TypeToken&lt;Collection&lt;Integer&gt;&gt;()&#123;&#125;.getType();Collection&lt;Integer&gt; ints2 = gson.fromJson(json, collectionType);// ==&gt; ints2 is same as ints 关于 immutable关于 TypeToken]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-处理 JSON数据(PhotoGallery应用)]]></title>
    <url>%2F2017%2F10%2F29%2FAndroid-%E5%A4%84%E7%90%86-JSON%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[解析 JSON 数据 这是通过使用 google 插件 postman 排好的格式 json.org API 提供有对应 JSON 数据的 Java 对象如 JSONObject 和 JSONArray。 使用 JSONObject(String) 构造函数，可以把 JSON 数据解析进相应的 Java 对象。 1JSONObject jsonObject=new JSONObject(jsonString); 当将 json 字符串传入 JSONObject 对象后,会生成与原始 JSON 数据对应的对象树,如上图。 获取对应图片的信息并创建模型类创建 GalleryItems ,并在网络类创建一个方法获取每张图片信息，需要获取的信息为模型类的字段 id title url_s 123456789101112131415161718192021222324/*创建 parseItems() 获取 json字符串中我们想获得的并添加给 模型层*/ private void parseItems(List&lt;GalleryItem&gt; items, JSONObject jsonObject) throws JSONException &#123;// 获取 JSONObject JSONObject jsonObject1 = jsonObject.getJSONObject("photos");// 获取对象里面的数组 JSONArray jsonArray = jsonObject1.getJSONArray("photo");// 循环遍历找出每一个对应的标题和id for (int i = 0; i &lt;= jsonArray.length(); i++) &#123;// 获取每一个 JSONObject 对象 JSONObject eachJSONObject=jsonArray.getJSONObject(i);// 创建一个模型层的类，用于添加信息 GalleryItem item= new GalleryItem(); item.setId(eachJSONObject.getString("id")); item.setCaption(eachJSONObject.getString("title"));// 检查 是否有 url_s 的键 if(!eachJSONObject.has("url_s"))&#123; continue; &#125; item.setUrl(eachJSONObject.getString("url_s")); items.add(item); &#125; &#125; 创建 ViewHolder 和 Adapter 内部类 实现 RecyclerView 的视图以及数据加载(代码部分省略) 从 AsyncTask 回到主线程 我们需要注意的是在后台我们获取了数据，需要把数据适配到前台中，不能再后台线程中调用设置适配器。在计算机里，内存对象间步调不一致冲突会让应用崩溃，所以不允许从后台更新 UI 线程 回顾AsyncTask 使用 onPostExecute(Result)1234567891011121314151617181920/*创建一个 AsyncTask 的内部类，后台处理网络*/private class FetchItemsTask extends AsyncTask&lt;Void, Void, List&lt;GalleryItem&gt;&gt; &#123; @Override protected List&lt;GalleryItem&gt; doInBackground(Void... voids) &#123;// 获取网络中的String 数据 /* String result = new FlickerFerchr() .getUrlString("http://www.bignerdranch.com");// log 显示 String Log.i("TAG","Fetched contents of URL:+"+result);*/ return new FlickerFerchr().fetchItems(); &#125; @Override protected void onPostExecute(List&lt;GalleryItem&gt; items) &#123; mItems = items; setupAdapter(); &#125;&#125; 运行结果 清理 AsyncTask 一开始我们保留了 fragment(调用了 setRetainInstance(true) )，这样即使设备旋转，也不会重复创建新的 AsyncTask 去获取 JSON 数据。但是有些时候必须掌控它，让他能够随时撤销或重新运行 AsyncTask AsyncTask.cancel(boolean)撤销 温和的(false) 粗暴的(true) 第一种，传入参数为 false ,它可能温和的设置 isCancel() 的状态，然后提前结束运行 第二种,传入参数为 true ,它会粗暴地终止 doInBackground() 方法当前所在的线程，应尽量避免使用这种方式 什么时候使用撤销? 当 fragment 和 activity 已经销毁了或者看不到了，就在 onStop() 方法里(看不到视图)，或者 onDestory()方法里(fragment/activity) 实例已销毁撤销 AsyncTask 实例 fragment 和 activity 已经销毁了 不去销毁 AsyncTask 可能引发内存泄漏,也可能出现 UI 更新问题]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单算法(三)]]></title>
    <url>%2F2017%2F10%2F27%2F%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[快速排序思路:对一组数据找到一个基准数，用这个基准数做参考，小于它的放右边(左边)，大于它的放左边(右边),然后左右两边同样实现这样的排序,直到都符合规则 直接上原书的图《坐在马桶上学算法》 算法难点: 使用左右两边的数据 以左边的数作为基准数 先从右边开始找比基准数小的点(从大到小排序) 当右边找到比基准数小的点，左边找到比基准数大的点时，交换两个位置的值，然后继续 当左右两点位置相等时，将该位置点与左边 1 位置交换 左右两边分别重复上面的步骤，直到一边没有数据只剩下一个结束这样的循环 这是具体的一个交换流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;int a[101],n; // 定义全局变量void quicksort(int left,int right)&#123; int i,j,t,temp; if(left&gt;right) &#123; return; &#125; temp=a[left];//temp 中存的就是基准数 i=left; j=right; while(i!=j) //两边不想交就一直循环 &#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j) //顺序很重要 先从右边找 &#123; j--; //在找左边 &#125; while(a[i]&lt;=temp &amp;&amp; i&lt;j) &#123; i++; &#125; if(i&lt;j) &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; // i等于j a[left]=a[i]; //最左边为停止的数字 a[i]=temp; //停止的为基准数 quicksort(left,i-1); //左边的继续 quicksort(i+1,right); //右边的继续&#125;int main(void)&#123; int x; printf("请输入需要排序的个数:"); scanf("%d",&amp;n); for(x=1;x&lt;=n;x++) &#123; scanf("%d",&amp;a[x]); &#125; quicksort(1,n); //快速排序调用 for(x=1;x&lt;=n;x++) &#123; printf("%d ",a[x]); &#125; getchar(); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 网络连接(PhotoGallery应用)]]></title>
    <url>%2F2017%2F10%2F27%2FAndroid-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[基本网络连接GitHub 地址:关于联网显示图片的应用 前期准备 fragment + recyclerView 实现基本框架，这就不说了，前面有介绍过，没总结过 http 与后台的知识 设置网络类 创建一个类，并实现两个方法分别用来获取数据的字节流并把字节流转化为字符串 1234567891011121314151617181920212223242526272829303132333435public class FlickerFerchr &#123; public byte[] getUrlBytes(String urlSpec) throws IOException &#123;// 创建 URL 对象将 url 字符串转换为URL URL url = new URL(urlSpec); // 创建连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); try&#123;// 实例化字节流 ByteArrayOutputStream out = new ByteArrayOutputStream();// getInputStream() 连接 InputStream in = connection.getInputStream();// 判断是否连接成功 if (connection.getResponseCode()!=HttpURLConnection.HTTP_OK)&#123; throw new IOException(connection.getResponseMessage()+"with:"+urlSpec); &#125; int bytesRead=0; byte[] buffer=new byte[1024];// 循环读取,读取一定数量字节放入缓存区数组buffer，并以整数形式返回实际读取的字节数 while ((bytesRead=in.read(buffer))&gt;0)&#123; out.write(buffer,0,bytesRead); &#125;// 关闭输出流 out.close(); return out.toByteArray(); &#125;finally &#123; connection.disconnect(); &#125; &#125; public String getUrlString(String urlSpec) throws IOException &#123; return new String(getUrlBytes(urlSpec)); &#125;&#125; 获取网络使用权限 1&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 使用 AsyncTask 在后台线程上运行代码 我们前面都是使用的 UI 线程，当进行网络访问的等操作，如果还在 UI 线程上，会出现程序不响应，是否结束任务的提示，所以使用 AsyncTask 工具类创建一个后台线程处理网络请求 123456789101112131415161718/*创建一个 AsyncTask 的内部类，后台处理网络*/private class FetchItemsTask extends AsyncTask&lt;Void,Void,Void&gt;&#123; @Override protected Void doInBackground(Void... voids) &#123;// 获取网络中的String 数据 try &#123; String result = new FlickerFerchr() .getUrlString("http://www.bignerdranch.com");// log 显示 String Log.i("TAG","Fetched contents of URL:+"+result); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 启动后台线程 12// 执行AsyncTask new FetchItemsTask().execute(); 线程与主线程网络连接需要时间。Web 服务器也需要时间响应请求，文件下载则需要更长的时间。Android 禁止任何主线程网络连接行为。如果 Android 也会抛出 NetworkOnMainThreadException 异常线程：单一执行序列，单个线程代码会逐步执行。Android 应用运行从主线程开始，但它并不是线程那样的预定执行序列。相反，它是一个无限循环的运行状态，等待用户或者系统触发的事件的发生。事件触发后,主线程便负责执行代码. 从 Flickr 获取 JSON 数据 前面的网站虽然通过 web 可以进行访问，但是并没有返回我们可以使用时信息，我们通过 Flickr 提供的 JSON API 获取我们想要的信息，并显示到我们的应用上 下面是我自己建立的，这个过程耗费我两天，因为flickr 创建的 key 一直不生效，最后发现是权限为私有，打开为公有还要上传照片、添加标签、添加 url 最后才能修改 https://api.flickr.com/services/rest/?method=flickr.photos.getRecent&amp;api_key=461a0d44890535444f94fd9d9643b6b6&amp;format=json&amp;nojsoncallback=1 构建 url123456789101112131415161718 /*创建一个构造url的方法*/public void fetchItems()&#123; try &#123;// 构建url 字符串供 getUrlString 方法使用 String url =Uri.parse("https://api.flickr.com/services/rest/") .buildUpon() .appendQueryParameter("method","flickr.photos.getRecent") .appendQueryParameter("api_key","461a0d44890535444f94fd9d9643b6b6") .appendQueryParameter("format","json") .appendQueryParameter("nojsoncallback","1") .appendQueryParameter("extras","url_s") .build().toString(); String jsonString=getUrlString(url); Log.e("TAG","JSON: "+jsonString); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 重新修改后台访问网络连接123456789101112131415/*创建一个 AsyncTask 的内部类，后台处理网络*/ private class FetchItemsTask extends AsyncTask&lt;Void,Void,Void&gt;&#123; @Override protected Void doInBackground(Void... voids) &#123;// 获取网络中的String 数据 /* String result = new FlickerFerchr() .getUrlString("http://www.bignerdranch.com");// log 显示 String Log.i("TAG","Fetched contents of URL:+"+result);*/ new FlickerFerchr().fetchItems(); return null; &#125; &#125; Console 台显示 json 字符串]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入学习: 进程与任务]]></title>
    <url>%2F2017%2F10%2F27%2F%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[进程与任务 对象 需要内存和虚拟机的支持才能存在 进程 是操作系统创建的、供应用对象生存以及应用运行的地方 进程 通常占用系统的资源，如内存、网络接口、打开的文件·进程拥有至少一个(可能多个)执行线程。 在 Android 系统中, 进程 总会有一个运行的虚拟机 Android 世界里的每个应用组件都仅与一个进程相关联。应用伴随着自己的进程一并创建,该进程同时也是应用中所以组件的默认进程 每个 activity 实例都仅存在于一个进程和一个任务中。 任务只包含 activity,这些 activity 通常来自于不同的应用 而 进程 则包含应用的全部代码和对象 进程与任务的区别实例1: 当启动一个应用的同时会创建与之对应的进程 当应用中设置了跳转到其他应用的操作，比如联系人 activity 会被添加到这个应用的任务中,然而它也创建了一个联系人应用的进程，当用户后退在不同 activity 间切换过程中，可能不会意识到他们正在进程间的切换 实例2: 情况android 的所有应用，然后启动这个应用，重复启动联系人应用，然后按主屏幕键回到主屏幕点击联系人应用，并添加联系人实例，关系如下图 通过这两个实例可以看出 任务可以说是进程的分支，进程的概念比任务要大，通常任务管理器结束的任务，其实是关于这个应用的进程 下面是别人写的我认为说的很好，可能没有学过操作系统，关于这方面的知识比较欠缺，理解能力也有限，以后会学习这方面的知识 相关链接]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析 Intent(二)]]></title>
    <url>%2F2017%2F10%2F25%2F%E8%A7%A3%E6%9E%90-Intent-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[前一节利用 PackageManager 查询系统所以有 Main 的 Activity,显示实现点击后进入各应用,创建显式 Intent 进行打开。 创建监听器 ResolveInfo 对象获取 activity 的包名与类名 。从 ResolveInfo 对象的 ActivityInfo 中获取 1234567891011@Overridepublic void onClick(View view) &#123;// 从 ResolveInfo 获取包名或类名 ActivityInfo activityInfo=mResolveInfo.activityInfo;// 创建 Intent 对象 Intent i=new Intent(Intent.ACTION_MAIN) .setClassName(activityInfo.applicationInfo.packageName,activityInfo.name);// 启动 Intent startActivity(i);&#125; 任务与后退栈任务:通俗讲就是用户关心的 activity栈，当我们点击打开一个应用就将主 activity弹到栈顶，用户看到的是栈顶，当我们点击后退键，回到系统主屏幕 通过几个场景理解任务与栈 场景1：我们点开应用在应用中点击启动不同的 activity 返回键总是能返回到我们上一个页面，这就是 activity 栈 场景2：任务键的切换，玩过 Android 的用过 场景3：可能会想到底要说什么 o(╥﹏╥)o 说明这个自动其他应用的任务与栈与其他的不同：当我们在这个应用点击其他应用，应该会两个任务事实上当启动其他的 activity栈 添加到了自己的任务中 如果我们需要在启动新任务的 activity ，可以让应用拥有自己的任务，用户可以在运行的应用间自由切换，需要给 Intent 添加一个标志，作用是告诉系统我要让启动的activity 创建一个任务 123Intent i=new Intent(Intent.ACTION_MAIN) .setClassName(activityInfo.applicationInfo.packageName,activityInfo.name) .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 让 NerdLauncher 应用 作为设备主屏幕 这好比 是吧这个应用设置为主屏幕，其他应用返回的 栈底部 activty ,一般设置为主屏幕的为主题应用。 现在你的手机主题 就是这个应用了。如果不小心设置了可以点击 Setting 应用——&gt; Apps——&gt; 选择这个应用请出默认 ——&gt; 点击主屏幕 选择系统，然后删除该应用 获取各个应用的图标ResolveInfo.loadLabel() 方法获取各个 activity 名称,ResolveInfo还提供 loadIcon() 的方法,为每个应用加载显示图标 创建布局模板 list_item (一个视图一个文本) ViewHolder 使用这个布局加载 实例化两个控件 包名前面通过 loadLabel() 方法获取 现在通过 loadIcon() 获取图标 这个很简单就不上代码了。 本应用 GtiHub 地址:NerdLauncher 应用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单算法(二)]]></title>
    <url>%2F2017%2F10%2F25%2F%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[冒泡排序 针对前一节讲的 “桶排序” 的问题，当我们处理很大的数据，如：0~200000000，这种范围的数据，需要申请一个 200000000 的变量：这种非常浪费空间！，如果要进行小数的排序，显然这种”桶排序” 是无法解决这些问题的，接下来介绍冒泡排序 基本思想：每次比较两个相邻的元素,如果他们的顺序不对(就是不符合这样排序的)就把他们交换过来。 “冒泡排序” 原理是:每一趟只能确定将一个数归位。如果有 n 个数进行排序，就需要进行 n-1 趟. 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main(void)&#123; //定义输入的个数最多有多少个 int a[100],i,j,t,n; printf("请输入你想排序的个数:"); scanf("%d",&amp;n); //循环 n 个数到数组中 for(i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;a[i]); &#125; //n个数的排序，只进行 n-1 次 for(i=1;i&lt;=n-1;i++) &#123; //这个 for 循环进行比较的次数 比如： 三个数 第一趟： 比较 3-1次 第二趟：3-2 // j表示的是数的位置 for(j=1;j&lt;=n-i;j++) &#123; if(a[j]&lt;a[j+1]) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; //输出结果 for(i=1;i&lt;=n;i++) &#123; printf("%d ",a[i]); &#125; getchar(); return 0;&#125; 如何实现带有姓名和分数的排序？ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;struct student&#123; char name[21]; char score;&#125;; //创建结构体储存姓名和分数int main(void)&#123; struct student a[100],t; int i, j , n; printf("请输入要排序的数目: \n"); scanf("%d",&amp;n); //循环读入姓名和分数 for(i=1;i&lt;=n;i++) &#123; scanf("%s %d",a[i].name,&amp;a[i].score); &#125; //循环遍历的趟数 for(int i=1;i&lt;=n-1;i++) &#123; for(int j=1;j&lt;=n-i;j++) &#123; if(a[j].score&lt;a[j+1].score) &#123; t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; //输出排序后的名字 for(int i=1;i&lt;=n;i++) &#123; printf("%s \n",a[i].name); &#125; return 0;&#125; 冒泡排序的核心部分是双重嵌套循环。时间复杂度 O(N2) 下一节 –快速排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析 Intent]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%A7%A3%E6%9E%90-Intent%2F</url>
    <content type="text"><![CDATA[应用获取设备上的可启动应用，会使用 PackageManager 获取所有可启动主 activity。你可能会发现每一个应用都有一个主启动 activity 在注册清单上都有如下 1234&lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt;&lt;/intent-filter&gt; 新增 setupAdapter() 方法 负责隐式 intent 并从 PackageManager 那里获取匹配它的所有 activity 1234567891011private void setupAdapter() &#123;// 创建一个隐式 Intent 添加分类选择 Intent startupIntent = new Intent(Intent.ACTION_MAIN); startupIntent.addCategory(Intent.CATEGORY_LAUNCHER); PackageManager pm = getActivity().getPackageManager();// 利用 pm 查询所有 startupIntent 的 activity 返回给 list 列表 List&lt;ResolveInfo&gt; activities = pm.queryIntentActivities(startupIntent, 0);// log 打印含有多少个 activities Log.i(TAG, "activities have ："+activities.size()); &#125; 通过 ResolveInfo 对象中，可以获取 activity， ResolveInfo这个类是通过解析一个与IntentFilter相对应的intent得到的信息。它部分地对应于从AndroidManifest.xml的&lt; intent&gt;标签收集到的信息。 我们通过 log 可以看到我们获取的 activity 现在我们完善 RecyclerView 实现数据与视图的绑定 ViewHolder 1234567891011121314151617181920/*ViewHolder 内部类显示标签名*/ private class ActivityHolder extends RecyclerView.ViewHolder &#123; // 创建引用信息加载获取用户标签 // 初始化显示控件 private ResolveInfo mResolveInfo; private TextView mNameTextView; public ActivityHolder(View itemView) &#123; super(itemView); mNameTextView = (TextView) itemView; &#125; public void bindActivity(ResolveInfo resolveInfo) &#123; mResolveInfo = resolveInfo; PackageManager pm = getActivity().getPackageManager(); String appName=mResolveInfo.loadLabel(pm).toString(); mNameTextView.setText(appName); &#125; &#125; Adapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*ViewHolder 内部类显示标签名*/private class ActivityHolder extends RecyclerView.ViewHolder &#123;// 创建引用信息加载获取用户标签 private ResolveInfo mResolveInfo;// 初始化显示控件 private TextView mNameTextView; public ActivityHolder(View itemView) &#123; super(itemView); mNameTextView = (TextView) itemView; &#125; public void bindActivity(ResolveInfo resolveInfo) &#123; mResolveInfo = resolveInfo; PackageManager pm = getActivity().getPackageManager(); String appName=mResolveInfo.loadLabel(pm).toString(); mNameTextView.setText(appName); &#125;&#125;/* Adapter 内部了实现数据*/private class ActivityAdapter extends RecyclerView.Adapter&lt;ActivityHolder&gt; &#123;// 初始化数据变量 private final List&lt;ResolveInfo&gt; mActivities;// 构造方法获取 activities private ActivityAdapter(List&lt;ResolveInfo&gt; activities) &#123; mActivities = activities; &#125;// 创建列表布局视图样式 @Override public ActivityHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(getActivity()); View view = layoutInflater.inflate(android.R.layout.simple_list_item_1, parent, false); return new ActivityHolder(view); &#125;// 获取每个activity 信息 并与ViewHolder 进行数据传递并绑定 @Override public void onBindViewHolder(ActivityHolder holder, int position) &#123; ResolveInfo resolveInfo = mActivities.get(position); holder.bindActivity(resolveInfo); &#125;// 获取整个 list 数据 @Override public int getItemCount() &#123; return mActivities.size(); &#125;&#125; 最后在 startupAdapter 方法下给 RecyclerView 添加Adapter,因为适配器所需要的参数，就是该方法获取到的 activity 信息1mRecyclerView.setAdapter(new ActivityAdapter(activities)); 明天解决点击后跳转到其他应用 ヾ(◍°∇°◍)ﾉﾞ]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习]]></title>
    <url>%2F2017%2F10%2F23%2FC%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[概念 C是强大而简洁的编程语言。 编程机制 C编译器和链接器是把C语言源代码转换成可执行代码的程序。上图可知我们将源代码输入到编译器，生成机器语言的目标代码通过连接器把目标代码和库代码、启动代码结合生成可执行代码。启动代码在不同的系统下略有不同。 C语言的语法大概举一些例子 每个程序必须包含一个 main() 函数 声明语句 分号结尾 函数体是花括号 stdio.h 是输入输出的函数在声明语句中不引用它，就不能使用 printf 和 scanf 函数 关键字不能作为函数名称 注意 C语言的 数据类型，没有 string 注释 /**/ 占位符的使用 %d %s %c %f 代表的意思 要使用函数前先要声明函数 。。。。 数据和 C关键字： int short long unsigned char float double _Bool _Complex _Imaginary 运算符： sizeof() 返回一个变量内容的大小函数：scanf() 练习 float 相关：1234567891011#include &lt;stdio.h&gt;int main(void)&#123; float weight;//重量 float value; //相等的白金价格 printf("输入白金的重量？"); scanf("%f",&amp;weight); value=1700 *weight *14.5833; printf("你的白金价值：%.2f",value); return 0;&#125; %f 占位符替换浮点类型 &amp;weight 代表 scanf 函数获取用户的值赋值给 weight 数据类型关键字 根据计算机的存储类型分为两个基本类型： 整数类型 浮点数类型 位、字节和字 位：最小的存储单元(bit) 位是计算机内存的基本构建块 字节：最常用的计算机存储单位(byte) 1byte = 8 bit 字：设计计算机给定的自然存储单位。32位的微型计算机，一字长32位 整数概念：没有小数部分的数 如：22 -44 。计算机以二进制数存储整数，例如 7，二进制为 111 浮点数与整数相反: 如 2.75 3.18E2 4.00 2e-2 。3.18E2：表示 3.18 X 100(3.18 乘以 10 的二次方)E后面的表示10的指数计算机把浮点数分成小数部分和指数部分分别表示以及存储这两部分。 C语言的基本数据类型int 类型概念：int 类型是有符号整型，必须为整数可以为正整数、负整数或零 声明 int 变量 1int one,two,three; 变量获取值： 赋值 函数获取 初始化赋值 -_-|| 其实就是初始化变量同时赋值 变量创建和存储空间 12345678910#include &lt;stdio.h&gt;int main(void)&#123; int ten = 10; int two = 2; printf("%d minus %d = %d \n",ten,two,ten - two); printf("%d minus %d is %d \n",ten); return 0;&#125; 由于没有给后面两个参数赋值，所以打印出的值是内存的任意数 八进制与十六进制 通常 C语言都假定整型常量是十进制数。程序员喜欢八进制和十六进制，因为他们是 2 的幂，而 10 不是。例如：十进制 65536 经常出现在 16 位机中，用十六进制表示 10000 。十六进制数的每一位都是 4 位二进制数表示。例如， 十六进制 3 是 0011 ，5是 0101 。十六进制数 35 组合 00110101. 这种方式使得二进制与十六进制转换非常方便。 0X前缀表示 十六进制 而八进制的前缀为 0 显示八进制和十六进制 显示十进制的数字 %d 显示八进制的数字 %o 显示前缀 %#o 显示十六进制的数字 %x 显示前缀 %#x 12345678#include &lt;stdio.h&gt;int main(void)&#123; int x = 100; printf("dec = %d; octal = %o;hex = %x \n;" , x , x , x); printf("dec = %d; octal = %#o;hex = %#x \n" , x , x , x); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel VBA基础语法]]></title>
    <url>%2F2017%2F10%2F19%2FExcel-VBA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据类型 常量和变量12Dim 变量名 As 数据类型Dim i As String String 可以存20亿个字符，如果我们声明定长的 String 变量1Dim i As String*10 使用类型声明符只有部分有 12Dim str$表明这是字符串的变量 声明多个变量1Dim str As String,nu As Integer Variant如果不声明数据类型默认 Variant 变体型 默认会根据赋值的类型自己判断 强制声明所有变量 Option Explicit在模块的第一句手动输入代码：会提示你变量没有规定数据类型 三种语法 123public Dim str As String 公共变量private Dim str As String 私有变量static Dim str As String 静态变量 变量的作用域 单个过程 单个模块 所有模块 使用变量1Set str = “hello” 给对象变量赋值时 必须加 Set 123456Option ExplicitSub test() Dim a As Range Set a = Range(&quot;A3&quot;) a = &quot;123&quot;End Sub 使用常量 1Dim str As String = &quot;123&quot; 使用数组123Dim 数组名(a to b) As 类型Dim 三年级1班(1 To 50) As StringDim box位置(1 To 50，1 To 50) As String 赋值12三年级1班(1) = &quot;张三&quot;box位置(1，2) = &quot;张三&quot; 动态数组1Dim 数组名称() 最近超级不在状态，可能没有休息过来，每天都有课，有点厌倦了，有些课一点都没有意思，总感觉现在的课让我越来越缓慢，可能我的大脑能有点着急┭┮﹏┭┮]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vultr 搭建 VPS]]></title>
    <url>%2F2017%2F10%2F18%2FVultr-%E6%90%AD%E5%BB%BA-VPS%2F</url>
    <content type="text"><![CDATA[不废话，这是一篇关于购买 vps 搭建 科(v)学(p)上(n)网的教程，包括服务器的优化 获取 VPS官方网站进入注册 注册 充值 购买vps 搭建 对于充值 支持支付宝，推荐充值 10$ 也就是60多，Vultr 是按小时收费的，你所购买的类型每月有上限，超过这个上限不收费。比如 ： 2.5$ 每月的服务器，一个小时 0.004 一月按照 670 小时 也就是28天计算。充一次用很久 选择 vps 2.5$ 每月 只有 Miami 和 New York了 然后直接确定部署 现在我们需要下载一个软件去连接它，当天它自己也提供了连接，但是不推荐，因为后面有很长命令，不能粘贴复制 Xshell 5百度云盘链接：http://pan.baidu.com/s/1kVehzSV 密码：uy5w 第一步:创建 名称随便，主机是在注册页面的ip 端口号 22，账号 root 密码 如下图。 连接成功 然后开始配置文件 搭建 Shadowsocks安装组件123$ yum install m2crypto python-setuptools$ easy_install pip$ pip install shadowsocks 安装完成后配置服务器参数1$ vi /etc/shadowsocks.json 多端口的如下：123456789101112&#123; &quot;server&quot;:&quot;47.x.x.x&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: &#123; &quot;7777&quot;: &quot;password1&quot;, &quot;8888&quot;: &quot;password2&quot; &#125;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 然后保存退出。 vi 的命令: 按 “i” 进入编辑模式，编辑后按 “esc” 退出编辑模式， 输入 “:wq” 保存退出vi。 配置防火墙 1234# 安装防火墙$ yum install firewalld# 启动防火墙$ systemctl start firewalld 启动 Shadowsocks 服务推荐直接第二个1$ ssserver -c /etc/shadowsocks.json 如果想干点其他的实现后台运行，使用1nohup ssserver -c /etc/shadowsocks.json &amp; 连接 Shadowsocks VPS加速引擎：Linux版锐速全自动安装包 不废话 直接别人总结很好VPS加速引擎：Linux版锐速全自动安装包]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel VBA 速记]]></title>
    <url>%2F2017%2F10%2F17%2FExcel-VBA-%E9%80%9F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本节目录: VBA VBA 面板 试写一个简单的 VBA 程序 VBAVBA(Visual Basic For Application)是一种建立在 Office 中的编程语言。上一节讲了宏，顺便引出 VBA,录制宏就是一种 VBA 程序，只不过这个程序是自己生成的。在使用 Excel 过程中有很多不能用宏解决的问题，比如循环，做复杂操作…. 只有我们进入 VBA 编程，自己编写宏。 VBA 面板 打开方式： alt+F11 查看宏 ——&gt; 编辑 开发工具选项卡 ——&gt; 查看代码 工作区 ——&gt; 右键菜单 ——&gt; 查看代码… 试写一个简单的 VBA 程序添加或删除模块不多说，直接上图，简单明了 开始编写双击模块 ——&gt; 插入菜单 ——&gt; 过程 ——&gt; 命名并确定中间添加123Public Sub mysub() MsgBox &quot;学习 VBA hahahahha&quot;End Sub 然后点击运行 一键查询F1 查询,比如刚才的 MsgBox 是什么意思? 选择 MsgBox 按 F1]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 虚拟机和 Docker 虚拟机冲突]]></title>
    <url>%2F2017%2F10%2F15%2FAndroid-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C-Docker-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%B2%E7%AA%81%2F</url>
    <content type="text"><![CDATA[当最近下载 Docker 并学习 Docker 相关知识发现不能启动 android 虚拟机了 问题 Android studio 启动模拟器报错-Turn off Hyper-V2. 解决虽然网上查询资料，但都没有解决【Hyper-V】与【VirtualBox】【VMware】 虚拟机冲突的问题，但是有两个解决方案 在 VMware 里的系统进行操作 如果两个类型的虚拟机在 windows 上可通过 关闭与打开 Hyper -V (比较麻烦，需要重启) 打开控制面板 ——&gt; 卸载 ——&gt; 启动或关闭 windows 功能 ——&gt; 选择关闭打开 Hyper -V 相关链接1相关链接2]]></content>
      <categories>
        <category>问题汇总</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel 初学宏]]></title>
    <url>%2F2017%2F10%2F15%2FExcel-%E5%88%9D%E5%AD%A6%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[本节目录: 宏的定义 实现工资条的宏 定义宏的按钮 定义宏的快捷功能区 宏安全 宏的定义什么是宏? 通俗讲就是类似与 gif 动态图，重复做一系列操作，对于宏，就是重复录制的操作，录制的不是图像，而是在重复操作的过程。宏方便于大批量的操作，使用宏可以做到一键操作。 实现工资条的宏是否遇到过一下形式的 excel 方便打印后裁剪 通常我们的表格是这样的 实现1：使用ctrl + c和 ctrl + v 实现 这种方式对于数量较小的操作可能比较方便，当遇到大量的数据推荐使用宏定义。 实现2：使用宏 步骤1：选取行的第一个单元格定位 ——&gt; 录制宏 ——&gt; 操作1：辅助第一行 ——&gt; 操作2：插入辅助到第三行 ——&gt; 停止录制 定义宏的按钮插入一个宏按钮，进行宏操作 定义宏的快捷功能区有时候我们经常使用的宏，相同的操作我们不希望每次都打开录制，我们可以把我们的这个按钮放到快捷功能区里。 宏安全有时候在工作中打开文档，不能使用宏，因为设置了宏安全为高级，禁用了宏。我们可以通过宏安全选项，取消禁用]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Master-Detail]]></title>
    <url>%2F2017%2F10%2F14%2FAndroid-Master-Detail%2F</url>
    <content type="text"><![CDATA[本节目录: 主从用户界面 增加布局灵活性 使用别名系统 fragment 回调接口 主从用户界面本来对应手机设备，一般都是单版面，上图这种双版面可以叫做主从界面 增加布局灵活性 手机的布局都是单版面(single-pane) 在平板上，因为同时显示主从用户的界面，我们需要生成双版面(two-pane)布局 如何实现? 修改托管 fragment 的 setContentView 方法 创建两个 fragment 容器布局 修改托管的 Activity 实现在手机中显示单版面，在平板上实例化双版面 具体到项目: 修改布局，从单版面修改为双版面 给父类 SimpleFragmentActivity 中的加载 fragment 改为 获取布局的方法 分别给水平，垂直布局修改布局 覆写 getLayoutResID 返回 需要加载的布局 使用别名系统别名系统是一种指向其他资源的特殊资源 在 res/values 创建refs.xml 别名资源文件 创建默认的别名资源值 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;item name="activity_masterdetail" type="layout"&gt; @layout/activity_fragment &lt;/item&gt;&lt;/resources&gt; 创建规定屏幕范围的资源值 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;item name="activity_masterdetail" type="layout"&gt; @layout/activity_twopane &lt;/item&gt;&lt;/resources&gt; 上面两种别名资源，可以通过设备屏幕的大小改变不同的布局文件。 当屏幕小于 600dp 将使用 R.layout.activity_fragment 单版面布局 当屏幕大学 600dp 将使用 R.layout.activity_twopane双版面的布局 fragment 回调接口 当我们在双版面的情况下，不在启动新的页面，在第一个页面的 fragment 中的点击事件获取第二个页面的 FragmentManager ，然后提交一个 fragment 事务，将第二个 Fragment 添加到双版面的布局。虽然这种方法行的通。 fragment 天生是独立的开发构件。如果用 fragment 用来添加其他 fragment 到 activity 的 FragmentManager，那么这个 fragment 就必须知道托管 activity 是如何工作的。 托管 activity 将实现回调接口，履行托管 fragment 的任务 接口回调是用接口句柄来得到并调用实现这个接口的子类的引用 在 fragment 定义回调接口，托管 activity 强制转化为 CallBacks 对象并赋值给 CallBacks 类型变量(强制转化的目的是托管 activity 必须实现回调接口，这种机制将 fragment 需要完成的事务托管给 activity) 托管的 activity 实现 .CallBacks 接口 实现接口的方法，方法内写事务 实例: 当为手机设备，启动 activity 当为平板设备，将 fragment 放入 双版面的详情页面 以下是实现接口的回调方法12345678910111213@Override public void onCrimeSelected(Crime crime) &#123; if(findViewById(R.id.detail_fragment_container)==null)&#123; Intent intent=CrimePagerActivity.newIntent(this,crime.getId()); startActivity(intent); &#125;else&#123; Fragment newDetail=CrimeFragment.newInstance(crime.getId()); getSupportFragmentManager().beginTransaction() .replace(R.id.detail_fragment_container,newDetail) .commit(); &#125; &#125; 当点击不同列表，显示不同详情页，调用全部回调方法。 点击列表调用显示详情页的回调方法 点击添加按钮时，调用显示详情页的回调方法 回调函数刷新 将列表清单刷新私有方法改为公有方法 将详细面板创建 Callbacks 回调方法，并创建 onAttach()将 activity 赋值给 Callbacks 对象。frgament 结束方法 onDetach() 将 null 复制 Callbacks 对象 托管 activity 实现接口方法，并在方法中实现托管的代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 快速记忆总结]]></title>
    <url>%2F2017%2F10%2F14%2FAndroid-%E5%BF%AB%E9%80%9F%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[本节目录: 托管 UI fragment 使用 RecyclerView 使用 fragment argument 使用 ViewPager 使用 DialogFragmen 在初学 android 中总是记不住一个控件的使用，用法，通过这种提纲加一点详细说明的方式，方便以后再开发中，快速找到和回忆起相关操作，减少百度查资料的时间。可能总结的不是那么完善，通过后期不断的翻看，以及实践过程中的不断使用，完善这种总结。 托管 UI fragmentfragment的生命周期托管的两种方式fragment 使用- 定义容器视图(FrameLayout) - 创建 UI fragment 类 - onCreateView 定义布局文件中的组件 - 将 fragment 添加到 托管actiivty中 FragmentManager(负责发 fragment添加到 activity 视图层级结构) - fragment 事务组装用户界面 添加 UI fragment 到 FragmentManagerFragmentManager的概念FragmentManager的管理1. fragment 队列 2. fragment 事务回退栈 fragment 事务FragmentManager 与 fragment 的生命周期 使用 RecyclerView 显示列表 基本流程： 创建Adapter 获取模型层数据并绑定 ViewHolder 给视图，然后将 Adapter 添加个 RecyclerView 使用抽象 activity 托管 fragment（将相同的activity 将重复部分封装为抽象类，每个 activity 都继承这个抽象类）RecyclerView、Adapter 和 ViewHolderViewHolder 和 Adapter- viewholder -adapter 使用 RecyclerView- 导入依赖 - 定义容器视图(RecyclerView) - 通过代码实例化视图(onCreateView方法中，需要 LayoutManager 的支持) - 定义 ViewHolder 的内部类 （继承 RecyclerView.ViewHolder） - 创建 adapter 的内部类 ( 继承 RecyclerView.Adapter&lt;ViewHolder&gt; ) 1. onCreateViewHolder() --需要使用列表布局 2. onBindViewHolder() 3. getItemCount() - 给 RecyclerView 设置适配器 响应点击验证每个 ItemView 是否有效 - 添加 View.OnClickerListerner 接口 - 覆写 onClick 方法 - 给每个 ItemView 设置监听器 使用 fragment argument每个 fragment 实例都可附带一个 Bundle 对象。格式为键值对形式，一个键值对即一个 argument 先创建 Bundle 使用 bundle put 类型方法，将 argument 添加到 bundle 中 code 附加 argument 给 fragment格式： Fragment.setArguments(Bundle)必须在 fragment 创建后、添加给 activity 前完成 利用 getArguments（）.get 获取 通过 fragment 获取返回结果类似与 Activity 调用 startActivityForResult() ,转而调用 Fragment.startActivityForResult()接受也是从 Activity 到 Fragment 中，其中要注意的是 fragment 对返回结果处理不同 - 自身无法持有返回结果，只用 activity 拥有返回结果 1p183 使用 ViewPager 创建 一个 ViewPager 类 定义容器组件 在 ViewPager 关联 ViewPager 和 adapter 修改 ViewPager 和 PagerAdapterPagerAdapter 子类 FragmentStatePagerAdapterFragmentStatePagerAdapter 的抽象方法 getCount() getItem(int)还有实例需要 FragmentManager 使用 DialogFragment1. 创建 DialogFragment 类 2. 继承 DialogFragment 3. 覆写 onCreateDialog 方法 4. 方法内返回 AlertDialog.builder 创建的 Builder 对象（setView-setTitle-setPositiveButton） 5. 创建 FragmentManager 6. show(manger,xxx) 显示对话框 工具栏菜单1. 定义 XML 菜单文件 2. onCreateOptionsMenu()方法创建菜单 3. onOptionsItemSelected（）对菜单进行操作处理 实现层级式导航 1. 在注册文件清单上向详情 Activity 上添加 向上按钮parentActivityName（） SQLite 数据库1. 创建一个数据库表字段的类 2. 创建初始化数据库，用到SQLiteOpenHelper类 3. 覆写两个方法，一个 onCreate 创建数据库 一个 onUpgrade创建数据库 4. 初始化数据库并授权权限 5. ContentValues 负责处理数据库写入和更新操作。格式为键值对数据（这个类用户数据库操作使用） 6. 数据库的insert update delete 操作 CursorWrapper 类封装数据表的原始数据 从cursor 获取数据]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式 Intent]]></title>
    <url>%2F2017%2F10%2F12%2F%E9%9A%90%E5%BC%8F-Intent%2F</url>
    <content type="text"><![CDATA[本节目录: 使用隐式 Intent 隐式 Intent 的组成 执行操作 数据的位置 涉及的数据类型 可选类别 一些实例 最近学习《Android 权威编著》,这几天学的总结一下，加深印象，也是方便以后忘记了，能快速找到相关内容，本节主要是关于 隐式 Intent 的使用 使用隐式 Intent隐式 Intent 区别与显示 Intent 的主要区别在于，在实现 Intent 通信我们不需要想显示 Intent 提供以及编写指定具体的 activity，只需要告诉操作系统我们想要做什么，通过系统内置的属性就可以简单实现我们想要的。 隐式 Intent 的组成执行操作通常 Intent 类中的常量来表示。 Intent.ACTION_VIEW 查看某个 URL Intent.ACTION_SEND 发送邮件 Intent.ACTION_DITL 拨号界面等待拨号 Intent.ACTION_CALL 拨打电话 数据的位置 设备外的资源使用 URL 指向文件的 URI 指向 ContentProvider 中的某个内容 URI (content URI) 涉及的数据类型MIME 数据类型，如 text/html , audio/mpeg3.如果一个 intent 包含数据位置，那么通常可以从中推测出数据的类型 关于 MIME 可选类别如果操作用于描述具体要做什么，那么通常用来描述我们是何时、何地或者如何使用某个 activity 的。 通过简单的 Intent 通过配置文件的 intent 过滤器 一些实例 打开短信，发送消息 1234567Intent i = new Intent(Intent.ACTION_SEND);i.setType("text/plain");/*添加正文内容*/i.putExtra(Intent.EXTRA_TEXT, "TEXT");i.putExtra(Intent.EXTRA_SUBJECT, "SUBJECT");i = Intent.createChooser(i, "选择你想使用的应用");startActivity(i); 使用 ShareCompat 类创建发送消息123456ShareCompat.IntentBuilder intentBuilder = ShareCompat.IntentBuilder.from(getActivity()); intentBuilder.setType("text/plain"); intentBuilder.setText("text"); intentBuilder.setSubject("what"); intentBuilder.setChooserTitle("select"); intentBuilder.startChooser(); 打开联系人，选择联系人 12Intent pickContact = new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI); startActivityForResult(pickContact, REQUEST_CODE); 这需要处理返回的 Intent ，因为系统会把联系人数据发送个 Intent，其中包含了临时的权限。onActivityResult方法中一下注释前是通过 查询名称，注释后查询电话号，并拨打电话 12345678910111213141516171819202122232425262728f (requestCode == 1 &amp;&amp; data != null) &#123; /*创建一个Uri 数据地址*/ Uri contactUri = data.getData(); /*创建查询语句*/ String[] queryFields = new String[]&#123;// ContactsContract.Contacts.DISPLAY_NAME ContactsContract.Contacts._ID &#125;; /*查询联系人数据库，并返回一个 cursor*/ Cursor c = getActivity().getContentResolver().query(contactUri, queryFields, null, null, null); try &#123; c.moveToFirst(); /*判断返回结果是否为0 表示没有数据*/ if (c.getCount() == 0) &#123; return; &#125; /*String suspect=c.getString(0); mCrime.setPeopleName(suspect); mSuspect.setText(suspect);*/ Uri number = Uri.parse("tel:" + c.getString(0)); Intent i = new Intent(Intent.ACTION_DIAL, number); startActivity(i); &#125; finally &#123; c.close(); &#125; 打开相机 12Intent captureImage = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);startActivityForResult(captureImage, 2); 因为 Intent 打开应用两种情况，一种是很多应用支持，可以使用选择器。一种是没有内置的应用，这种情况会让应用崩溃，可以通过 packageManager 自检，如果没有就，禁用按钮 1234PackageManager packageManager = getActivity().getPackageManager(); if (packageManager.resolveActivity(pickContact, PackageManager.MATCH_DEFAULT_ONLY) == null) &#123; mSuspect.setEnabled(false); &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的字体表情]]></title>
    <url>%2F2017%2F10%2F12%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[生活中不管是发消息，还是编辑文档，写个人简介，编写 README … 都会使用表情图标💪，增加文本的互动性，提高文本的可阅读性，今天想总结一下这一类的图标资源😃😄😅😆😉😊😋 使用这个使用起来很方便就是 ctrl + C &amp;&amp; ctrl + V 需要注意的是表情在不同页面，应用，以及平台上的表现效果是不同的 来看一组图 哈哈，有没有觉得好笑，但是这不是重点，重点是我们只要使用了，比不适用的好的多的多。(#^.^#) 展示🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥 常用emoji符号一(非图片可复制) 😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂 常用emoji符号二(非图片可复制) 🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴 常用emoji符号三(非图片可复制)↑返回顶部 🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣🌿🚧💒☎📟💽⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞 网站首选 emoji 网站常用emoji符号]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我鞭策(2017-10-10)]]></title>
    <url>%2F2017%2F10%2F10%2F%E8%87%AA%E6%88%91%E9%9E%AD%E7%AD%96-2017-10-10%2F</url>
    <content type="text"><![CDATA[回过头看这几个月，发现自己什么都没有做好，假期回去了，本来打算好的好好学技术也没有去做，去参加夏利营培训，也就前几天认真完成任务，后面开始有点松懈了。开学也是，也就前几天每天都忙如狗，可是有没有什么特别的成绩。 也就这几天有点进步,知道的概念多点，每天写写博客，但是，长点心吧，曲家诚，你马上都快要毕业了，你明知道要考6级，要比赛，要专升本，为什么每天都在浑浑噩噩的，想想虽然每天自己很忙，但是有成效的却很少，而且忙的都是不怎么重要的，你的英语，高数，你根本没有给出时间去看。你就是缺少自我控制，和自我管理的能力，虽然对未来你有目标，但是这些目标没有计划，没有付出与行动。即使你现在每天写博客，但是一天下来就一篇博客? 我真不知道你怎么还能受得了自己，想想以后要面试的时候，你拿什么跟人家比，拿什么让别人留下你，你该好好想想以后去做了，该去指定一个计划，然后每天按照这个计划一步一步实现自己想要的结果。你还想再经历高考那种耻辱吗？如果不想重蹈覆辙，就着眼于眼下，想想目前来说，什么才是重要的?你在乎的是什么?知道了，就应该想想如何去实现他们。 骂了自己那么多，其实也清楚了自己现在最重要的事 专升本 英语六级 Android 比赛 既然知道了在乎的三件事，需要去实现它们，我还要走很长的路，但是，说句实话，我现在真的是对新的技术，语言，还是工具感兴趣，我这十几天每天写博客，能坚持的原因就是喜欢，可能遇到了困难，但是我清楚这之中我浪费了很多时间和精力做了跟他们无关的事情，我缺少了专注了，以至于现在一天做的事情太少。 现在我清楚离六级考试，离专升本已经还有几个月的时间了，今天就想鞭笞一下自己，并且确定接下来的日子应该怎么度过，我觉得这是有必要的，我需要制定一个实际并有效的计划让我的生活有节奏，并且从中得到成就感。否则，我很快就会过那种颓废，而且每天胡思乱想的生活了。 现在，每天坚持的: 早起 锻炼 写博客 看看书 我还要其他的事情，让他成为一种习惯，因为习惯的事情，做起来不觉得别扭，而且坚持下来对自己很有好处。我希望在接下来的一个月每天能坚持的： 早上能抽出时间看英文原版书 晚上做做高数 就这两条吧，我怕多了，有点违背现实，以及高估自己的自控力。 虽然以前也有过自己自责自己，然后让自己去改变的想法，但是从来没有把这个当成博客来写，以后会经常写。因为对于自己来说写博客，能加深自己对自己写的东西的印象。这个现象是我这半个月来发现的。我觉得这个学习方法比较适合我。 总有一天，我会写夸自己的博客！！！O(∩_∩)O哈哈~]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-9)]]></title>
    <url>%2F2017%2F10%2F09%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-9%2F</url>
    <content type="text"><![CDATA[本节目录: 高级网络配置 快速配置指南 配置DNS 容器访问控制 端口映射实现 配置 docker0 网桥 自定义网桥 高级网络配置当 docker 启动时，会自动创建一个 docker0 虚拟网桥，实际上是 Linux 的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。 同时，Docker 随机分配一个本地未占用的私有网段(zai RFC 1918 中定义)中的一个地址给 docker0 接口.比如:172.17.42.1,掩码为255.255.0.0 。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。 当创建一个Docker 容器的时候，同时创建一对 veth pair 接口。这对端口一段在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头，通过这个方式，主机可以跟容器通信，容器之间也可以相互通信。 Docker 就创建了在主机和所以容器之间的虚拟共享网络 关于1 RFC 1918关于2 RFC 1918veth pair 快速配置指南下面关于 Docker 网络相关的命令列表。其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效 1234567-b BRIDGE or --bridge=BRIDGE (指定容器挂载的网桥)--bip=CIDR (定制 docker0 的掩码)-H SOCKET... or --host=SOCKET... (Docker 服务端接收命令的通道)--icc=true|false (是否支持容器之间进行通信)--ip-forward=true|false (请看下文容器之间的通信)--iptables=true|false (是否允许 Docker 添加 iptables 规则)--mtu=BYTES (容器网络中的 MTU) 下面两个命令在启动服务时指定，也可以在 Docker 容器启动指定12--dns=IP_ADDRESS... (使用指定的DNS服务器)--dns-search=DOMAIN... (指定DNS搜索域) 下面的选项只有在 docker run 命令下执行，因为它们是针对容器的特性内容。 12345-h HOSTNAME or --hostname=HOSTNAME (配置容器主机名)--link=CONTAINER_NAME:ALIAS (添加到另一个容器的连接)--net=bridge|none|container:NAME_or_ID|host (配置容器的桥接模式)-p SPEC or --publish=SPEC (映射容器端口到宿主主机)-P or --publish-all=true|false (映射容器所有端口到宿主主机) 配置 DNSDocker 没有为每个容器专门定制镜像，那么怎么自定义配置容器的主机名和 DNS 配置呢?利用虚拟文件挂载容器的 3 个相关配置文件。在容器中使用 mount 命令可以看到挂载信息。 这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 dns 配置通过 /etc/resolv.conf 文件立即得到更新。如果想要手动指定容器的配置。可以使用下面的选项。1-h HOSTNAME or --hostname=HOSTNAME 会被写到容器内的 /etc/hostname 和 /etc/hosts 但在容器外看不到，即不会再 docker ps 中显示，也不会在其他的容器的 /etc/hosts 看到 –link=CONTAINER_NAME:ALIAS 选项会在创建容器的时候，添加一个其他容器的主机名到 /etc/hosts 文件中，使用主机名 alias 就可以连接它 –dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 的主机名 –dns-search=DOMAIN 设定容器的搜索域，当设定的搜索域为 .example.com ，在搜索一个名为 host 的主机，DNS 不仅搜索 host，还会搜索 host.example.com 默认用主机上的 /etc/resolv.conf 来配置容器 容器访问控制容器访问控制，主要通过 Linux 上的 自带防火墙 iptables 进行管理和实现 容器访问外部网络需要本地系统的转发支持 sysctl net.ipv4.ip_forward 如果为 0 ，说明没有开启转发，需要手动开启 sysctl -w net.ipv4.ip_forward=1 在启动 Docker 服务的时候设定 –ip-forward=true,就会自动设置为 1 。 容器之间的访问 容器之间网络拓补是否互联 本地系统的防火软件 iptables 是否允许通过 访问所有端口当启动 Docker 服务时，添加 iptables 的 FORWARD 链上。策略通过还是禁止取决于配置 –cc=true 还是 –cc=false 则不会添加 iptables 规则。 访问指定端口 再通过 –icc=false 关闭网络访问后，还可以通过 –link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。 CONTAINER_NAME 必须是 Docker 分配的名字,或使用 –name 参数指定的名字。主机名则不会被识别 映射容器端口到宿主主机的实现默认情况下容器可以访问外部网络，但是外部不能访问容器 容器访问外部实现 因为 windows 无法识别 iptables 这部分放弃了 ┭┮﹏┭┮ 我想换系统 配置 docker0 网桥Docker 默认制定了 docker0 接口的 IP 地址和子网掩码，让主机和容器之间可以通过网桥互相通信，他们还给出了 MTU (接口允许接受的最大的传输单元)，通常是 1500 Bytes –bip=CIDR – IP 地址加掩码格式 –mtu=BYTES – 覆盖默认的 Docker mtu 配置 也可以在配置文件中配置 DOCKER_OPTS 然后重启服务。 每次创建一个新的容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所以容器的默认网关。 自定义网桥除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器，使用 -b BRIDGE 或 –bridge=BRIDGE 来指定使用的网桥。如果服务已经运行，需要停止服务，并删除旧的网桥 o(╥﹏╥)o 总结不下去，windows根本用不了，这本书让我好蛋疼啊，前面还介绍了 windows 后面直接全部 Linux 下的命令。但是通过进入bash 可以执行，但是文件查看还是很麻烦 先告一段落，后期有时间继续学习相关知识]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-8)]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-8%2F</url>
    <content type="text"><![CDATA[本节目录: Docker 中网络功能介绍 外部访问容器 映射所有接口地址 映射指定地址的指定端口 映射到指定地址的任意端口 查看映射端口配置 容器互联 自定义容器命名 容器互联 Docker 提供 外部访问 或 容器之间互联 的方式提供网络服务。 外部访问容器-P 或-p参数来指定端口映射. 当使用-P,Docker 会随机映射一个 49000-49900 的端口到内部容器开放的网络端口。 1docker run -d -P training/webapp python app.py 使用docker ps -l查看端口号，可以看出，本地主机的 32768 被映射到容器的 5000 端口。此时访问本地的 32768 端口就可以访问容器内 web 应用提供的界面。(可能每个人机器的的端口号不同，访问通过 loc) - p小写 p，可以指定要映射的端口，在指定端口只可以绑定一个容器三种格式： ip：hostPort：containerPort ip::containerPort hostPort:containerPort 映射所有接口地址使用 hostPort：containerPort 格式本地的 5000 端口映射 容器的 5000 端口1docker run -d -p 5000:5000 training/webapp python app.py 此时默认会绑定本地所有接口上的所有地址。 问题:不是指定端口映射?为什么说默认映射所有端口?解决: 在本机上访问端口 5000 就是 访问容器端口 5000 映射到指定地址的指定端口ip：hostPort：containerPort 格式指定映射特定地址1docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py 映射到指定地址的任意端口ip::containerPort 格式指定ip的任意端口到容器 5000 端口，本地主机会自动分配一个端口。 1docker run -d -p 127.0.0.1::5000 training/webapp python app.py 还可以指定 udp 来指定 udp 端口 1docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py 关于udp 查看映射端口配置docker port 查看映射端口配置，以及配置绑定的地址1docker port NAMES 5000 注意: 容器有自己的内部网络和 ip 地址(docker inspect 可以获取所以变量)-p 标记可以多次使用来绑定多个端口 1docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py 容器互联容器的连接系统是除了端口映射外，另一种跟容器中应用交互的方式。该系统会在源容器和接受容器之间创建一个隧道，接受容器可以看到源容器指定的信息 自定义容器命名连接系统依赖容器的名称来执行。因此，首先需要自定义名称来执行。因此，首先需要自定义一个好记的名称. 使用 –name 标记可以为容器自定义命名。1docker run -d -P --name web training/webapp python app.py docker ps -l查看容器自定义名称 容器互联–link 参数可以让容器之间安全的进行交互。 实例：创建新的数据库容器1docker run -d --name db training/postgres 删除并重新创建 web 容器123docker rm -f webdocker run -d -P --name web --link db:db training/webapp python app.py 这样，db容器和 web 容器 创建互联关系 格式： –link name:alias name 表示连接的容器名称 alias 表示是这个连接的别名 Docker 在两个互联的容器之间建立的安全隧道，不用映射他们的端口到宿主主机。再启动 db 容器并没有使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。 Docker 2中方式为容器公开连接信息: 环境变量 更新 /etc/hosts 文件 实例1:使用 env 命令查看环境变量 实例2:除了环境变量，Docker 还添加 host 信息到父容器的 /etc/hosts 的文件。下面是父容器 web 的 hosts 文件 123docker run -t -i --rm --link db:db training/webapp /bin/bash进入终端cat /etc/hosts 截图 这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 可以在 web 容器中安装 ping 命令来测试跟db容器的连通。 1ping db]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-7)]]></title>
    <url>%2F2017%2F10%2F07%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-7%2F</url>
    <content type="text"><![CDATA[本节目录: 数据管理 数据卷 数据卷容器 备份、恢复、迁移数据卷 数据管理本小节学习在 Docker 内部以及容器之间管理数据，主要方式: 数据卷(Data volumes) 数据卷容器 (Data volume containers) 数据卷数据卷是一个提供一个或者多个容器使用的 特殊目录 它绕过 UFS ，可以提供很多有用的特性: 数据卷可以在容器之间共享和重用 对数据卷的更新可以立马生效 数据卷的更新不会影响镜像 数据卷默认一直存在，即使容器被删除 创建一个数据卷在使用 docker run 命令，使用 -v 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。 实例:下面创建一个名为 web 的容器，并加装一个数据卷到容器的 /webapp1docker run -d -P --name web -v /webapp training/webapp python app.py 注意: 也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器。 删除数据卷 数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，也不出现垃圾回收机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除命令加 -v 参数，docker rm -v 命令删除容器移除数据卷 挂载一个主机目录作为数据卷 -v 标记也可以指定挂载一个本地主机的目录到容器中去1docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py 上面的命令加载主机 /src/webapp 目录到容器的 /opt/webapp目录。 注意： Dockerfile 不支持这种用法，这是因为Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以现在还不能支持 Docker 挂载数据卷默认权限是读写，用户也可以通过:ro指定为只读 1docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py 加了 :ro 之后，就挂载为只读了 查看数据卷的具体信息1docker inspect web ... 在输出的内容中找到其中和数据卷相关的部分 数据卷容器如果你有一些持续更新的数据需要在容器之间共享,最好创建数据卷容器。专门提供数据卷为其他容器挂载的。 实例：创建 dbdata 数据卷容器1docker run -d -v /dbdata --name dbdata training/postgres echo Data-only container for postgres 在其他容器中 使用 –volumns-from 来挂载dbdata 容器中的数据卷12345docker run -d -volumns-from dbdata --name db1 training/postgresdocker run -d -volumns-from dbdata --name db2 training/postgresdocker run -d -volumns-from db1 --name db3 training/postgres 注意：使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。 利用数据卷容器来备份、恢复、迁移数据卷备份 12docker run --volumes-from dbdata -v $(pwd):/backup ubuntutar cvf /backup/backup.tar /dbdata 创建一个挂载 dbdata 的容器，并从主机挂载到 backup 目录，之后执行 tar 命令生成一个 .tar 文件的备份 恢复如果恢复一个数据到一个容器，首先创建带空数据卷的容器 dbdata2 1docker run -v /dbdata --name dbdata2 ubuntu /bin/bash 然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载容器卷中。1docker run --volumes-from dbdata2 -v $(pwd): /backup busybox tar xvf /backup/backup.tar 为了查看或者验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看1docker run --volumes-from dbdata2 busybox /bin/ls /dbdata]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-6)]]></title>
    <url>%2F2017%2F10%2F06%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-6%2F</url>
    <content type="text"><![CDATA[本节目录: 访问仓库 Docker Hub 私有仓库 仓库配置文件 访问仓库仓库是集中存放镜像的地方。Registry 注册服务器是管理仓库的具体服务器，每个服务器上面有很多个仓库，每个仓库对应有许多镜像。从这方面来说，仓库可以被认为是一个具体的项目或者目录。需要我们对注册服务器做区分。 Docker HubDocker Hub 是官方维护的公共仓库 Docker Hub ，其中已经包括了超过 15,000 的镜像。大部分都可以从 Docker Hub 中下载镜像来实现。 登录 基本操作 用户无需登录即可通过在 docker search查找官方仓库中的镜像，docker pull来下载到本地 实例:1docker search centos docker search + 搜索的关键词,其中我们可以看出，搜索出来的字段，包括镜像名称，描述，星级，是否官方创建、是否自动创建。 名称:一般官方创建、维护、支持的镜像都是单个单词作为名字。用户创建的镜像一般名称格式 username/ 描述:对镜像的说明 星级:表示该用户的受欢迎程度 -s N 参数可以在查找中指定显示 N 星以上的镜像(新版本推荐filter=starts=N 参数) 方式 1: 方式 2: docker pull [OPTIONS] NAME[:TAG|@DIGEST] 自动创建Automated Builds 自动创建功能对于需要经常升级镜像的程序来说，十分方便。自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站(支持 GitHub 和 BitBucket )上的项目，一旦项目发生新的提交，则自动执行创建。 操作： 登录 Docker Hub ，以及目标网站; 在目标网站中连接到 Docker Hub； Docker Hub 中配置一个自动创建 选取一个目标网站中的项目(需要含 Dockerfile)和分支； 指定 Dockerfile 的位置，并提交创建 在 Docker Hub 自动创建页面跟踪每次创建的状态 私有仓库有时候使用 Docker Hub 不方便，用户可以创建一个本地仓库供私人使用。docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库 安装运行docker-registry 容器运行1docker run -d -p 5000:5000 registry 使用官方的 registry 镜像来启动本地的私有仓库 默认情况下，仓库会被创建在容器的 /var/lib/registry 下。可以通过 -v 参数来将镜像文件存放在本地的指定路径。下面将上传的镜像放到 /opt/data/registry 目录1docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry Docker私有仓库Registry的搭建验证搭建docker本地镜像仓库 在私有仓库上传、下载、搜索镜像 创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送到仓库里，别的机器就可以下载 docker images 查看已有的镜像 docker tag 将 deal194 标记为 127.0.0.1:5000/test (格式:docker tag images[:tag][registryhost/][username/name[:tag]) docker push 127.0.0.1:5000/test 使用 push 上传标记的镜像 curl 查看仓库中的镜像 仓库配置文件Docker 的 Registry 利用配置文件提供了一些仓库的模板，用户直接使用它们来进行开发或生产部署 模板在 config_sample.yml 文件中,可以看到一些模板段:1234567891011common ：基础配置local ：存储数据到本地文件系统s3 ：存储数据到 AWS S3 中dev ：使用 local 模板的基本配置test ：单元测试使用prod ：生产环境配置（基本上跟s3配置类似）gcs ：存储数据到 Google 的云存储swift ：存储数据到 OpenStack Swift 服务glance ：存储数据到 OpenStack Glance 服务，本地文件系统为后备glance-swift ：存储数据到 OpenStack Glance 服务，Swift 为后备elliptics ：存储数据到 Elliptics key/value 存储 用户也可以添加自定义的模板段:]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-5)]]></title>
    <url>%2F2017%2F10%2F05%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-5%2F</url>
    <content type="text"><![CDATA[本节目录: 镜像的实现原理 操作 Docker 容器 启动容器 后台(background)运行 终止容器 进入容器 导出和导入容器 删除容器 清理所有处于终止状态的容器 镜像的实现原理Docker 镜像是怎么实现增量的修改和维护的?每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。 通常 Union FS 有两个用途: 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下 另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。Docker 在 AUFS 上构建的容器也是利用了类似的原理。 关于 UFS 操作 Docker 容器容器是 Docker 又一核心概念 容器对应虚拟机可以理解为模拟运行的一整套操作系统(提供了运行态环境和其他操作系统)和跑在上面的应用。下面学习容器的创建、启动和停止等 启动容器 基于镜像创建一个容器并启动 将在终止状态(stopped)的容器重新启动 实例1:1docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos; Hello world 1docker run -t -i ubuntu:14.04 /bin/bash -t 选项让 Docker 分配一个伪终端，并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开，进入交互终端，用户可以通过所创建的终端来输入命令, 当利用 docker run 来创建容器时， Docker 在后台运行的标准操作包括: 检查本地是否存在指定镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统,并在只读的镜像层外面挂载一层 可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去，从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 关于 pwd 实例2:利用 docker start 命令，直接将一个已经终止的容器启动运行。 容器的核心是为所执行的应用程序，所需要的资源都是应用程序运行所必须的。在终端中利用 ps 和 top 来查看进程信息。 可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源利用率极高，体现了 Docker 轻量级虚拟化 top: 后台(background)运行 通常的时候需要让 Docker 在后台运行，而不是直接将执行结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现 实例:1docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; 容器会把输出的结果打印到宿主机上面 使用 -d参数运行容器1docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; 使用 -d 参数启动后会返回一个唯一的 id ,也可以通过 docker ps 命令来查看容器信息 要获取容器的输出信息，可以通过 docker logs [container ID or Names] 终止容器使用 docker stop 命令来终止一个运行中的容器终止状态的容器可以用 docker ps -a 命令看到。现在我们可以用我们刚才讲的docker start 重启结束的容器 docker restart 可以结束正在运行的容器，然后重新启动 进入容器在使用 -d 参数时，容器启动后进入后台。某些时候需要进入容器进行操作： attach 命令 nsenter 命令 实例1：attach 命令 当多个窗口同时 attach 到同一个容器的时候,所以窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口也无法执行操作。 实例2：nsenter 命令 书上介绍的都是 Linux 系统下进行的，因为自己电脑上 windows 这一部分，先暂停 导出和导入容器导出容器导出本地容器1docker ps -a 查询已经停止的容器 ID 1docker export commitID &gt; xxx.tar 导入容器快照 实例:1docker import - test/ubuntu:v1.0 删除容器docker rm命令删除处于终止状态的容器。 -f 强制删除容器，用在运行的容器中。 清理所有处于终止状态的容器1docker rm &amp;(docker ps -a -q) windows 下进入 git bash 运行上面的命令删除 注意；这个命令其实会尝试删除所有的包括还运行中的容器，不过就像上面提过的 docker rm 默认不会删除运行中的容器。这个命令是在 linux 系统下执行]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-4)]]></title>
    <url>%2F2017%2F10%2F04%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-4%2F</url>
    <content type="text"><![CDATA[本节目录: 其他生成镜像的方法 从 rootfs 压缩包导入 docker save 和 docker load 删除本地镜像 用 ID、镜像名、摘要删除镜像 Untagged 和 Deleted 用 docker images 命令来配合 今天可能要出去，所以一大早上就要把今天要学习的内容学完ヾ(◍°∇°◍)ﾉﾞ 其他生成镜像的方法除了使用 Dockerfile 生成镜像的方法外,由于各种特殊需求和历史原因，还提供了其他方法用以生成镜像 从 rootfs 压缩包导入格式: docker import [选项]&lt;文件&gt;||-[&lt;仓库名&gt;[:&lt;标签&gt;]] 解释: 压缩包可以是本地文件、远程 Web 文件、甚至是从标准输入中得到。 压缩包将会在镜像/目录展开，并直接作为镜像的第一次提交 实践: 比如我们想要创建一个 OpenVZ 的 Ubuntu 14.04 模板的镜像: 123docker import http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz openvz/ubuntu:14.04 因为命令过长 上面一条命令 我把他分为三行，这条命令下载 .tar.gz 文件，并作为根文件系统展开导入，并保存为镜像 openvz/ubuntu:14.04，导入成功后，docker images查看镜像，或者docker history openvz/ubuntu:14.04查看历史 关于 openVZ docker save 和 docker loadDocker 还提供 docker save 和 docker load 命令用于将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来 这是在没有 Docker Registry 时的做法，现在已经不推荐,镜像迁移应该直接使用 Docker Registry ，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。 保存镜像使用 docker save 将镜像保存为归档文件。 实践: 保存镜像命令1docker save apline | gzip &gt; apline-latest.tar.gz 问题： windows 不识别 gzip 命令解决： 下载 gzip for windows 版本 将 alpine-latest.tar.gz 复制到另一个机器上，然后使用下面命令加载镜像1docker load -i alpine-latest.tar.gz 如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能： 12docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &apos;cat | docker load&apos; 关于 ssh关于 pv 删除本地镜像格式: docker rmi [选项]&lt;镜像1&gt;[&lt;镜像2&gt;…] 用 ID、镜像名、摘要删除镜像实践: 比如我们要删除,apline 镜像，可以执行; docker iamges 查看镜像信息 docker rmi 镜像ID 如果删除不了 加 -f 强制删除 或者 docker ps -a 查看所有 container id ，然后先 停止所有 container ID 然后在删除 使用 镜像名，删除 docker rmi 仓库名:标签 更准确的使用 镜像摘要删除镜像 docker images –digests Untagged 和 Deleted如果仔细发现，删除行为 有两类 Deleted Untagged 前面介绍过,镜像的唯一标识是其 ID 和 摘要 我们都知道镜像的唯一标示是 ID 和 摘要 ，而一个镜像可以有更多个标签，因此当我们指定标签删除镜像，如果还有其他标签的对应这个镜像，就不会发生delete 行为，而 untaggged 使我们取消了所有的标签，当所有标签取消后就可以出发 delete 行为 镜像之间的依赖，镜像是多层结构，删除的时候也是从上层向基础层方向依次进行判断删除，如果其他镜像依赖于待删除的某一层，也不会触发 delete 效果 容器对镜像的依赖，如果有用这个镜像启动的容器存在，那么就不能删除镜像。容器是以镜像为基础添加一层容器存储器，组成的多层存储结构去运行。因此该镜像如果被这个容器所依赖的，就需要先删除容器，在删除镜像 用 docker images 命令来配合实例: 1$ docker rmi $(docker images -q -f dangling=true) 删除所有仓库名为 redis 的镜像：1$ docker rmi $(docker images -q redis) 删除所有 mongo:3.2 之前的版本1$ docker rmi $(docker images -q -f before=mongo:3.2)]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-3)]]></title>
    <url>%2F2017%2F10%2F03%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-3%2F</url>
    <content type="text"><![CDATA[本节目录： ENV 设置环境变量 ARG 构建参数 VOLUME 定义匿名类 EXPOSE 声明端口 USER 指定当前用户 HEALTHCHECK 检查健康 ONBULID 为他人做嫁衣 接着上一节学习 Dockerfile 的指令 ENV 设置环境变量标题中已经告诉我们 ENV 是设置环境变量的，环境变量大家都不陌生，就是定义一个环境变量，可以在程序中重复使用，一般用在需要大量使用该参数的地方。这个好处就是，方便代码的维护。 格式： ENV key value ENV key1=value1 key2=value2 这个指令很容易理解，直接上图吧 ARG 构建参数跟 ENV 效果一样，都是设置环境变量，但 ARG 的区别在于，它是设置 构建环境 的环境变量。意思就是当时用构建命令时使用的。 格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;] 在 Dockerfile 中 的 ARG 指令是定义参数名称,以及定义其默认值。该默认值可以在构建命令中覆盖 1docker --build-arg&lt;参数名&gt;=&lt;值&gt; 需要注意的是，在1.13版本之前 要求使用 –build-arg 中的参数名,必须在 Dockerfile 中用 ARG 定义。在1.13开始，这种严格的限制解除了，不会报错退出，而只是显示警告信息。 实例: 123FROM xxxARG user=xxx... 在上面的 Dockerfile 中 ARG 指定了我们 user ，当我们构建这个镜像的时候，如果想更换用户，就可以1docker --build-arg user=2xxx 构建后的名称 VOLUME 定义匿名类容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用,其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件保存目录挂载为卷。在 Dockerfile 中，我们事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会像容器存储层写入大量数据。关于挂载 格式：VOLUME [“&lt;路径1&gt;”，”&lt;路径2&gt;”…] 1VOLUME /data 该命令表示，在运行时自动挂载为匿名类,任何想 /data 中写入的信息都不会记录进容器存储层，从而保证容器存储层的无状态化。运行时也可以覆盖掉这个匿名挂载设置123docker run -d -v mydata:/data xxxx&lt;!--mydata这个命名卷挂载了 /data 这个位置--&gt; EXPOSE 声明端口格式：EXPOSE 端口1[端口2…] EXPOSE 只是声明运行时容器提供服务端口号,这个只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile中写入声明的好处： 帮助镜像使用者理解这个镜像服务的守护进程，以方便映射 在运行使用随机端口映射时,也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 以前的 Docker 所以容器是互通的，这存在于安全性问题。现在通过自定义网络可以实现容器间的互联与隔离。要将 EXPOSE 和 运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt;区分开来。 -p 是映射宿主端口和容器端口，就是容器对应的端口服务公开给外界访问,而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 WORKDIR 指定工作目录格式：WORKDIR 工作目录路径 该指令指定工作目录，以后各层的当前目录就会被改为指定的目录，如果不存在，就自动创建 USER 指定当前用户格式：USER 用户名USER 指令与 WORKDIR 相似，都是改变环境状态并影响以后的层。一个改变目录，一个是改变之后执行命令的身份。 HEALTHCHECK 检查健康格式： HEALTHCHECK [选项] CMD &lt;命令&gt; :设置检查容器健康状况的命令 HEALTHCHECK NONE :如果基础镜像有检查健康检查指令，可以屏蔽其他健康检查指令。之前没有什么 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主程序是否退出来判断容器是否状态异常。在程序进入死锁状态或者，死循环状态，应用进程并不退出，也就无法提供服务了。 当使用 HEALTHCHECK 指令后,用其启动容器,初始状态会变成 starting ，在 HEALTHCHECK 指令检查成功后变为 healthy ,如果连续一定次数失败,则会变为 unhealthy 。 选项：–interval=&lt;间隔&gt;：两次健康检查的间隔，默认30秒–timeout=&lt;时长&gt;：如果超过这个时间，表示失败–retries=&lt;次数&gt;:当连续失败状态为 unhealthy 默认 3 次 假设我们的镜像是一个最简单的 Web 服务，我们希望增加健康检查来判断其Web服务是否在正常工作，我们可以用 curl 帮助判断123456FROM nginxRUN apt-get update \&amp;&amp; apt-get install -y curl \&amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \CMD curl -fs http://localhost/ || exit 1 构建 docker build -t myweb:v1 .启动容器docker run -d –name web -p 81:80 myweb:v1查询状态docker ps ONBULID 为他人做嫁衣格式: ONBULID 其他指令这是一个特殊的指令,它后面跟的是其它指令,比如 RUN , COPY 等, 而这些指令,在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像,去构建下一级镜像的时候才会被执行。 假设我们要制作 Node.js 所写的应用的镜像.Node 使用 npm进行包管理。有依赖、配置、启动信息等会放 package.json 文件里。一般 npm install 获取依赖，然后 npm start 启动应用1234567FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN [ &quot;npm&quot;, &quot;install&quot; ]COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 如果我们构建第二个相同项目，我们可能会复制，如果有很多文件，文件副本也很多，版本控制就越困难。如果第一个文件出现需要修改的问题，我们如何同步多个项目? 写一个基础镜像，让各个需要构建的项目都指向基础镜像，重新构建，会继承基础镜像的更新。构建 基础 镜像，起名 my-node (docker build -t my-node .) 其他项目的 Dockerfile 指向基础镜像 my-node，就是上面那幅图 （问题解决了一半，如果我需要给npm install 加一些参数） ONBUILD 可以解决这个问题。 使用 ONBUILD 重写 Dockerfile 基础镜像my-node1234567FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]ONBUILD COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 加上 ONBUILD 的指令并不会执行，然后各个项目的 Dockerfile 都为 1FROM my-node 只有一行的 Dockerfile 构建的时候，就执行 基础镜像里面的 ONBUILD 后面的，成功的将但钱项目的代码复制进镜像，当遇到修改时 我们知道修改一份 镜像，然后构建成基础镜像，供其他镜像使用。 最后是关于网上我觉得不错的博客，很崇拜比自己写的好的人，对于我这个快要毕业的人来说，还有许多要学，现在唯一能做的就是让自己不骄不躁，安心做好当下的事情，我相信即使毕业了，自己的技术还不够找一份好工作，我也会坚持学习！ヾ(◍°∇°◍)ﾉﾞ如何写Dockerfile，Dockerfile 参考文档Docker 官方文档Dockerfile 实践文档]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单算法(一)]]></title>
    <url>%2F2017%2F10%2F02%2F%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[从极客学院 wiki 中下载的电子书《坐在马桶上学算法》,虽然入门编程已经两年了，但从来没有学习有关算法的知识，因为以后励志想要成为一名合格的程序员，知道算法在编程中是不可或缺的，但现在太正式的学习又会让自己失去信心，所以网上找到这本书，算是培养一下自己的兴趣吧，这本书特点是图文并茂，风趣易懂。(要求:C语言基础) 我用的编译器：Pelles C 最快最简单的排序(桶排序) 问题：生活中有许多需要处理排序的问题，考试中，评奖学金等等，如何编写一段程序 解决:只需借助一个一维数组就可以解决。假设:我们编写一个排序 5 个数的大小 申请一个大小为 11 的数组 int a[11] 初始化 a[0]~a[10] 都为 0 ,表示没有分数 处理这 5 个数 ,因为是排序分数 ，利用数组输出特性,将分数的值存在对应的位置，比如 5分 就存在 a[5] 中,并把值改为 1 ，表示出现过的次数 输出:遍历数组，依次打印，数值&gt;0 的数组多少就打印几次 12345678910111213141516#include &lt;stdio.h&gt;int main(void)&#123; int a[11],i,j,t; for(i=0;i&lt;=10;i++) a[i]=0;//初始化为0 for(i=1;i&lt;=5;i++) &#123; scanf("%d",&amp;t); a[t]++; &#125; for(i=0;i&lt;=10;i++) for(j=1;j&lt;=a[i];j++) printf("%d",i); getchar();&#125; 这种排序方法我们暂且叫”桶排序”,这个不是正真的桶排序,这个程序好比 11 个桶,编号从 0~10 每出现一个数,就将对应编号的桶加1，然后按顺序将通的编号打印出来，打印的次数为桶中的个数 上面的只接受 10 以内的排序，如果需要更大范围排序，需要修改数组的大小。如何实现从大到小排序？ 1234// 只需要将数组从大到小遍历就可以了for(i=10;i&gt;=0;i--) for(j=1;j&lt;=a[i];j++) printf("%d",i); 时间复杂度: O(m+n+m+n)m:桶的数量n:输入的次数 如果每个数据对应一个名字 这种简单算法就无法进行,这就要用到冒泡排序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-2)]]></title>
    <url>%2F2017%2F10%2F02%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-2%2F</url>
    <content type="text"><![CDATA[本节目录 Dockerfile 指令详解 COPY 复制文件 ADD 更高级的复制文件 CMD 容器启动命令 ENTRYPOINT 入口点 Dockerfile 指令详解COPY 复制文件格式：COPY &lt;源路径&gt;…&lt;目标路径&gt;COPY [“&lt;源路径&gt;”,…”&lt;目标路径&gt;”]和 RUN指令一样,也有两种格式,一种命令行，一种函数调用的方式 COPY 指令将从构建上下文目录中 &lt;源路径&gt;的文件 / 目录 复制到新的一层镜像内的 &lt;目标路径&gt; 位置。 比如:1COPY package.json /usr/src/app/ &lt;源路径&gt;可以是多个，可以使用通配符，规则要满足 Go 的 filepath.Match 规则&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径，目标目录不需要事先创建，当目录不存在会在复制文件前创建确实目录 使用 COPY 指令，源文件的各种元数据都会保留。比如 读、写、执行权限、文件变更时间等 ADD 更高级的复制文件ADD 指令更 COPY 的格式和性质基本一致。但是在 COPY 的基础上增加了一些功能。 &lt;源路径&gt; 可以是一个 URL ,这种情况下， Docker 引擎会尝试去下载这个链接的文件。下载后文件权限自动设置为600，当需要修改权限，还需要额外的一层 RUN 进行权限调整，如果 URL 是一个压缩文件，需要解压缩，同样也需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令然后使用工具处理权限，解压缩，然后清理无用的文件 —-扯了那么多，就是这个功能不实用？？ &lt;源路径&gt;是一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; ADD 最适合的场景就是自动解压缩的时候，并且需要注意 ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得缓慢? 所以在 COPY 和 ADD 指令中，当文件复制使用 COPY 指令，当涉及到自动解压缩的场合使用 ADD CMD 容器启动命令格式： shell 格式 1CMD &lt;命令&gt; exec 格式1CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;] 容器是进程，当启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是注定默认的容器的启动命令的 比如，ubuntu 镜像默认CMD 是 /bin/bash ,如果我们在 运行时 指定运行别的命令,如 docker run -it ubuntu cat /etc/os-release。就是用 cat /etc/os-release 命令替换默认命令，输出系统信息。(注意cat后面跟空格) 在指令格式上，一般推荐 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要是使用双引号 “”。如果使用 shell 格式的话,实际的命令会被包装为 sh -c 的参数的形式进行执行 1CMD echo $HOME 实际执行 1CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $HOME&quot;] 使用环境变量的原因,因为这些环境变量会被 shell 进行解析处理 ENTRYPOINT 入口点ENTRYPOINT 的目的和 CMD 一样，就是在指定容器启动程序及参数，ENTRYPOINT 在运行时也可以替代，需要通过 docker run 的参数 –entrypoint 来指定。当entrypoint指定后，CMD 的含义就发生了改变。将 CMD 的内容作为参数传给 ENTRYPOINT 指令 。实际执行时，变成了：1&lt;ENTRYPOINT&gt; &quot;CMD&quot; 第一次看的这种解释有点怪。 场景一:让镜像变成像命令一样使用 假设我们需要一个得知自己当前公网 IP 的镜像,那么可以先用 CMD 来实现：12345FROM ubuntu：16.04RUN apt-get update \&amp;&amp; apt-get install -y curl \&amp;&amp; rm -rf /var/lib/apt/lists/*CMD [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;] 还记得前一节讲的如何通过 Dockerfile 构建镜像? 将上述信息写入 Dockerfile 文件中 运行 docker build -t myip . 创建镜像。加入我们需要查询当前公网 IP ,只需要执行：1docker run myip 这样看来我们把镜像当做命令使用了，不过命令总有参数，那么如果我们希望显示 HTTP 头信息，就需要添加 -i 参数,直接添加对吗?我们之前说过，跟在镜像后面的是命令，会替换原来的 CMD ,而不是添加在curl -s http://ip.cn 后面，替换命令为 -i 不是命令，他只是参数，所以报出错误找不到文件。 如何解决这个问题? 如果我们希望加入 -i 这参数，就必须重写新的完整输入 1docker run myip curl -s http://ip.cn -i 使用 ENTRYPOINT 就可以解决这个问题。(如果不记得ENTRYPOINT是什么翻到上面再看一下概念)Dockerfile文件中 12345FROM ubuntu:14.04RUN apt-get update \&amp;&amp; apt-get install -y curl \&amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;] docker run 设置的命令参数或者 CMD 指令的命令，都将作为ENTRYPOINT指令的命令参数，追加到ENTRYPOINT指令的命令之后。其中上述 的 -i 作为参数天交到 curl 之后。 关于 apt-get 关于 curl 问题:如何删除镜像？ 123456docker ps -l (列出正在运行的详情)docker stop &lt;containerid&gt;docker rm &lt;containerid&gt;docker rmi &lt;imageid&gt;docker rmi $(docker images -q)(删除全部镜像)docker rm $(docker ps -a -q)(删除所有的容器) 场景二:应用运行前的准备工作启动容器就是启动主进程,但有些时候,启动主进程前,需要一些准备工作。而这些准备工作是跟容器 CMD 无关的，无论 CMD 为神马，都需要事先进行一个预处理的工作。比如： mysql 类的数据库,可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 可能希望避免使用 root 用户启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行，方便调试 这些情况，可以写一个脚本,然后放入 ENTRYPOINT 中去执行,而这个脚本会将接到的参数(也就是 CMD)作为命令，在脚本最后执行。因为对 shell 脚本不熟悉 所以用照片记录脚本的使用。 shell 教程 | 菜鸟教程]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-10-1)]]></title>
    <url>%2F2017%2F10%2F01%2F%E5%AD%A6%E4%B9%A0Docker-2017-10-1%2F</url>
    <content type="text"><![CDATA[本节学习目录 使用 Dockerfile 定制镜像 Dockerfile 的使用 构建镜像 直接用 Git repo 进行构建 用给定的 tar 压缩包构建 从标准输入中读取 Dockerfile 进行构建 从标准输入中读取上下文压缩包进行构建 继续学习 Docker 相关知识，上节学习了如何列出镜像，以及镜像的理解，关于 commit 生成定制的镜像，最后对 commit 生成镜像的缺点分析。 今天从 Dockerfile 定制镜像开始学习，并完成笔记。 使用 Dockerfile 定制镜像DockerfileDockerfile 是一个文本文件，其中包含一条条指令(Instrution),每一条指令构建一层,因此每条指令的内容，就是描述该层的应当如何构建。 Dockerfile 的使用 在一个文件夹中创建一个 Dockerfile 的文本,其中写入两条命令12FROM ngixRUN echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt; /usr/share/ngix/html/index.html FROM 指定基础镜像 回顾我们上节课的 nginx 镜像，就是一个基础镜像，在此基础做出定制。基础镜像是必须指定的。而 FROM 就是指定基础镜像，每个 Dockerfile 中 FROM 是必备的，而且必须是第一条指令。 知识：在 Docker Hub 上有非常多的高质量的官方镜像 可以直接拿来使用的 服务器镜像： nginx、redis、mongo、mysql、httpd、php、tomcat 等 方便开发、构建、运行各种 语言应用的镜像： node、openjdk、python、ruby、galang 等 基础的 操作系统镜像： ubuntu、debian、centos、fedora、alpine 等 特殊镜像 scratch ,表示虚拟的概念，并不存在，是一个空白的镜像 FROM scratch … 表示不以任何镜像为基础，接下来的命令作为镜像第一层开始存在。 知识：不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd 对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经让镜像体积更加小巧了。因此 FROM scratch 会让镜像体积更加小巧。实用 Go 语言开发的应用用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言之一。—来自《Docker 从入门到实践》 RUN 执行命令RUN 指令是执行命令行的命令。RUN 指令在定制镜像时是最常见的指令之一。其格式有两种: shell格式：RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。 exec 格式：RUN [“可执行文件”,”参数1”,”参数2”],这更像是函数调用中的格式 问题：既然 RUN 就像 shell 脚本一样可以执行命令,那么我们是否就可以像 shell脚本一样把每个命令对应一个 RUN 呢? 之前说过， Dockerfile 中每一个指令都会建立一层, RUN 也不例外。 每一个 RUN 的行为,就和刚才我们手工建立镜像的过程一样：新建一层，然后执行这些命令,commit 这层的修改，构成新的镜像。如果每条指令都是用 RUN 就创建了很多 镜像，所以又出现了上一节的问题，增加了镜像的臃肿程度。 Union FS 是有最大层数限制,比如 AUFS,曾经42层，现在127层 关于 Union FS 解决：仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需要的命令串联起来。 Dockerfile 支持 Shell 类的行尾添加 \ 命令换行，以及行首 # 进行注释格式 理解：阅读上图可能发现最后删除了编译构建所需要的软件，清理了所以下载、展开的文件，并清理了 apt 缓存文件，现在我们可能理解了 commit 和 Dockerfile 的区别，commit 直接生成了我们没有处理干净的镜像，其中包括很多自动生成的东西。利用 Dockerfile 相当一个”一键生成”的功能，把我们所要执行的工作，包括最后清理的工作，全部合成到一起，避免了 commit 忘记每一层构建的时候产生的文件。 构建镜像回到我们刚才的 nginx 镜像，让我们构建这个镜像12docker build -t nginx:v3 .&lt;!-- 格式：docker build [选项] &lt;上下文路径/URL/-&gt;--&gt; 遇到的问题 问题1： 输入命名显示格式错误提示！解决： 后来发现后面需要添加 . 点：表示当前目录 问题2： 未找到 Dockerfile 文件在你的目录解决：知道了找不到文件，思考了一下可能文件格式不对，书上没说什么格式，我的是txt格式，后来改成 无后缀的ok了 问题3： build 成功后 windows 提示 权限问题解决：解决方法 验证： 启动 进入验证 镜像构建上下文 (Context)构建镜像命令后面有个.，表示当前目录，对应命令格式，是上下文路径，什么是上下文？ Docker build 工作原理Docker 运行： Docker 引擎(服务端守护进程) 客户端工具 Docker 的引擎提供了一组 REST API (Docker Remote API),使用 docker 命令的客户端工具是通过这个 API 与引擎进行交互的。因此，虽然从表面上看我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端完成。这种 C/S设计，让我们轻松的操作远程服务器的 Docker 引擎。 当我们进行构建镜像的时候，并非是在本地构建，而是在服务端，也就是 Docker 引擎中进行。其中使用了上下文概念。 上下文路径的作用：当用户执行 docker build 命令，获取上下文路径，会将这个路径的内容打包上传到 Docker 引擎，引擎展开这个包获得构建镜像所需的一切文件 需要注意的是:我们上传的内容不要在硬盘的根目录，也就是 C,D 盘，这会在执行 docker build 命令后 发送一个 几十 GB 的文件，这是一种错误的做法。正确的做法是创建一个空目录，或者项目目录，把需要的文件复制一份，如果目录下有不想构建的内容，可以用 .gitignore一样的语法创建一个dockerignore 直接用 Git repo 进行构建docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建: 用给定的 tar 压缩包构建1docker build http://server/context.tar.gz 所给的 URL 不是git repo，而是 tar 压缩包，那么 Docker 引擎会下载这个包，自动解压，以其作为上下文，开始构建。 从标准输入中读取 Dockerfile 进行构建1dockerfile -&lt; Dockerfile 如果标准输入传入的是文本文件，则将其视为 Dockerfile ，并开始构建。 这种形式读取内容，没有上下文，因此不可以将本地文件 COPY 进镜像之类的事情 从标准输入中读取上下文压缩包进行构建1docker build -&lt; context.tar.gz 如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-9-30)]]></title>
    <url>%2F2017%2F09%2F30%2F%E5%AD%A6%E4%B9%A0Docker-2017-9-30%2F</url>
    <content type="text"><![CDATA[本节学习目录 虚悬镜像 中间层镜像 列出部分镜像 利用 Commit 理解镜像构成 慎用 docker commit 衔接上一篇的内容,继续学习 Docker 的相关知识 虚悬镜像 中间层镜像 列出部分镜像 docker images 会列出所以镜像，当添加多个镜像只好几个参数 以特定格式显示 1docker images -q 显示所有镜像的id信息 下面的命令会直接列出镜像结果,并且只包含镜像 ID 和仓库名:1docker images -format &quot;&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Repository&#125;&#125;&quot; 或者打算以表格等距显示,并且有标题行,和默认一样，不同自己定义列：1docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot; 利用 Commit 理解镜像构成 回顾知识:镜像是多层存储,每一层是前一层的基础上进行的修改；而容器也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层 我们定制一个 Web 服务器为例子,来讲解镜像是如何构建的。 1docker run --name webserver -d -p 80:80 nginx 这条命令会用nginx镜像启动一个容器，名称为webserver，并且映射了80端口，如果使用的是 Docker for Windows 直接 通过 loclhost 访问。如果使用的是 Docker Toolbox ,或者是在虚拟机、云服务器上安装的 Docker ,则需要将 loclhost 换位虚拟机地址或者云服务器的地址 出现问题图片12345docker: Error response from daemon: Conflict. The container name &quot;/webserver&quot;is already in use by container &quot;9ea8beeb72c9f62b300ce1628f9a1660b37091636c8fc95774a3cb682b8b0819&quot;. You have to remove (or rename) that container to be able to reuse that name.See &apos;docker run --help&apos;. 问题：上述命令下载nginx 镜像后，再次报错？解决：上述出错信息是你不能使用80端口，所以我们修改了端口，解决后的命令如下 1docker run --name webserver -d -p 81:80 nginx 如果你的机器运行失败，使用docker ps -l查看正在运行的镜像，然后docker kill commit_ID结束并删除docker rm commit_ID,然后在使用上面的命令，成功后返回一个 id最后通过localhost:81访问 我们可以通过docker exec命令进入容器，修复其内容1docker exec -it webserver bash 解释:我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令, 也就是获得一个可以操作的 Shell。 然后，我们用 Hello ,Docker! 内容覆盖/usr/share/nginx/html/index.html的内容 我们修改了容器的文件，也就是改动了容器的储存层。我们可以通过 docker diff 命令看到具体的改动 1docker diff webserver 现在我们定制好了变化，将其保存下来形成镜像。Docker 提供了一个 docker commit 命令, 可以将容器的存储层保存下来成为镜像。 换句话说，就是在原有镜像的基础上，在叠加容器的存储层，并构成新的镜像 1docker commit [选项] &lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]] 12345docker commit \--author &quot;didiaoyuan &lt;didiaoyuan@gmail.com&gt;&quot; \--message &quot;修改了默认网页&quot; \webserver \nginx:v2 现在我们可以在 docker images 中看到这个修改后的镜像:12docker images nginx(注意在生成新nginx：v2的时候注意拼写错误，本人在这上面卡了一会！) 通过docker history查看镜像内的历史变化1docker history nginx:v2 然后我们允许新的镜像1docker run --name web2 -d -p 82:80 nginx:v2 通过localhost:82访问 慎用 docker commit 大部分引用书上的解释和自己的理解，文书出处与 GitBook《Docker 从入门与实践》 虽然，上面解释 docker commit 可以直观的理解镜像的分层概念，但是实际上不会使用 commit 来生成镜像，而是使用 dockerfile 生成镜像。 原因： 如果你仔细发现 docker diff webserver 的结果，会发现，除了我们修改的 index.html 文件外还有许多文件被改动了或者添加。如果是安装了软件包、编译构建，那会产生大量的无关内容被添加进来，会导致镜像十分臃肿。 使用 docker commit 对镜像的操作都是暗箱操作，生成的镜像都是黑箱镜像，因为除了制作人知道怎么生成，别人都不清楚，何况时间久了制作人也不清楚具体的操作，所以这种操作维护起来很难。 回顾之前的分层储存概念，除当前层外，之前的层是不会发生变化的，就是任何改变结果仅仅是在当前层进行操作(标记、添加、修改..)而不会改动上一层，使用 commit 制作镜像，以及后期修改，每一层都会让镜像更臃肿一次，所删除的上一层的东西不会消失，会一直如影随形的跟着这个镜像，只会让这个镜像更加臃肿。]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Docker(2017-9-29)]]></title>
    <url>%2F2017%2F09%2F29%2F%E5%AD%A6%E4%B9%A0Docker-2017-9-29%2F</url>
    <content type="text"><![CDATA[本节学习目录 Docker的优势 Docker 基本概念 Docker 安装 使用 Docker 镜像 获取镜像 运行 列出镜像 镜像体积 通过自学关于 Docker 的知识,因为不太懂详细的说明，所以在编写的时候，采用目录总结(通过先理清楚整体框架，然后在进行知识的填充,我喜欢用这种方式，因为有条理性吧,自创方法,不要见笑！)的方式 Docker的优势 更高效的利用系统资源 更快速的启动时间 一致的运行环境 持续交付和部署 更轻松的迁移 更轻松的维护与扩展 Docker 基本概念 Docker 镜像 Docker 容器 Docker 仓库 Docker Registry 公开服务 Docker Registry 私有服务 Docker 安装 Docker 版本介绍 Docker 各环境的安装(CE) Linux Docker Windows 10 下载安装 Docker for Windows 注册 Docler Hub 账号 注册阿里云加速器和DaoCloud settings 配置 Daemon 配置 JSON 字符串 检查加速器是否生效(Linux 系统下配置完加速器需要检查是否生效) macOS 使用 Docker 镜像获取镜像 1docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt; Docker Registry地址: &lt;域名/IP&gt; [:端口号] 默认地址是 Docker Hub 仓库名：使用两段式名称&lt;用户名&gt;/&lt;软件名&gt; 对于 Docker Hub,如果不给出用户名，则默认为Library ,也就是官方镜像 Test： 解释：镜像是由多层存储结构所构成，所有下载也是一层层得去下载，并非单一文件。命令默认地址就是从 Docker Hub 获取镜像 解释: 下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载的一致性 思考问题：windows下的文件去哪了？(以下为网上搜索的解释)解决：1、windows上的docker本质上还是借助与windows平台的hyper-v创建一个linux虚拟机，你执行的所有命令都是在这个虚拟机里执行的，所有pull到本地的image都会在虚拟机的Virtual hard disks目录的文件中，这个文件就是虚拟硬盘文件（有点类似与vmware的原理）。因此你打开hyper-v管理器，可以找到docker创建的虚拟机，点击左侧的虚拟机名称，然后再点击右边的移动选项，按照向导将虚拟机移动到其他目录即可。另外还可以在菜单栏点击:操作-&gt;Hyper-v设置，来调整你所有虚拟机的虚拟硬盘文件的默认存储位置。2、网上的关于pull 的镜像 路径地址转移 运行 如果我们打算运行刚才的镜像，可以执行以下的命令。1docker run -it --rm ubuntu:14.04 bash docker run：运行容器命令-it：-i、交互式操作，一个是-t、终端。我们打算进入 bash 执行一些命令并查看返回结果，因此需要交互式终端–rm：容器退出后将删除，避免空间浪费exit 退出 思考问题：bash 是什么?解决：百度–bash 是一个为GNU计划编写的Unix shell。 列出镜像1docker images 列表包括： 仓库名 标签 镜像 ID 所占控件 镜像体积 标识的体积和 Docker Hub 上的不同。因为 Docker Hub 中显示的是体积压缩的，在镜像下载和上传过程中镜像是保持着压缩状态，所以显示的是网络传输中关系的流量大小，本地是解压后的大小 docker images 下的体积综合并不是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构,并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union Fs ，相同的层只需要保存一份即可,所以实际镜像要小的多 Docker —几个概念的理解]]></content>
      <categories>
        <category>Docker笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git服务器搭建]]></title>
    <url>%2F2017%2F09%2F29%2FGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[git中远程仓库与本地仓库没什么区别，只是提供了一个24小时不关机的服务器，方便不同的机器获取和开发，然而托管于在线GitHub网址是开源的，大多数公司不希望自己的代码被别人知道，所以那么选择SVN集中式版本开发，要么自己搭建Git服务器，这节主要学习搭建Git服务器的知识 Git服务器搭建 准备工作： 准备一台 Linux 的机器（Ubuntu或者 Debian） 安装 git: 1sudo apt-get install git 创建git用户，用来运行 git 服务 1sudo adduser git 收集所有需要访问用户的GitHub上面的公钥 就是用户自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authoriz ed_keys文件里，一行一个 初始化版本仓库,假定是/srv/sample.git,在/srv目录下输入1sudo git init --bare sample.git Git 就会创建一个裸仓库,裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享,所有不让用户直接登记到服务器上去改服务区,并且服务器上的 Git 仓库通常都是 .git 结尾。然后，把owner 改为git:1sudo chown -R git:git sample.git 禁用 shell 处于安全考虑，创建git的用户不允许登录shell，找到etc/passwd文件找到类似下面的一行： 123git:x:1001:1001:,,,:/home/git:/bin/bash改为git:x:1001:1001:,,,:/home/usr/bin/git-shell 这样git用户可以正常通过ssh使用git，但无法登录shell，因为为git用户指定的shell登录就自动退出。 验证服务器git clone 克隆远程库 1git clone git@server:/srv/sample.git 涉及到的知识: apk 是Debian及其派生发行版的软件包管理器 Sudo 是一种程序，用于类Unix操作系统如BSD，Mac OS X，以及GNU/Linux以允许用户通过安全的方式使用特殊的权限运行程序（通常为系统的超级用户）。]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git继续学习(二)]]></title>
    <url>%2F2017%2F09%2F27%2FGit%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[之前的仓库操作跟SVN操作没甚区别，现在学习git独特的功能之一，远程仓库，配合GitHub网站托管代码块 远程仓库Git仓库与GitHub仓库的SSH加密第1步： 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C “youremail@example.com” id_rsa 是私钥id_rsa.pub 是公钥 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： ssh Key 目的是让 GitHub 识别推送上来的是自己的内容，并且GitHub支持添加多个Key 也意味着 你可以有若干的电脑往github上提交东西 注意：既然github是公共网站，所以提交上去的代码都是公开的要想让自己的代码不公开有两种方法 给github缴费使用私有版本库 自己搭建Git服务器 Git与GitHub进行同步 GitHub上创建一个版本库,获取ssh地址，用来对接 git remote add origin git@github.com:xxx/仓库名称 添加远程库的名称是origin,这是Git默认的叫法，也可以改成其他的,但是origin这个名字一看就知道是远程库,完成之后,就可以把本地的文件上传到远程库中了。 git push -u origin master 因为第一次推送到github,所以添加 -u 的参数，因为提交的是本地master分支，远程库是空的，所以会把master分支内容推送的远程库的master分支，还会把本地master与远程库master分支关联起来，在以后的推送或者拉取时就可以简化命令。以后直接使用git push origin master就可以了。 克隆远程版本库 git clone 版本库地址git支持多种协议 https ssh 其中通过ssh原生git协议速度最快 分支管理创建与合并分支原网站分支图 总结: git branch 查看分支 git branch ‘name’ 创建分支 git checkout ‘name’ 切换分支 git checkout -b ‘name’ 创建并切换分支 git merge ‘name’ 合并分支 git branch -d ‘name’ 删除分支 解决冲突 当两个分支进行合并出现冲突的时候，会出现冲突，冲突发生在两个分支在相同的位置上进行了修改，我们需要选在保留的部分删去不要的，处理后在进行提交 如何处理冲突可以查看文章下方如何处理冲突 git log –graph 查看分支合并图 分支管理策略 我们在合并分支的时候，一般会进入Fast forward快速合并模式，这个模式有个弊端是，直接删除分支，会丢失分支信息使用–no-ff参数普通合并，保留分支信息记录 Bug分支 场景：当我们在分支进行开发的时候，发现一个bug，可能通过建立一个修复bug的分支进行修复，但是你的开发分支正在编写，但是并不想提交，因为还为完成工作，但是你又必须现在就修复bug Git提供了一个stash功能，可以把你的工作展示保存，等使用的时候再恢复，如何使用呢？ 在开发分支下git stash git status查看工作区是空的 bug修复后切换到开发分支 git stash list 查看储存的 恢复工作区git stash pop 删除list列表，并恢复工作区内容 feature分支 场景:当我们有很多想法的时候，添加很多特效，功能的时候，通常创建一个feature分支，进行开发,但是会出现开发完好，突然说不需要添加这个功能了,在还没有合并提交的情况下删除 git branch -d feature会提示错误，未合并 如果要丢弃一个没有被合并过的分支，可以通过git branch -D ‘name’ 强行删除。 多人协助 git remote -v查看远程库的详细信息推送分支： 总结： 首先 git push origin 分支名称 将本地推送到远程库中 如果推送失败，因为远程分支比你的本地更新，git pull 远程库 分支命令获取最近版本，然后视图合并 如果合并冲突，解决冲突，并在本地提交git push origin 分支名称 如果git pull 提示”no tracking information “,说明本地分支，和远程分支的连接关系没有创建，git branch –set-upstream 分支名称 origin/分支名称 以上就是多人协作的工作模式 标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。原链接 在需要打标签的分支下执行下面的命令git tag v1.0 默认标签是打在最新的commit 上的，如果忘记打标签，可以找到需要打标签的commit_ID,然后打上标签git tag v1.1 commit_ID 查看所有标签git tag 根据标签的名称查看详细信息git show 标签名称 忽略特殊文件(9月29日) 场景:当我们在开发自己的项目的时候，是否会遇到配置文件保存密码，获取自动生成的文件，这些文件我们不需要让他添加到版本库中，所以git中.gitigore文件就是存放需要忽略的文件信息原文介绍 如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 文件格式如下 1234567#python 文件基本忽略*.py[cod]*.so*.egg*.egg-infodistbuild 将编辑好的.gitignore文件提交到git中 场景:如果你确实要强制添加内容，可以通过git add -f ‘name’ 场景:如果想要检查文件关于忽略的信息，可以通过git ceck-ignore这条命令只能查询添加不上的忽略信息 配置别名 功能:将命令简化，git status 简化 git st 一系列的命令简化操作 基本格式:1234$ git config --global alias.st status$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 还有一个用发，alias设置别名也可以替换长的命令 1$ git config --global alias.unstage &apos;reset HEAD&apos; 设置了上面的命令以后回退版本，git reset unstage 就可以了 配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用 配置文件目录 .git/config]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git继续学习]]></title>
    <url>%2F2017%2F09%2F26%2FGit%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[再次学习 git 完善以前没有注意到的问题，主要学习廖雪峰的git教程，基本命令在前面已经总结，但是具体的实际开发过程中需要注意的场景将重新总结。希望学习的可以访问原网站，一下是自己的总结，方便以后个人查询 Git工作区，暂存区与版本库 git add: 将文件从工作区添加到暂存区 git commit: 将暂存区存储到版本库 版本回退 当我们 commit 很多操作的情况系，我们想要回到之前的版本，可以通过版本回退，回退到之前的版本,如果忘了如何操作我们可以查询当前状态，根据提示操作 git status(git status 是查询工作区的状态) 12git reset --hard HEAD^(回退到上一个提交版本 HEAD~回退的次数)git reset --hard commit_ID(回退到固定id的版本) 以上可能需要 git log 查询提交ID，其中在命令后面添加 –pretty=oneline 表示只显示ID 和提交的消息 总结： HEAD 指向的版本问当前版本所以后面一个^表示向前跳转一个~+数字表示向前跳几个 如果在回退到之前的版本忘记了commit_ID可以通过git reglog查询记录所有的操作 管理修改 场景1：当我们在工作区修改了一些内容，想要回到以前的版本中 方法1: 手动删除不需要的内容 方法2: git chectout –filename 可以丢弃工作区的内容 场景2 :当我们不想要的修改已经提交到了暂存区内,并且又在工作区修改的一些内容，该如何恢复？ 方法: git reset HEAD filename这个命令在git status后也可看到该提示。如下图:将文件从回退到工作区。场景1的方法,将文件恢复到add前 场景3 :当我们不想要的修改提交到了版本库，该如何恢复？ 方法: 先reset 回退到前一个版本库。就OK啦 删除操作 当我们在完成了提交版本库的操作，删除了在工作区的一个文件，第一种场景是我们确实要删除它，那就add ——&gt; commit 完成更新版本库。第二种是，我们误删了文件想要恢复它。 方法：git checkout –filename 总结：git checkout 其实是用版本库里的版本替换工作区的版本，无论是修改还是删除,都可以“一键还原” 注意：git rm用于删除一个文件。如果这个文件已经提交到了版本库，那就不用担心误删，但是你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN学习--高级应用]]></title>
    <url>%2F2017%2F09%2F24%2FSVN%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SVN高级应用，主要用于svn版本库管理员级别的操作，这些操作需要暂停重启svn的操作 hooks钩子应用 hooks：当执行默写特定操作时触发执行预先设定的任务 不是很理解，所以用大白话说吧，后期继续学习的过程中，完善… 位置:服务器版本库/hooks/hook-scripts 1234567891011121314151617181920212223242526post-commit在提交完成，成功创建版本之后执行该钩子，提交已经完成，不可更改，因此本脚本的返回值被忽略。post-lock对文件进行加锁操作之后执行该脚本post-revprop-change在修改 revision 属性之后，执行该脚本。因为修改稿已经完成，不可更改，因此本脚本的返回值被忽略（不过实际上的实现似乎是该脚本的正确执行与否影响属性修改）post-unlock对文件进行解锁操作之后执行该脚本pre-commit在 Subversion transaction 完毕之后，在提交之前，执行该脚本pre-lock对文件进行加锁操作之前执行该脚本pre-revprop-change在修改 revision 属性之前，执行该脚本pre-unlock对文件进行解锁操作之前执行该脚本start-commit在客户端还没有向服务器提交数据之前，即还没有建立 Subversion transaction（缩写为 txn） 之前，执行执行该脚本 如图所示：以上都以.tmpl后缀结尾的。代表模板文件，使用的时候去掉后缀名，就是可执行shell脚本。比如图一，post-commit文件，当用户使用commit后出发执行脚本。 因为在学习阶段，并不清楚实际上的应用，大概明白了hooks具体是用来干什么的，实际上怎么用，以后遇到了在总结，网上找了相关的博客，看了一些，推荐一个感觉靠谱的网站利用SVN的post-commit钩子实现多项目自动同步 版本库精简与丢弃 在后期开发中，版本库的版本号会越来越的多，通过版本库的精简，丢弃靠前的版本，来达到版本库瘦身的目的 停止版本库服务(防止有新的版本提交 killall svnserve) 把需要保留的版本库备份(svnadmin dump 版本库文件系统路径 -r 2:4 &gt; 备份文件) 创建新的版本库存放精简过后的版本库(svnadmin create 路径/版本库名称) 导入备份(svnadmin load 版本库文件系统路径/ &lt; 备份文件) 复制原来的版本库权限配置文件 conf/* 删除旧的版本库(rm -rvf 路径) 运行svn服务 完成 注意:精简前checkout的工作副本不能使用了，原因是在精简和的版本号重新编号，与之前的不匹配，所以精简后重新checkout版本库 版本库迁移与switch重定向 迁移在上个知识点就用到了版本库操作 迁移方式2 ： killall svnserve(windows 下直接关闭) 把 版本库 压缩成 xxx.zip 复制xxx.zip 到新服务 器并解压 在新服务器上运行版本库 一行方法有点简单粗暴!! 因为更换了服务器，所以我们需要把工作副本重新定向到新的URL上去，这个过程称为重定向，使用第二种迁移方式重定向方便简单。 svn switch –relocate svn://原来版本库url svn://新版本库url 常见坑与总结]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN学习--进阶]]></title>
    <url>%2F2017%2F09%2F24%2FSVN%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[SVN进阶应用ls、st、log、info1234svn list --列出当前目录下处于版本控制的所有文件(添加-v显示更详细信息 --recursive 强制递归文件中的信息)svn status --列出工作副本中的文件状态svn log --查看提交日志svn info --查看工作副本及文件的详细信息 svn status中的状态说明 遇到问题：svn log 后显示 svn: E220001: 条目不可读解决：服务器的权限配置文件conf/svnserve.conf 中设置anon-access = none 即可. 然后重启Subversion 服务. 多版本库解决方案解决方案A 场景:当只有一台服务器当做版本库的时候，同一个服务器要开很多次服务，但是每一种服务对应只能一个端口号，所以当我们创建很多版本库的同时，再启动服务的时候也要手动分配一个端口号，svn默认端口3690 端口号知识 回顾创建版本库： svnserve create 版本库名称 为其他版本库启动服务12svnserve -d -r 路径1 --listen-port 3691svnserve -d -r 路径2 --listen-port 3692 注意：当同一个服务器有多个版本库，在使用checkout 后的url 要加上版本号，否则或链接默认端口号3690 killallserve –关闭所有服务 使用这种手动修改端口号的方法只适用于少量版本库 解决方案B 启动服务的路径为存放各个版本库的父级目录版本库 1svnserve -d -r 父级目录 只使用一个端口号一次性启动了所有的版本库，条件时所有版本库要建立在一个目录下 唯一要注意的是，当我们只用一个端口号对接多个服务器，在checkout下有点不同 12（客户端） svn co svn:0.0.0.0/需要的版本库 总结 svn copy 复制：工作副本与工作副本之间的复制。。。。在这之间需要理清楚复制从哪到哪 作副本与工作副本123（单个文件复制） svn copy index.html copy.html &lt;!--复制到copy.html新文件中--&gt; 1234（批量文件复制） svn copy index.html ./复制到的路径 &lt;!--只能复制到不同目录文件中，因为文件中文件名id唯一--&gt; &lt;!-- .表示当前目录 --&gt; 工作副本到服务器版本库 这种不经过本地的代码直接复制到版本库中，成功后将版本号+1 1svn copy index.htm svn:0.0.0.0/版本库名称/目标 -m &quot;copy a file&quot; 注意： 服务器版本库到工作副本12svn copy svn:0.0.0.0/版本库名称/目标 复制到的文件&lt;!--这种操作支持跨库操作--&gt; 可用从其他工作副本 获取到线上版本库 版本库到版本库 继续阅读——&gt; 主干版本与分支版本 在主干版本目录中创建一个目录区分主版本和分支版本 创建一个主干版本1svn cp svn://0.0.0.0/版本库名称/ svn://0.0.0.0/版本库名称/trunk -m &quot;setup a trunk&quot; 创建一个分支版本1svn cp svn:0.0.0.0/版本库名称/版本库名称 svn:0.0.0.0/版本库名称/branch -m &quot;create a branch&quot;]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN学习]]></title>
    <url>%2F2017%2F09%2F23%2FSVN%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[在中小型企业中开发一般会用到SVN 进行分布式开发，通过学习，熟悉以后的开发流程 概念这个百度吧，概念一般很专业，但不容易懂 CVS SVN GIT 三者之间的区别 SVN介绍与安装SVN 分服务器端和客户端，一般客户端在本地创建代码库，服务端是在远程服务器上搭建代码库 注意：在使用命令的时候要搞清算是服务端命令还是客户端命令 版本库的创建与删除—–服务端命令12svnadmin create 路径&lt;!--创建服务器版本库 --&gt; 可以添加参数指定版本库储存的数据类型12svnadmin create --fs-type fsfs 版本库的名称&lt;!-- fsfs表示数据保存类型 --&gt; 删除版本库1rm -rvf 删除的文件夹 版本库配置 位于版本库文件下的 path/repos/conf 文件夹其中有三个文件 1、svnserve.conf文件 在svn版本库权限上注意更新的概念： 更新代码：是从服务器更新到本地的操作 提交代码：是从本地修改的代码提交到服务器上的过程 打开svnserve.conf 前两个表示在无用户密码的情况下只有只读的权限，再有密码情况下拥有读写提交上传的权限12password-db = 路径（默认password）&lt;!-- 表示密码文件的路径 --&gt; 12&lt;!-- authz-db = 路径（默认authz）表示用户文件的路径 --&gt; 2、password文件 格式 如上添加一个didiaoyuan用户 密码为123456以此后面用户都可以按照这个格式添加 3、authz文件如图中注释 版本库的访问需要先搭建svn服务启动,其他客户端才能访问 运行svn服务1svnserve -d -r /路径/版本库 获取checkout —–客户端命令123svn co(checkout) svn://版本库服务器地址 (--username imocc --password 123456)[括号内可以不添加]&lt;!-- 首先进入输入服务器密码 --&gt; 获取checkout —–客户端图形界面管理下载tortoiesSVN 在文件夹先右键 第一行填写版本库服务器地址 第二行需要导入的文件夹地址 SVN自启动概念，当服务器开启自动启动svn服务linux 开机根据启动级别启动乌邦图下etc/rc.local文件中 exit 0 上面 写入 svn启动服务命令 svnserve -d -r /路径 不同系统下修改的方式不同，可通过百度或者google查询修改方式 SVN常见术语与文件状态 常见的客户端命令12345678910111213141516171819202122231.svn add --添加到版本控制文件中&lt;!-- 在svn客户端下从无版本控制状态添加文件到版本控制下 --&gt;svn add 文件名或文件夹 --当时用文件夹时，会自动递归添加文件夹下的所有文件svn add 文件夹 --non--recursive --添加所有文件的时候svn add *&lt;!-- 注意：当出现前面只添加了文件夹没添加里面内容时，使用*只会把没有添加的添加上并且只扫描到文件夹不会添加文件夹中的文件解决 --&gt;svn add * --force --强制执行svn commit -m &quot;&quot; 文件名 --提交修改到服务器&lt;!-- 创建一个新的版本号 缩写 ci --&gt;类似gitsvn commit -m &quot;&quot; --可以添加备注信息 并提示版本号svn update --更新工作副本 &lt;!-- 当已经更新最新版本更新在使用命令将不会进行更新，默认只更新一次 --&gt;svn delete --从版本库中删除文件或者目录svn diff(di) -r 需要比较的版本号 --版本差异比较 版本号 1:3 比较版本1和3svn mkdir --创建目录并添加到版本控制svn cat --路径文件 --脱离版本控制，查看文件 工作副本还原12svn revert * --只会扫描当前目录的所有修改后还原svn revert --recursive * --递归扫描其他文件夹中的 二进制冲突与树冲突场景：冲突常出现在工作副本长时间未更新冲突：在其他程序员提交相同位置代码到代码块，而自己因为没有update，在相同的位置下进行修改，当发生提交的时候发生冲突二进制冲突：文件一般是二进制，精确到代码的那一行树冲突：不是二进制文件，无法精确具体一行处理冲突 解读： update 弹出输入提示123456p:推迟提交df：显示不同e： 编辑文件m：合并mc：保留自己tc: 保留别人的 df 对比图中123+&lt;&lt;&lt;&lt;&lt;&lt;自己的代码=======+&gt;&gt;&gt;&gt;&gt;&gt; xxx人的代码 推荐p推迟处理，推迟后回生成冲突文件，删除不需要的 123&lt;!--通过文件修改后必须使用一下命令--&gt;svn resolved 文件名&lt;!--消除冲突后提交--&gt; 锁定与解锁12svn lock -锁定文件，防止其他成员对文件进行提交svn unlock -解锁文件 lock 是一种conflict 处理方案，当遇到很多人对同一个文件进行修改，锁定只会影响开发效率 问题1：服务器上的版本库文件在哪里？ 把文件上传到SVN版本库后,上传的文件不再以文件原来的格式存储,而是被svn以它自定义的格式压缩成版本库数据,存放在版本库中。（17年9月26日）]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python个人笔记(2)]]></title>
    <url>%2F2017%2F09%2F03%2FPython%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[《第六章》字典 使用字典在 Python 中，字典是一系列键-值对。1格式：name=&#123;'key':'value','key2':'value'&#125; 添加键-值对1格式：box[key]=value，利用这种方式，可以先创建一个空的字典，在添加键-值 修改字典中的值1同添加键-值一样，当添加的键相同的时候，变为修改字典中的值 删除键-值对1格式：del语句删除不需要的键-值 由类似对象组成的字典12345favorite_languages=&#123; 'jen':'python', 'jack':'java', 'tom':'c++', &#125; 遍历字典12for key,value in box.items(): print(key,value); 遍历字典中的所以键12for name in box.keys(): print(name) 按顺序遍历字典中的所有键12for name in sorted(box.items()): print(name) 遍历字典中的所有值12for name in box.values(): print(name) 嵌套字典列表 列表嵌套字典 字典嵌套字典 字典嵌套列表 《第七章》用户输入和while循环函数 input() 的工作原理input() 让程序暂停运行，等待用户输入 12age=input('请输入你的年龄')print(age) *在支持暂停的编辑器下运行 使用int() 来获取数值输入在用input() 获取用户的输入值中，接受的是字符串类型，如果我们要接受数值，可以用int()函数1234age=input('请输入您的名字')age=int()if(age&gt;3) print('欢迎'+age+'你') 求模运算符 % 取余 while 循环 for循环用于针对集合中每个元素的代码块，不进行修改内容 while循环不断的运行，知道不符合条件时退出让用户选择何时退出 让循环条件不满足 使用标志123456while 的循环条件为布尔类型active=Trueage=int()while active: if age==18: active=False 使用 break 退出循环 在循环中使用break 将直接跳出讯循环 使用 continue 在循环中使用 continue 将跳出循环，执行下一个循环 *在使用while循环的时候避免无限循环 使用while循环来处理列表和字典思路：while循环 一个列表 ,.pop()删除的内容复制给另一个列表中删除包含特定值得所有列表元素思路：while循环判断元素是否在列表中，然后remove() #《第八章》函数定义函数1234 def greet_user(): print('hello')#调用函数 greet_user() 向函数传递信息123def greet_user(username): print('hello,'+username.title())greet-user('jack') 实参和形参 *一个有具体值，一个没有 传递实参位置实参的顺序在定义函数的同时，形参的顺序，也规定了在调用函数填入实参的顺序关键字实参关键字实参无需考虑顺序,在调用函数的时候，参数通过键-值传递1234def greet_user(first_name,last_name): print('Hello'+first_name+','+last_name)greet_user(last_name='abc',first_name='python') 默认值给形参指定默认值 ，在实参默认省略的时候1234def greet_user(first_name,last_name='allen'): print('Hello'+first_name+','+last_name)greet_user(first_name='python') *避免实参错误 返回值return让实参变成可选的有时候,需要让实参变为可选的，这样使用函数的人在需要才提供额外的信息，通过讲函数的形参设为=’’123def greet_user(first_name,last_name=''): print('Hello'+first_name+','+last_name)greet_user('hello') 结合函数和while循环在函数中使用while循环传递列表将函数传入的参数为列表，并for循环遍历 禁止函数修改列表当我们不需要修改原列表内容的时候可以向函数传递列表副本，通过切片的原理1234567格式： def show_list(list_names): for list in list_names: print(list)list_name=['a','b','c']greet_user(list_name[:])print(list_name) 传递任意数量的实参*表示Python 创建一个名为 XX 的空元组12345def make_print(*toppings): """打印""" print(topping)make_print('a')make_print('a','b','c') 任意数量的关键字参数 表示可以接受任意数量的键-值数据12345def make_print(**toppings): """打印""" print(topping)make_print('a':'B')make_print('a':'B','c':'C') 将函数储存在模块中导入模块将写好的函数放在.py文件中导入模块： 1import file_name 导入特定的函数1格式：from module_name import function_name 使用as给函数指定别名1格式：import file_name as fn 使用as给模块函数名指定别名1格式：from module_name import file_name as fn –&lt;第八章&gt;END–]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python个人笔记(1)]]></title>
    <url>%2F2017%2F09%2F01%2FPython%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[《第一章》Python的安装《第二章》变量和简单数据类型字符串命名和使用：首字母不能为数字 修改字符串的大小写： .tittle() 首字母大写 .upper() 全部大写 .lower() 全部小写 合并字符串加号（+）使用制表或者换行符添加空白\t \n删除空白 .rstript() 删除右边 .lstript() 删除左边 .stript() 删除两端 数字整数加+减-乘除/其中 2乘表示平方，后面的数字表示乘多少次 浮点数结果包含的小数位数是不确定的1234&gt;&gt;&gt; 0.2+0.10.30000000004&gt;&gt;&gt;3 * 0.10.30000000004 python2 中的整数 3/2 =1 保留整数部分 使用 str()避免类型错误 注释使用 # 《第三章》列表([ ]) 表示列表并使用逗号来分隔其中的元素访问任意元素通过索引12box=['a','b','c']print(box[1]) *索引从0而不是1开始 修改，添加和删除元素**替换1box[1]='d'; 添加12append('d')# 末尾添加 插入1insert(index,值) 删除12345678910111213del box[1]# del 语句直接删除pop() # 末尾删除 *术语弹出（pop）&gt;&gt;&gt;box = ['a','b']&gt;&gt;&gt;print(box.pop(1))b# 弹出列表任意位置元素remove(值)# 根据值删除元素 组织列表 sort() 永久排序 sort(reverse=Ture) 排序反转 sorted() 对列表进行临时排序 reverse() 不进行倒序，只是进行列表反向输出 长度12length=box.len()print(len(box)) *避免索引引起错误 《第四章》操作列表遍历整个列表for循环格式： for 单个名称 in 列表 ： 语句 *避免缩进带来的错误遗漏冒号带来的错误 创建数值列表1234567891011range(start,end)# 创建数字列表&gt;&gt;&gt; print(list(range(1,5)))[1,2,3,4]# list()将range()的结果直接转换为列表&gt;&gt;&gt; print(list(range(1,5,2)))[2,4]#range(start,end,step) 最后一个指定步长 对数字列表进行简单的统计计算 min() 取列表最小值 max() 取列表最大值 sum() 取合 列表解析列表解析，通过三四行代码实现的效果，通过列表解析，一行进行实现。123456789# 法1squares=[]for value in range(1,5): squares.append(value**2)print(squares)# 法2&gt;&gt;&gt;squares=[value**2 for value in range(1,5)]&gt;&gt;&gt;print(squares) 使用列表的一部分切片处理列表中的部分元素可以使用切片12345678910111213141516171819box=['g','a','b']print(box[0:1])[g,a]# 切取：前开始：后结束的部分box=['g','a','b']print(box[:1])[g,a]# :前没有数字表示从开始到指定结束box=['g','a','b']print(box[1:])[a，b]# ：后没有数字表示从指定开始到结束box=['g','a','b']print(box[-2：][a,b]# 负数索引表示从尾部切取 遍历切片遍历列表部分元素，可在循环中使用切片1234&gt;&gt;&gt;box=['g','a','b']&gt;&gt;&gt;for value in box[-2:]:&gt;&gt;&gt; print(value)[a,b] 复制列表同时省略：前后12&gt;&gt;&gt;box=['g','a','b']&gt;&gt;&gt;box2=box[:] 元组python 将不能修改的值称之为不可变的,而不可变的列表称为元组() 圆括号表示元组定义元组12abc=(200,50)print(abc[0]) *尝试修改元组会报错 修改元组虽然不能修改元组的元素，但可以给储存元组的变量赋值。12345678910&gt;&gt;&gt;box=(200,50)&gt;&gt;&gt;for value in box:&gt;&gt;&gt; print(value)20050&gt;&gt;&gt;box=(100,100)&gt;&gt;&gt;for value in box: &gt;&gt;&gt; print(value)100100 代码格式 每行不超过 80 字符 注释行不超过 72 字符 《第五章》 IF 语句格式：1234if 条件： 语句 else: 语句 检查多个条件 使用 and 检查多个条件（同时满足） 使用 or 检查多个条件（满足一个即可） 使用 in 检查是否包含在列表中 if-elif-else使用if-elif-else处理多分支语句12345678910111213141516&gt;&gt;&gt;for value in range(1,8):&gt;&gt;&gt; if value==1:&gt;&gt;&gt; print(str(value)+'st')&gt;&gt;&gt; elif value==2:&gt;&gt;&gt; print(str(value)+'nd')&gt;&gt;&gt; elid value==3:&gt;&gt;&gt; print(str(value)+'rd')&gt;&gt;&gt; else:&gt;&gt;&gt; print(str(value)+'th')1st2nd3rd4th5th6th7th &lt;第五章–END–&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Python(5)]]></title>
    <url>%2F2017%2F08%2F07%2F%E8%8F%9C%E9%B8%9FPython(5)%2F</url>
    <content type="text"><![CDATA[电影网站 实现一个电影页面 实现基本要素 电影标题 电影描述 电影图片 电影网站 创建 Movie 类创建 media.py 的文件12345678910import webbrowser# 创建 Movie 类class Movie():# 定义 __init__方法 self 代表实例化对象def __init__(self,movie_title,movie_storyline,poster_image,trailer_youtube): self.title=movie_title self.storyline=movie_storyline self.poster_image_url=poster_image self.trailer_youtube_url=trailer_youtube 调用 Movie 类创建一个 show_html.py 的文件1234# 导入 media 文件import mediaopen_html=media.Movie("玩具总动员","一群玩具的大作战...","http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg","https://v.qq.com/x/cover/cezngt65nqkg580.html")print(open_html.title) 用网页打开下载 fresh_tomatoes.py 这个文件包含要生成的 HTML 文件 和两个方法改变标题，电影图片… 在 show_html.py 文件中修改 12345678910# 导入 media 文件import mediaimport fresh_tomatoestoy_movie = media.Movie("玩具总动员","一群玩具的大作战...","http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg","https://v.qq.com/x/cover/cezngt65nqkg580.html")toy_movie1 = media.Movie("玩具总动员","一群玩具的大作战...","http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg","https://v.qq.com/x/cover/cezngt65nqkg580.html")toy_movie2 = media.Movie("玩具总动员","一群玩具的大作战...","http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg","https://v.qq.com/x/cover/cezngt65nqkg580.html")toy_movie3 = media.Movie("玩具总动员","一群玩具的大作战...","http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg","https://v.qq.com/x/cover/cezngt65nqkg580.html")movies=[toy_movie,toy_movie1,toy_movie2,toy_movie3]fresh_tomatoes.open_movies_page(movies) 效果： 解决乱码 fresh_tomatoes.py 文件中 编写的 HTML 文件将 编码方式改成 GBK]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Python(4)]]></title>
    <url>%2F2017%2F08%2F07%2F%E8%8F%9C%E9%B8%9FPython(4)%2F</url>
    <content type="text"><![CDATA[不敬语查询123456789# 定义一个读取的方法def read_text(): # 调用 open 内置函数打开文件 quotes = open("E:\ButterKnife.txt") # 读取文件 contents_of_file=quotes.read() print(contents_of_file) quotes.close()read_text() 内置函数Ptyhon 中的内置函数 利用代码访问网站不敬语查询网站 可能需要进行科学上网，利用这个网站后缀，进行查询是否存在不文明的字12345678910111213import urllibdef read_text(): quotes = open("E:\ButterKnife.txt") contents_of_file=quotes.read() print(contents_of_file) quotes.close() check_profanity(contents_of_file)def check_profanity(check_text): connection=urllib.urlopen("http://www.wdylike.appspot.com/?q="+check_text) output=connection.read() print(output) connection.close()read_text()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Python(3)]]></title>
    <url>%2F2017%2F07%2F28%2F%E8%8F%9C%E9%B8%9FPython(3)%2F</url>
    <content type="text"><![CDATA[使用类-发送消息实现结果：通过 twilio 实现给手机发送短信 下载 twilio进入 cmd 命令窗口，选择其中一个 easy_install twilio pip install twilio 注册 twilio Twilio 注册地址 在注册的时候选择 SMS 获取sid和token 获取发送号码 123456789101112131415from twilio.rest import Client# Your Account SID from twilio.com/consoleaccount_sid = "ACdxxxxxxxxxxxxxxxxxxxxxxxx"# Your Auth Token from twilio.com/consoleauth_token = "d5xxxxxxxxxxxxxxxxxxxxxxxx"client = Client(account_sid, auth_token)# 电话号码在注册的时候会获取，接受手机是注册的手机message = client.messages.create( to="+861510xxxxxxx", from_="+16195667xxxx", body="I Love You !")# body 显示发送的内容print(message.sid) 执行结果 如何实现发送分析代码第一行，from 关键字获取twilio文件中的rest 文件，import 导入 Client 类可以通过GitHub中查看找到 twilio ——&gt; rest——&gt; init.py ——&gt; Client类 具体代码实现，可以自己查看 总结上一篇我们介绍了 Python类 的介绍，介绍类的实例化，这一章通过介绍 twilio 更加深入了解类的使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Python(2)]]></title>
    <url>%2F2017%2F07%2F27%2F%E8%8F%9C%E9%B8%9FPython(2)%2F</url>
    <content type="text"><![CDATA[Python 中的类前面使用到的函数都是直接调用函数，比如 webbrowser.open() 或 time.ctime() 这些通过调用函数来进行操作，今天我们使用 turtle 来介绍 Python 中的类 turtle先看我们需要实现的效果 turtle 翻译过来是乌龟的意思，它能实现绘画的效果，要想实现以上图案，需要先会画一条直线，然后正方形，然后旋转 画一个正方形12345678910111213141516171819202122232425262728import turtledef draw_square(some_param): # 定义循环变量 init=0 end=4 while(init&lt;end): # 向前走100码 some_param.forward(100) # 向右旋转90度 some_param.right(90) init+=1def draw_paint(): # 将turtle屏幕赋值给window window=turtle.Screen() window.bgcolor("red") # 执行turtle进行绘画 brad=turtle.Turtle() # 改变turtle的形状 brad.shape("turtle") # 改变turtle的颜色，两个参数第一个表示划线颜色，第二个表示箭头颜色 brad.color("yellow", "black") # 改变turtle的速度 brad.speed(10) draw_square(brad) # 将屏幕固定在屏幕上，点击后关闭 window.exitonclick()draw_paint() 现在画完了正方形，在把每次画完正方形后面添加移动角度123for i int range(1,36): draw_square(brad) brad.right(10) 其中有三个函数，用来改变turtle的属性 12345678# 执行turtle进行绘画brad=turtle.Turtle()# 改变turtle的形状brad.shape("turtle")# 改变turtle的颜色，两个参数第一个表示划线颜色，第二个表示箭头颜色brad.color("yellow", "black")# 改变turtle的速度brad.speed(10) 我们回顾一下 webbrowser.open() 和 turtle.Turtle()这两个虽然都是调用方法，但是turtle不同的是调用的一个Turtle()类，这个类有 init 函数进行初始化，跟其他语言差不多，在使用类，可以通过不同的实例进行不同的调用。类的概念好比一张设计图，我们的实例，相当于照着设计图设计不同的大楼。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Android(1)]]></title>
    <url>%2F2017%2F07%2F15%2F%E8%8F%9C%E9%B8%9FAndroid(2)%2F</url>
    <content type="text"><![CDATA[日志在应用中记录信息，选用的日志级别 ERROR 出现在程序崩溃或结束，用于记录明显的错误 WARN 不会出现崩溃，但会记录提示性警告 INFO 提示文本类消息 DEBUG VERBOSE WTF what a Terrible Failure 提示永远不可能发生的错误(强制设备停止，并输出调试报告) 资源]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb随心笔记(3)]]></title>
    <url>%2F2017%2F07%2F09%2FJavaWeb%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0(3)%2F</url>
    <content type="text"><![CDATA[简单的购物商城 思路 创建数据库表 连接数据库 创建 bean 层 创建 dao 层 三个页面第一个显示商品列表（利用 ArrayList 存储每一条信息） 第二个显示详情列表（利用 Item.getId() 记录点击的详情，进行数据库查询） 第三个显示购物列表（利用 插入数据库操作） 游览记录 通过 Cookie 记录游览记录， 创建 Cookie 创建字符串，将每次点击的id记录到一个字符串中 通过split 获取字符串数组 在biz 层处理后5条字符串，并将后五条存储在 ArrayList 中]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb随心笔记(2)]]></title>
    <url>%2F2017%2F07%2F08%2FJavaWeb%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[JSP 相关技术JSP 是在 HTML 页面中嵌入 Java 代码。HTML 负责页面的静态部分， Java 代码负责动态部分，java 代码获取服务端的数据，并利用数据在游览器上。JSP 的实质是 Servlet，具体通过 jsp 的生命周期理解。 JSP 指令格式:&lt;%@ page 属性名=”Value” 属性名=”Value” &gt;language=”java”Content-Type=”text/html;charset=utf-8”import=”” JSP 注释12345&lt;!-- --&gt; HTML 注释，可以再游览器中查看&lt;%-- --%&gt; 注释不能再游览器中查看&lt;% java 代码 %&gt; jsp 脚本 &lt;!% java 代码 %&gt; jsp 的声明，定义变量和方法&lt;%= %&gt; jsp 的表达式 可以调用 jsp 中声明的 java 代码 JSP 的生命周期详情页面:菜鸟教程 JSP 的内置对象 request response out (向游览器输出内容) page (表示当前页面) pageContent (当前页面的上下文环境，可以获取上下文的数据) session (一次会话) application (开始于服务器的启动,结束与服务器的结束) exception (异常) config (在 Servlet 初始化的时候来获取相关参数和传递信息) 利用 application 实现网站计数器12345678910&lt;%//获取应用中的Counter 值 if(application.getAttribute("counter")==null)&#123; application.setAttribute("counter",new Integer(1)); &#125; //如果存在就 +1 int value=(Integer)application.getAttribute("counter"); application.setAttribute("counter",new Integer(value+1));%&gt;欢迎第&lt;%application.getAttribute("conter") %&gt;名顾客访问！ javaBean 的简介 该类是一个公共类 必须有一个无参的构造方法 必须有所有的属性私有 通过 getter 和 setter 进行私有属性的存取 在 JSP 中使用 JavaBean普通方式 导包(&lt;%@page import=”bean.User”&gt;) 使用(&lt;% User user=new User()%&gt;) 使用 JSP 标签12&lt;jsp:useBean id="myUser" class="bean.User" scope="page"/&gt;用户名称&lt;%myUser.getName()%&gt; SetProperty 标签配合 useBean 标签使用，给你usebean 赋值1234//匹配信息到User 中的名字&lt;jsp:setProperty property="username" name="myUser" /&gt;//将密码匹配到User&lt;jsp:setProperty property="password" name="myUser" value="123456"/&gt; JavaBean 中作用域 page 当前页面有效 request 一次请求有效 session 一次会话有效 application 从服务器开启到服务器关闭有效 JSP 的动作和指令详情页面: JSP 的动作和指令 菜鸟教程 JSP 指令]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb随心笔记(1)]]></title>
    <url>%2F2017%2F07%2F07%2FJavaWeb%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[阅读目录 Q1: JavaSE JavaEE JavaME 的区别? Q2: Servlet 的作用？ Q3: WEB中 Servlet &lt; load-on-startup &gt;1&lt;/ load-on-startup &gt;标签代表什么意思 Q5: 如何获取访问的设备类型 Q6: 如何固定时间自动跳转页面 Q7: 如何设置一个下载页面 Q8:如何设置防盗链 Q9:如何利用 Cookie 判断首次登陆 Q10: Session Q1: JavaSE JavaEE JavaME 的区别? JavaSE 标准版本 JavaEE 企业版本 JavaME 移动版本 Q2: Servlet 的作用？ Q3: WEB中 Servlet &lt; load-on-startup &gt;1&lt;/ load-on-startup &gt;标签代表什么意思 伴随服务器的启动，启动Servlet 标签值中大于0或等于0的表示伴随服务器的启动，自动启动Servlet 标签值小于0或者没有标签的表示，选择时再启用 其中数值表示优先级，在很多需要启动的 Servlet 中数值越小优先级越大 Q4: 获取文件的真实路径在做文件处理的情况下，不能把路径写成绝地路径，因为我们最后需要搭建到服务器上，所以把路径写到相对路径上就会省去不必要的麻烦 1String realPath=request.getServletContent.getRealPath(""); Q5: 如何获取访问的设备类型12345678910String from=request.getHeader("User-Agent");if(from.indexOf("Windows")&gt;0)&#123; userFrom ="来自Windows的用户！";&#125;else if(from.indexOf("Macintosh")&gt;0)&#123; userFrom ="来自 Mac 的用户！";&#125;else if(from.indexOf("Android")&gt;0)&#123; userFrom ="来自 Android 的用户！";&#125;else if(from.indexOf("IPhone")&gt;0)&#123; userFrom ="来自 IPhone 的用户！"; &#125; indexOf(str) 获取第一次出现的字符串索引 Q6: 如何固定时间自动跳转页面1response.setHeader("Refresh","2,URL=路径"); Q7: 如何设置一个下载页面 获取文件名称 获取文件路径 创建文件对象，并判断是否存在 设置游览器的的类型为应用下载(application/x-msDownload) 设置游览器的下载方式 12345678910111213141516171819202122232425262728//获取下载名称String filename=request.getParameter("filename");//获取路径名称String downloadPath=this.getServletContext().getRealPath("/")+"WEB-INF\\Logs\\";if(file.exists())&#123; //对游览器进行下载设置 response.setContentType("application/x-msDownload"); //对游览器进行设置，将下载的内容作为附件，并指定文件名 response.setHeader("Content-Disposition", "attachment;filename=\""+filename+"\""); //打开输入输出流 InputStream inputStream=new FileInputStream(file); ServletOutputStream servletOutputStream=response.getOutputStream(); //开始进行文件读写 byte[] b=new byte[1024]; int n; while((n=inputStream.read(b))!=-1)&#123; servletOutputStream.write(b, 0, n); &#125; inputStream.close(); servletOutputStream.close();&#125;else&#123; //下载不存在 PrintWriter out=response.getWriter(); out.print("下载文件不存在...."); out.flush(); out.close();&#125; Q8:如何设置防盗链referer：当访客访问网页时，HTTP来源地址是前一个网页的URL。 1234567891011121314151617181920212223242526272829303132String referer=request.getHeader("referer"); String sitePart="http://"+request.getServerName(); System.out.println(referer+"\n"+sitePart); if(referer!=null&amp;&amp; referer.startsWith(sitePart))&#123; if(file.exists())&#123; //对游览器进行下载设置 response.setContentType("application/x-msDownload"); //对游览器进行设置，将下载的内容作为附件，并指定文件名 response.setHeader("Content-Disposition", "attachment;filename=\""+filename+"\""); //打开输入输出流 InputStream inputStream=new FileInputStream(file); ServletOutputStream servletOutputStream=response.getOutputStream(); //开始进行文件读写 byte[] b=new byte[1024]; int n; while((n=inputStream.read(b))!=-1)&#123; servletOutputStream.write(b, 0, n); &#125; inputStream.close(); servletOutputStream.close(); &#125;else&#123; //下载不存在 PrintWriter out=response.getWriter(); out.print("下载文件不存在...."); out.flush(); out.close(); &#125; &#125;else&#123; //跳转到自己的页面 request.getRequestDispatcher("自己的现在地址").format(request,response); &#125; Q9:如何利用 Cookie 判断首次登陆添加 Cookies 1Cookie cookie=new Cookie("key",value); 12345678910111213141516 //创建 Cookie 对象，获取出现的 Cookie 的值 Cookie lastCookie=null; //创建 Cookie 数组用来获取游览器中的所有 Cookie Cookie[] cookies=request.getCookies(); //遍历所有 cookies for(int i=0;cookies!=null &amp;&amp; i&lt;cookies.length;i++)&#123; if("以前添加键".equals(cookies[i].getName()))&#123; lastCookie=cookies[i].getValue(); break; &#125; &#125;if(lastCookie==null)&#123; response.getWriter.print("欢迎新用户");&#125;else&#123; response.getWriter.print("欢迎老用户");&#125; Q10: Session1234// 获取 SessionHttpSession session=request。getSession();//存放对象session.setAttribute("key",value);]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础命令]]></title>
    <url>%2F2017%2F07%2F03%2FGit%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git init git 初始化 git status 查询状态git log 查看日志 git add 添加文件到暂存区 git commit 提交在暂存区的文件 git diff xxx xxx 比较文件 git branch 查看分支 git branch xxx 创建新的分支 git checkout xx 切换分支 git checkout -b xxx 创建新的分支并切换 git merge master test 合并两个分支（当分支同一级都做了修改，合并的时候会出现冲突，具体参考下面的冲突） git show id 显示父级跟系版本的改动 git branch -d test 删除分支 merge conflict HEAD标记表示我的代码中间部分是已修改的原始版本底部标记的分支是表示该分支的代码 方法：删除原始数据和不需要的留下来的代码，保留需要的代码 git remote 查看远程库和创建远程数据库 git remote add 名称 远程数据库地址 git remote -v 显示详细的信息 git push 名称 分支 推送到github git pull 名称 分支 github上拉取 GitHub 上fork 是获取其他人的库，并不需要先clone本地然后在上传 fork显示其他人获取的数量git fetch 更新远程分支的本地副本而实际的本地版本保持不变 情景：在获取远程库副本到本地，进行操作的时候 git pull 相当等于git fetch 更新然后 git merge 进行合并自己画图梳理了一下。git merge master origin/master 合并本地数据库和远程数据库副本 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD这一层表示本地自己修改的信息| | | | | | | | | 表示原版本这一层表示原版本的信息========这一层表示origin/master 分支的信息&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master 解读完上述信息，合并保留需要的删除其他两个-&gt;git add 文件-&gt;git commit；]]></content>
      <categories>
        <category>Git笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Python(1)]]></title>
    <url>%2F2017%2F07%2F03%2F%E8%8F%9C%E9%B8%9FPython(1)%2F</url>
    <content type="text"><![CDATA[Python 是解释型语言 java 是编译型语言 解释型语言，发布相当等于公布源码. 解释型语言，运行时间长 编译型语言，通过编译器编译成机器可以读的语言，源代码不公开. 编译型语言运行时间短，因为它编译成机器可读的 可以看看廖雪峰 Python介绍 1.练习1（Take a break）打开游览器 import webbrowser 导入webbrowser包 webbrowser.open(“网址”); 运行 添加等待时间 import time time.sleep(10) 添加循环 total_times=3 init_times=0 添加循环 12345678910import webbrowserimport timetotal_times=3 init_times=0print("开始执行..."+time.ctime())while(total_times&gt;init_times): time.sleep(10) webbrowser.open("111.13.100.91"); init_times+=1 注意Python中的 while 循环格式 2.Python 标准库上述的小练习，有两个模块，一个 webbrowser ，一个 time ，每个模块拥有各自的函数，webbrowser 拥有 open 函数，time 模块拥有 sleep 函数和 ctime 函数，而这些东西都在 Python 标准库,可以通过查询标准库，来实现对 Python 的理解]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟Android(1)]]></title>
    <url>%2F2017%2F07%2F01%2F%E8%8F%9C%E9%B8%9FAndroid(1)%2F</url>
    <content type="text"><![CDATA[Android 四大组件 Activity Service Content Provider Broadcast Receiver 这四个组件在 AndroidMainifest 上注册才能被 Android 识别 1. ActivityActivity 是一个交互软件，每一个 Activity 都对应一个 XML 布局，布局内包含其他视图组件，用于显示视图。 Android FrameWork 包含大量的工具包用来帮助构建用户界面。在 res 目录下的 layout 文件夹中包含布局文件，当在主 Activity.java 的 onCreate 方法下使用 SetContentView(R.layout.name); 方法可填充布局，用来显示页面 在打开一个 Activity 实现交互的时候，当点击后退按钮，系统显示堆栈的上一个 Activity 如果堆栈为空则返回启动器 从图中可以看到，应用标签内是 Activity 组件，组件内部是一个 Intent 过滤器标签，其中一个标签提到 Launcher 启动器 布局 XML 视图类型 UI组件 UI 组件 TextView EditView button … Android studio 自带视图编辑器，可直接拖动视图，来实现布局,还可以在约束布局（ConstraintLayout）下通过视图推理功能，进行自适应布局。 容器视图 类名称 说明 LinearLayout 在一行或一列里显示视图 RelativeLayout 相对某个视图放置其他视图 FrameLayout ViewGroup 包含一个子视图 ScrollView 一种 FrameLayout，旨在让用户能够在视图中滚动查看内 ConstraintLayout （约束布局）这是更新的 viewgroup；可以灵活地放置视图 XML 的属性每个视图都具有大量的属性，可以在相关的文档页面查看这些属性。这些属性可以设为不同的值。属性确定了视图的外观细节和互动方式。 R类当你的应用被编译时，系统会生成 R 类。它会创建常量，使你能够动态地确定 res 文件夹的各种内容，包括布局。要了解详情，请参阅关于资源的文档。 IDID 是 Android 用于识别和定位各种控件的 数字标志 Android 工具实际上会帮助我们生成这个数字,我们只需要给它标志名称即可。如： @+id/标识名称 @ 告诉工具不要将括号里的内容视为字符串文本 告诉工具如果 ID 不存在 则创建一个 / 斜线前的 ID 告诉工具我们这是创建 ID]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask 和 AsyncTaskLoader 的使用]]></title>
    <url>%2F2017%2F05%2F07%2FAsyncTask-%E5%92%8C-AsyncTaskLoader-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[上一篇 JSON学习 中介绍了 JSON 对象的结构，如何解析 JSON 数据，但是我们的 JSON 数据是本地已经转换的 String 类型，现在我们处理网上的 JSON 数据,用到了网上的操作，必然要进行网络的连接，讲到网络部分，有必然使用到多线程，所以本篇侧重于介绍多线程部分。 为什么要使用多线程？我们最初的 Android 学习中，默认都是在主线程( MainThread )进行操作的,主线程也叫做 UI 线程，一般的添加控件之类的操作都是主线程运行的，下面的图可以很好的说明，我们一般的绘图操作，点击按钮的操作，网络请求…都是在主线程上运行，但是这些操作的会被放到队列中，顺序执行，每次执行一个事件。 然而我们为什么要使用多线程，我们可能遇到过这样的情况，当我们访问一些 APP 的时候，在做一些网络请求的时候，界面会不动，当你点击界面上的按钮时，会出现是否停止响应的按钮。 为什么会出现这种情况？那是因为我们的网络请求很可能写到主线程上，当你进行网络请求时，应用可以需要一段时间去连接，获取，解析数据，但是同时你又多次按下了按钮，这些操作会出现到你的主线程队列上，但是应用并没有执行你的操作，以至于导致线程阻塞，一段时间后 Android 系统会显示上图的提示。 所以 Android 有个重要原则：不能把网络请求放到主线程 ，也就是不能阻塞 UI 线程，所以这个问题的解决方案就是使用多线程，让各自的操作到各自的线程中进行，网络访问一个线程，数据处理一个线程….这里我们只需要一个后台线程，用来处理网络请求。关于进程和线程可以访问官方链接 AsyncTask 处理多线程Android为了降低开发难度，提供了AsyncTask。AsyncTask就是一个封装过的后台任务类，就是异步任务。它是在 Android 上线程之间进行线程和消息传递的抽象类，并不适用与任何情况，在使用的情况下，考虑当前的使用背景。先来介绍一下 AyncTask 的基本用法。AyncTask 是一个抽象类，要使用这个抽象类需要建立一个子类去继承它，在继承这个类的同时需要规定三个泛型参数，我们为了便于理解，我们把着三个泛型参数放到方法之后讲解，先来讲解 AyncTask 的四个方法： onPreExcute()：UI 线程中调用 该方法在后台任务执行之前调用，一般用于界面的初始化操作，如：显示一个进度条。 doInBackground(Params…)：后台线程中调用 ，该方法用于处理耗时操作，操作一旦完成既可以通过 return 来返回执行结果。用过要在该方法中更新 UI 可以手动调用 publishProgres(Progress…) 方法来完成。 onProgressUpdate(Progress…)：UI 线程中调用 利用该方法可以对 UI 进行相应的更新。该方法的使用必须在 doInBackground() 方法使用 publishProgres() 方法 onPostExcute(Result)：UI 线程中调用 在doInBackground(Params…)中返回的数据会作为参数传递到该方法中。 可以利用后台线程返回的参数进行 UI 操作。 现在我们在讲一讲 AyncTask 中的三个泛型参数，配合上述的方法，你会很快找到对应的规律和使用方法。 Params：在执行 AyncTask 需要传入的参数，用于后台任务使用。对应 doInBackground() Progress：后台任务执行时,如果需要在界面上显示当前的进度。对应onProgressUpdate() Result：当任务完毕的情况下，如果需要对结果进行返回，则使用该返回值类型,对应方法onPostExcute() ## 练习操作＞这个项目是获取网上地震数据并进行显示的应用。效果图如下： 先顶一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public final class QueryUtils &#123; private QueryUtils() &#123; &#125; //该方法进行网络连接，获取数据，解析数据 public static List&lt;Info&gt; fetchEarthquakeDatas(String requestUrl) throws MalformedURLException &#123; /*调用方法处理正确的url*/ URL url = createUrl(requestUrl); /*定义一个json响应的变量*/ String jsonResponse = null; try &#123; /*调用一个方法获取jsonResponse*/ jsonResponse = makeHttpRequest(url); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; /*extractFeatureFromJson一个提取json数据的方法*/ List&lt;Info&gt; listItem = extractFeatureFromJson(jsonResponse); return listItem; &#125; /*创建一个方法，处理传入的Url*/ private static URL createUrl(String stringUrl) &#123; URL url = null; try &#123; url = new URL(stringUrl); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; return url; &#125; /*创建一个方法，连接网络获取jsonResponse*/ private static String makeHttpRequest(URL url) throws IOException &#123; String jsonResponse = ""; if (url == null) return jsonResponse; /*初始化网络连接*/ HttpURLConnection urlConnection = null; /*初始化输入流,因为返回的是一个字符串类型，所以要读取数据*/ InputStream inputStream = null; try &#123; urlConnection = (HttpURLConnection) url.openConnection(); urlConnection.setReadTimeout(10000); urlConnection.setConnectTimeout(15000); urlConnection.setRequestMethod("GET"); urlConnection.connect(); if (urlConnection.getResponseCode() == 200) &#123; Log.i(TAG_LOG, "启动网络服务成功"); Log.v("MainActivity", String.valueOf(urlConnection.getResponseCode())); /*得到他的输入流，也就是读取*/ inputStream = urlConnection.getInputStream(); /*调用一个方法，读取数据*/ jsonResponse = readFromStream(inputStream); &#125; else &#123; Log.i(TAG_LOG, "启动网络服务失败"); Log.v("MainActivity", String.valueOf(urlConnection.getResponseCode())); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (urlConnection != null) urlConnection.disconnect(); if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return jsonResponse; &#125;/*创建一个方法读取输入流的数据*/ private static String readFromStream(InputStream inputStream) &#123; /*字符串的拼接*/ StringBuilder output = new StringBuilder(); if (inputStream != null) &#123; InputStreamReader inputStreamReader = new InputStreamReader(inputStream, Charset.forName("UTF-8")); BufferedReader reader = new BufferedReader(inputStreamReader); try &#123; String line = reader.readLine(); while (line != null) &#123; output.append(line); line = reader.readLine(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /*如果输入流不为空，进行数据读取转换为字符串类型*/ return output.toString(); /*返回字符串*/ &#125;/*创建一个提取json数据的方法*/ private static List&lt;Info&gt; extractFeatureFromJson(String earthquakeJSON) throws MalformedURLException &#123; if (TextUtils.isEmpty(earthquakeJSON)) return null; /*因为返回类型是List&lt;Info&gt;,所以新建一个对象*/ List&lt;Info&gt; listItem = new ArrayList&lt;Info&gt;(); try &#123; JSONObject root = new JSONObject(earthquakeJSON); JSONArray featureArray = root.getJSONArray("features"); for (int i = 0; i &lt; featureArray.length(); i++) &#123; JSONObject feature = featureArray.getJSONObject(i); JSONObject properties = feature.getJSONObject("properties"); Double mag = properties.getDouble("mag"); String place = properties.getString("place"); Long time = properties.getLong("time"); String urlString = properties.getString("url"); URL url = new URL(urlString); listItem.add(new Info(mag, place, time, url)); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; return listItem; &#125;&#125; 上面 QueryUtils 类 一个网络请求的类，我们需要使用 AsyncTask 内部类，调用我们这个网络访问类。 12345678910111213141516171819202122232425/*创建一个AsyncTask的内部类*/ private class EarthAsyncTask extends AsyncTask&lt;String, Void, List&lt;Info&gt;&gt; &#123; @Override protected List&lt;Info&gt; doInBackground(String... urls) &#123; Log.i(TAG_LOG, "doInBackground()"); if (urls.length &lt; 1 || urls[0] == null) return null; List&lt;Info&gt; result = null; try &#123; result = QueryUtils.fetchEarthquakeDatas(urls[0]); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(List&lt;Info&gt; result) &#123; /* 清除之前地震数据的适配器*/ adapter.clear(); /* add与addALL的区别在于add方法即便加入一个list也只是保存其中一条，addAll 保存全部*/ if (result != null &amp;&amp; !result.isEmpty()) adapter.addAll(result); &#125; &#125; 为什么要使用 AsyncTaskLoader ？当我们旋转屏幕的时候，会改变设备配置。设备配置是用来描述设备当前状态的一系列特征。当我们旋转屏幕时，我们重新创建了一个新的活动，相当于创建了两个 AsyncTask ，可能这个问题看起来没什么问题，我们都知道我们手机有内存限制，当我们频繁的旋转设备，就会造成大量的 AsyncTask 的资源占用，还有就是每次设备更改时，都会访问一次 Internet ，这不仅仅是造成不必要的流量丢失，还造成数据利用率极低。需要注意的，当 AsyncTask 数量增加时，Android 系统并不会自动释放不用的资源，因为 AsyncTask 是原始活动的的内部类，所以只有 AsyncTask 结束才会统一释放资源，如何处理上述所说的问题，这里就用到 Loader 关于 Loader 介绍，我们可以查看官方文档 在上述的项目中，我们如何加入 AsyncTaskLoader 来处理设备配置的问题？首先，我们先创建一个子类继承 AsyncTaskLoader 并实现一个最重要的方法loadInBackground()，该方法和doInBackground()原理相同 其次，创建完这个 AsyncTaskLoader 的子类，我们需要用到一个 LoaderManager 顾名思义，它是管理我们 Loader 的类，要想让我们的类使用 Loader 就必须使用 LoaderManager.LoaderCallbacks 接口，这样 LoaderManager 就可以通知我们创建 加载器 Loader 。并且实现三个方法 onCreateLoader（）当loadermanager调用initLoader()时, 首先检查指定的id是否存在，如果不存在才会触发该方法，通过该方法才能创建一个loader onLoadFinished（）当一个加载器 完成了它的装载过程后被调用 onLoaderReset（）当一个加载器 被重置而什其数据无效时被调用 不多说直接贴代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class EarthquakeActivity extends AppCompatActivity implements android.app.LoaderManager.LoaderCallbacks&lt;List&lt;Info&gt;&gt; &#123; private TextView emptyTextView; private InfoAdapter adapter; private static final String REQUEST_URL = "https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&amp;orderby=time&amp;minmag=5&amp;limit=10"; @Override protected void onCreate(Bundle savedInstanceState) &#123; Log.i(TAG_LOG, "onCreate()"); super.onCreate(savedInstanceState); setContentView(R.layout.earthquake_activity); emptyTextView = (TextView) findViewById(R.id.empty_tv); /*获取listView*/ ListView earthquakeListView = (ListView) findViewById(R.id.list); /*将空视图和list进行挂接，实现当加载不出来时，显示提示文本*/ earthquakeListView.setEmptyView(emptyTextView); adapter = new InfoAdapter(this, new ArrayList&lt;Info&gt;());/*绑定适配器*/ earthquakeListView.setAdapter(adapter);/*判断是否联网*/ ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetWork = cm.getActiveNetworkInfo(); if (activeNetWork != null &amp;&amp; activeNetWork.isConnectedOrConnecting()) &#123; /*初始化loader*/ getLoaderManager().initLoader(0, null, this); /*添加项目点击监听器*/ Log.i(TAG_LOG, "initLoader()"); &#125; else &#123; View loading_progress_Bar = findViewById(R.id.loading_progressbar); loading_progress_Bar.setVisibility(View.GONE); emptyTextView.setText("no Internet"); &#125; earthquakeListView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; /*查找单机的当前地震*/ Info currentInfo = (Info) adapter.getItem(i); /*获取uri对象???*/ Uri infoUri = Uri.parse(currentInfo.getURL().toString()); /*创建一个新的Intent*/ Intent intent = new Intent(Intent.ACTION_VIEW, infoUri); startActivity(intent); &#125; &#125;); /* 实例化AsyncTask 并执行*/ EarthAsyncTask task = new EarthAsyncTask(); task.execute(REQUEST_URL); &#125; @Override public android.content.Loader&lt;List&lt;Info&gt;&gt; onCreateLoader(int i, Bundle bundle) &#123; Log.i(TAG_LOG, "onCreateLoader()"); return new EarthquakeLoader(this, REQUEST_URL); &#125; @Override public void onLoadFinished(android.content.Loader&lt;List&lt;Info&gt;&gt; loader, List&lt;Info&gt; infos) &#123; Log.i(TAG_LOG, "onLoadFinished()"); adapter.clear(); /* 如果存在 &#123;@link Earthquake&#125; 的有效列表，则将其添加到适配器的 数据集。这将触发 ListView 执行更新。 add与addALL的区别在于add方法即便加入一个list也只是保存其中一条，addAll 保存全部*/ if (infos != null &amp;&amp; !infos.isEmpty()) adapter.addAll(infos); View loading_progress_Bar = findViewById(R.id.loading_progressbar); loading_progress_Bar.setVisibility(View.GONE); emptyTextView.setText("no Text"); &#125; @Override public void onLoaderReset(android.content.Loader&lt;List&lt;Info&gt;&gt; loader) &#123; Log.i(TAG_LOG, "onLoaderReset()"); adapter.clear(); &#125; /*创建一个AsyncTask的内部类*/ private class EarthAsyncTask extends AsyncTask&lt;String, Void, List&lt;Info&gt;&gt; &#123; @Override protected List&lt;Info&gt; doInBackground(String... urls) &#123; Log.i(TAG_LOG, "doInBackground()"); if (urls.length &lt; 1 || urls[0] == null) return null; List&lt;Info&gt; result = null; try &#123; Log.i(TAG_LOG, "调用doInBackground+fetchEarthquakeDatas"); result = QueryUtils.fetchEarthquakeDatas(urls[0]); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; return result; &#125; @Override protected void onPostExecute(List&lt;Info&gt; result) &#123; /* 清除之前地震数据的适配器*/ Log.i(TAG_LOG, "onPostExecute()"); adapter.clear(); /* 如果存在 &#123;@link Earthquake&#125; 的有效列表，则将其添加到适配器的 数据集。这将触发 ListView 执行更新。 add与addALL的区别在于add方法即便加入一个list也只是保存其中一条，addAll 保存全部*/ if (result != null &amp;&amp; !result.isEmpty()) adapter.addAll(result); &#125; &#125;&#125; 总结：花了一下午时间去整理，后面的内容可能不是很详细，但是这种概念的东西，大家都可以的百度的到，还有有些代码都做了相关的注释，一些 UI 上的东西，跟本篇讲的可能关系不大，主要是处理应用的交互性，比如：判断是否联网，当没有联网的情况下提示文本，还有在进行网络访问的时候，添加一个进度条提示，应用正在处理。希望能给大家带来帮助！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON学习]]></title>
    <url>%2F2017%2F05%2F01%2FJSON%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[&gt;有关的知识点可能过于简单，但是又不得不去写，想要养成写博客的习惯，不仅仅是对自己知识的总结，也是对耐力的磨练，虽然目前学的东西很浅，但是随着以后的深入不断去补充相关的知识，使自己的文章更加精炼。 最近在做一个网络请求的demo，用到了JSON，做一次总结。 一、JSON基础知识点？JSON是一种取代XML的数据结构,和xml相比,它更小巧但描述能力却不差,由于它的小巧所以网络传输数据将减少更多流量从而加快速度。 JSON就是一串字符串 只不过元素会使用特定的符号标注。 {} 双括号表示对象 [] 中括号表示数组 “ “ 双引号内是属性或值 : 冒号表示后者是前者的值(这个值可以是字符串、数字、也可以是另一个数组或对象) 二、Json解析 第一个 “size” 键的值为 9.5，由此可以判断出 该值属于数值类型，因为值周围没有引号。第二个 “wide” 键的值为 true，不带引号。这 表示该值属于布尔值。如果数字周围有引号，则表示其为字符串。也就是我们在第三个键值对中找到的字符串。第三个 “country-of-origin”键的值为 “usa”。第四个键是 “style”，其值表示为对象，因为两侧有大括号。 在 style 对象内部，我们可以找到两个嵌套键/值对：一个为 catergories，一个为color。其实 catergories 的值是一个数组，“boot” 和 “winklepicker”被包含在中括号内组成一个数组。 按照这种方式，通过使用对象和数组，可以嵌套几组值， 随后便可在这些容器中放入不同的数据类型。 如果我们请求的数据很多比如这个URL;我们就需要JSON整理格式化，推荐一个格式网站 三、如何获取JSON中的数据通过这个demo，先说明一下这个demo是在给定的 JSON ,下面的String中就是我们需要解析的JSON通过上面给的JSON格式工具，我们做一些操作取出 “features”对象中的一些值。便于理解贴一张图吧 下面的代码只是贴出必要的数据，方便需要运行看效果的同学直接拿来用 demo：123456789101112131415161718192021222324252627private static final String SAMPLE_JSON_RESPONSE = "&#123;\"type\":\"FeatureCollection\",\"metadata\":&#123;\"generated\":1462295443000,\"url\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&amp;starttime=2016-01-01&amp;endtime=2016-01-31&amp;minmag=6&amp;limit=10\",\"title\":\"USGS Earthquakes\",\"status\":200,\"api\":\"1.5.2\",\"limit\":10,\"offset\":1,\"count\":10&#125;,\"features\":[&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":7.2,\"place\":\"88km N of Yelizovo, Russia\",\"time\":1454124312220,\"updated\":1460674294040,\"tz\":720,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us20004vvx\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us20004vvx&amp;format=geojson\",\"felt\":2,\"cdi\":3.4,\"mmi\":5.82,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":798,\"net\":\"us\",\"code\":\"20004vvx\",\"ids\":\",at00o1qxho,pt16030050,us20004vvx,gcmt20160130032510,\",\"sources\":\",at,pt,us,gcmt,\",\"types\":\",cap,dyfi,finite-fault,general-link,general-text,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":0.958,\"rms\":1.19,\"gap\":17,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 7.2 - 88km N of Yelizovo, Russia\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[158.5463,53.9776,177]&#125;,\"id\":\"us20004vvx\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.19,\"place\":\"84km SSE of Taron, Papua New Guinea\",\"time\":1453777820750,\"updated\":1460156775040,\"tz\":600,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us20004uks\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us20004uks&amp;format=geojson\",\"felt\":null,\"cdi\":null,\"mmi\":4.1,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":572,\"net\":\"us\",\"code\":\"20004uks\",\"ids\":\",us20004uks,gcmt20160126031023,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,geoserve,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":1.537,\"rms\":0.74,\"gap\":25,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.1 - 94km SSE of Taron, Papua New Guinea\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[153.2454,-5.2952,26]&#125;,\"id\":\"us20004uks\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.3,\"place\":\"50km NNE of Al Hoceima, Morocco\",\"time\":1453695722730,\"updated\":1460156773040,\"tz\":0,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004gy9\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004gy9&amp;format=geojson\",\"felt\":117,\"cdi\":7.2,\"mmi\":5.28,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":695,\"net\":\"us\",\"code\":\"10004gy9\",\"ids\":\",us10004gy9,gcmt20160125042203,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":2.201,\"rms\":0.92,\"gap\":20,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.3 - 50km NNE of Al Hoceima, Morocco\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-3.6818,35.6493,12]&#125;,\"id\":\"us10004gy9\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":7.1,\"place\":\"86km E of Old Iliamna, Alaska\",\"time\":1453631430230,\"updated\":1460156770040,\"tz\":-540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004gqp\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004gqp&amp;format=geojson\",\"felt\":1816,\"cdi\":7.2,\"mmi\":6.6,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":1496,\"net\":\"us\",\"code\":\"10004gqp\",\"ids\":\",at00o1gd6r,us10004gqp,ak12496371,gcmt20160124103030,\",\"sources\":\",at,us,ak,gcmt,\",\"types\":\",cap,dyfi,finite-fault,general-link,general-text,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,trump-origin,\",\"nst\":null,\"dmin\":0.72,\"rms\":2.11,\"gap\":19,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 7.1 - 86km E of Old Iliamna, Alaska\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-153.4051,59.6363,129]&#125;,\"id\":\"us10004gqp\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.6,\"place\":\"215km SW of Tomatlan, Mexico\",\"time\":1453399617650,\"updated\":1459963829040,\"tz\":-420,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004g4l\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004g4l&amp;format=geojson\",\"felt\":11,\"cdi\":2.7,\"mmi\":3.92,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":673,\"net\":\"us\",\"code\":\"10004g4l\",\"ids\":\",at00o1bebo,pt16021050,us10004g4l,gcmt20160121180659,\",\"sources\":\",at,pt,us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":2.413,\"rms\":0.98,\"gap\":74,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.6 - 215km SW of Tomatlan, Mexico\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-106.9337,18.8239,10]&#125;,\"id\":\"us10004g4l\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.74,\"place\":\"52km SE of Shizunai, Japan\",\"time\":1452741933640,\"updated\":1459304879040,\"tz\":540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004ebx\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004ebx&amp;format=geojson\",\"felt\":51,\"cdi\":5.8,\"mmi\":6.45,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":720,\"net\":\"us\",\"code\":\"10004ebx\",\"ids\":\",us10004ebx,pt16014050,at00o0xauk,gcmt20160114032534,\",\"sources\":\",us,pt,at,gcmt,\",\"types\":\",associate,cap,dyfi,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,\",\"nst\":null,\"dmin\":0.281,\"rms\":0.98,\"gap\":22,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.7 - 52km SE of Shizunai, Japan\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[142.781,41.9723,46]&#125;,\"id\":\"us10004ebx\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.1,\"place\":\"12km WNW of Charagua, Bolivia\",\"time\":1452741928270,\"updated\":1459304879040,\"tz\":-240,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004ebw\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004ebw&amp;format=geojson\",\"felt\":3,\"cdi\":2.2,\"mmi\":2.21,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":573,\"net\":\"us\",\"code\":\"10004ebw\",\"ids\":\",us10004ebw,gcmt20160114032528,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":5.492,\"rms\":1.04,\"gap\":16,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.1 - 12km WNW of Charagua, Bolivia\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-63.3288,-19.7597,582.56]&#125;,\"id\":\"us10004ebw\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.23,\"place\":\"74km NW of Rumoi, Japan\",\"time\":1452532083920,\"updated\":1459304875040,\"tz\":540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004djn\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004djn&amp;format=geojson\",\"felt\":8,\"cdi\":3.4,\"mmi\":3.74,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":594,\"net\":\"us\",\"code\":\"10004djn\",\"ids\":\",us10004djn,gcmt20160111170803,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":1.139,\"rms\":0.96,\"gap\":33,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.2 - 74km NW of Rumoi, Japan\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[141.0867,44.4761,238.81]&#125;,\"id\":\"us10004djn\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.5,\"place\":\"227km SE of Sarangani, Philippines\",\"time\":1452530285900,\"updated\":1459304874040,\"tz\":480,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004dj5\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004dj5&amp;format=geojson\",\"felt\":1,\"cdi\":2.7,\"mmi\":7.5,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":650,\"net\":\"us\",\"code\":\"10004dj5\",\"ids\":\",at00o0srjp,pt16011050,us10004dj5,gcmt20160111163807,\",\"sources\":\",at,pt,us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":3.144,\"rms\":0.72,\"gap\":22,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.5 - 227km SE of Sarangani, Philippines\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[126.8621,3.8965,13]&#125;,\"id\":\"us10004dj5\"&#125;,\n" + "&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.55,\"place\":\"Pacific-Antarctic Ridge\",\"time\":1451986454620,\"updated\":1459202978040,\"tz\":-540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004bgk\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004bgk&amp;format=geojson\",\"felt\":0,\"cdi\":1,\"mmi\":0,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":554,\"net\":\"us\",\"code\":\"10004bgk\",\"ids\":\",us10004bgk,gcmt20160105093415,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,\",\"nst\":null,\"dmin\":30.75,\"rms\":0.67,\"gap\":71,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.0 - Pacific-Antarctic Ridge\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-136.2603,-54.2906,10]&#125;,\"id\":\"us10004bgk\"&#125;],\"bbox\":[-153.4051,-54.2906,10,158.5463,59.6363,582.56]&#125;"; //创建一个JSON对象，并传入JSON格式的数据 JSONObject root = new JSONObject(SAMPLE_JSON_RESPONSE); //获取数组对象“features” 从图中可以看出“features”后面是中括号 JSONArray featureArray=root.getJSONArray("features"); //这个循环只是获取每个数组中相同的对象 for(int i=0;i&lt;featureArray.length();i++)&#123; //获取第 i 个数组中的数据 JSONObject earthquake= featureArray.getJSONObject(i); //获取该对象中的“properties”JSON对象 JSONObject properties=earthquake.getJSONObject("properties"); //获取键为“mag”的值 Double mag= properties.getDouble("mag"); //获取键为“place”的值 String place= properties.getString("place"); //获取键为“time”的值 Long time= Long.valueOf(properties.getString("time")); 上面获取出来的值可有用 log 或者 Toast 显示出来 四、JSON 数据中时间格式的转换可以看出来 JSON 中 “time” 键值为毫秒数，我们便于观看需要转换为我们熟悉的格式,所以我们用到了 SimpleDateFormat类，基本格式是： 12345//引号中的格式参照下图SimpleDateFormat dateFormat=new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);Date date=new Date(time); //time为获取到的毫秒数String showDate=dateFormat.format(date);//用 log 或者 Toast 显示出来 如果要处理数值的格式我们用DecimalFormat类，用法很简单，如：123//“0”表示站位，下面的意思表示只保留一位小数//当然我们可以使用Math类也能达到保留一位小数 DecimalFormat decimalFormat=new DecimalFormat("0.0"); 更详细的可以查看 DecimalFormat 格式方法)，里面也有格式图，方便理解； 五、字符串的操控你也可以参阅文档中的CharSequence。CharSequence 是一组字符，字符串是一种更具体的 CharSequence （String 类是 CharSequence 类的 扩展类）。如果某个方法要求使用 CharSequence 作为输入，你可以 传递一个字符串。 以下是一些可以在 String 对象上调用的其他方法：length()) - 返回字符串中的 字符数contains(CharSequence cs)) - 根据 原始字符串中是否包含输入 CharSequence （或输入 String）返回 true 或 falseindexOf(String string)) - 返回输入 String 首次在原始 String 中出现的位置的索引，如果 原始 String 中不存在输入 String，则返回 -1split(String string)) - 根据输入 String 中 指定的位置对原始 String 进行拆分， 并返回包含拆分后 String 部分的数组。substring(int start, int end)) - 返回 一个新的 String，该 String 为从开始索引到结束索引 之间的内容（包括开始索引但不包括结束索引）。 demodemo 中，我们需要拆分“place” 中的数据，其中以“of”为划分 123456789101112131415TextView mLocation= (TextView) listItem.findViewById(R.id.location_tv);//说明一下mData.getLocation()是adpater中获取的具体的“place”数据 String show=null; //获取出现“of”的索引值 int indexOf=mData.getLocation().indexOf("of"); //如果数据包含“of” if(mData.getLocation().contains("of"))&#123; //从0索引开始到of之后得到索引结束取出之间的值 show=mData.getLocation().substring(0,indexOf+2); &#125;else&#123; show="near the"; &#125; //设置显示的文本 mLocation.setText(show); 更多的操作需要具体要求修改，答案不唯一，有兴趣可以把其他的几个方法的尝试一下]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总有你要的编程书单(GitHub)]]></title>
    <url>%2F2017%2F04%2F18%2F%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95(GitHub)%2F</url>
    <content type="text"><![CDATA[目录IDE IntelliJ IDEA 简体中文专题教程 MySQL 21分钟MySQL入门教程 MySQL索引背后的数据结构及算法原理 NoSQL Disque 使用教程 Neo4j .rb 中文資源 Redis 命令参考 Redis 设计与实现 The Little MongoDB Book The Little Redis Book 带有详细注释的 Redis 2.6 代码 带有详细注释的 Redis 3.0 代码 PostgreSQL PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 Web 3 Web Designs in 3 Weeks Chrome 开发者工具中文手册 Chrome扩展开发文档 Growth: 全栈增长工程师指南 Grunt中文文档 Gulp 入门指南 gulp中文文档 HTTP 接口设计指北 HTTP/2.0 中文翻译 http2讲解 JSON风格指南 Wireshark用户手册 一站式学习Wireshark 关于浏览器和网络的 20 项须知 前端代码规范 及 最佳实践 前端开发体系建设日记 前端资源分享（一） 前端资源分享（二） 正则表达式30分钟入门教程 浏览器开发工具的秘密 移动Web前端知识库 移动前端开发收藏夹 WEB服务器 Apache 中文手册 Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通 (PDF版本，运维生存时间出品) 其它 OpenWrt智能、自动、透明翻墙路由器教程 SAN 管理入门系列 Sketch 中文手册 深入理解并行编程 函数式概念 傻瓜函数编程 分布式系统 走向分布式 (PDF) 在线教育 51CTO学院 Codecademy CodeSchool Coursera Learn X in Y minutes (数十种语言快速入门教程) shiyanlou TeamTreeHouse Udacity xuetangX 慕课网 (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源) 极客学院 汇智网 计蒜客 大数据 Spark 编程指南简体中文版 大型集群上的快速和通用数据处理架构 大数据/数据挖掘/推荐系统/机器学习相关资源 数据挖掘中经典的算法实现和详细的注释 面向程序员的数据挖掘指南 操作系统 Debian 参考手册 Docker —— 从入门到实践 Docker中文指南 Docker入门实战 FreeBSD 使用手册 FreeRADIUS新手入门 Linux Documentation (中文版) Linux Guide for Complete Beginners Linux 构建指南 Linux 系统高级编程 Linux工具快速教程 Mac 开发配置手册 Operating Systems: Three Easy Pieces The Linux Command Line (中英文版) Ubuntu 参考手册 uCore Lab: Operating System Course in Tsinghua University UNIX TOOLBOX 命令行的艺术 嵌入式 Linux 知识库 (eLinux.org 中文版) 开源世界旅行手册 理解Linux进程 鸟哥的 Linux 私房菜 基础学习篇 鸟哥的 Linux 私房菜 服务器架设篇 数据库 Redis 设计与实现 The Little MongoDB Book 中文版 智能系统 一步步搭建物联网系统 正则表达式 正则表达式30分钟入门教程 版本控制 Git - 简易指南 Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） Git Community Book 中文版 git-flow 备忘清单 Git magic Git Magic Git 参考手册 Github帮助文档 GitHub秘籍 Git教程 （本文由 @廖雪峰 创作，如果觉得本教程对您有帮助，可以去 iTunes 购买） Got GitHub GotGitHub HgInit (中文版) Mercurial 使用教程 Pro Git Pro Git 中文版 (整理在gitbook上) svn 手册 学习 Git 分支 (点击右下角按钮可切换至简体及正体中文) 沉浸式学 Git 猴子都能懂的GIT入门 程序员杂谈 程序员的自我修养 管理和监控 ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） ELKstack 中文指南 Logstash 最佳实践 Mastering Elasticsearch(中文版) Puppet 2.7 Cookbook 中文版 编程艺术 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 每个程序员都应该了解的内存知识(译)【第一部分】 程序员编程艺术 编程入门指南 编译原理 《计算机程序的结构和解释》公开课 翻译项目 编辑器 exvim–vim 改良成IDE项目 Vim中文文档 所需即所获：像 IDE 一样使用 vim 笨方法学Vimscript 中译本 计算机图形学 OpenGL 教程 设计模式 史上最全设计模式导学目录 图说设计模式 软件开发方法 傻瓜函数编程 (《Functional Programming For The Rest of Us》中文版) 硝烟中的 Scrum 和 XP 项目相关 GNU make 指南 Gradle 2 用户指南 Gradle 中文使用文档 Joel谈软件) selenium 中文文档 开源软件架构 持续集成（第二版） (译言网) 約耳談軟體(Joel on Software) 编码规范 让开发自动化系列专栏 追求代码质量 语言相关Android Android Design(中文版) Android Note(开发过程中积累的知识点) Android6.0新特性详解 Android学习之路 Android开发技术前线(android-tech-frontier) Google Android官方培训课程中文版 Google Material Design 正體中文版 (译本一 译本二) Material Design 中文版 Point-of-Android Android 一些重要知识点解析整理 AWK awk中文指南 awk程序设计语言 C C 语言常见问题集 C/C++ 学习教程 Linux C 编程一站式学习 新概念 C 语言教程 C Sharp 精通C#(第6版) C++ 100个gcc小技巧 100个gdb小技巧 C 语言编程透视 C/C++ Primer - @andycai C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ Template 进阶指南 C++ 基础教程 C++ 并发编程(基于C++11) C++ 并发编程指南 CGDB中文手册 Cmake 实践 (PDF) GNU make 指南 Google C++ 风格指南 QT 教程 ZMQ 指南 像计算机科学家一样思考（C++版) (《How To Think Like a Computer Scientist: C++ Version》中文版) 简单易懂的C魔法 跟我一起写Makefile(PDF) (PDF) CoffeeScript CoffeeScript 中文 CoffeeScript 编程风格指南 Dart Dart 语言导览 Elasticsearch Elasticsearch 权威指南 （《Elasticsearch the definitive guide》中文版） ELKstack 中文指南 Mastering Elasticsearch(中文版) Elixir Elixir Getting Started 中文翻译 Elixir 编程语言教程 (Elixir School) Elixir元编程与DSL 中文翻译 Phoenix 框架中文文档 Erlang Erlang 并发编程 (《Concurrent Programming in Erlang (Part I)》中文版) Fortran Fortran77和90/95编程入门 Golang Go Web 编程 Go 入门指南 (《The Way to Go》中文版) Go 官方文档翻译 Go 指南 (《A Tour of Go》中文版) Go 简易教程 (《 The Little Go Book 》中文版) Go 编程基础 Go 语言标准库 Go命令教程 Go实战开发 Go语言博客实践 Java程序员的Golang入门指南 Network programming with Go 中文翻译版本 Revel 框架手册 学习Go语言 神奇的 Go 语言 Groovy 实战 Groovy 系列 Haskell Haskell 趣学指南 Real World Haskell 中文版 HTML / CSS CSS3 Tutorial 《CSS3 教程》 CSS参考手册 Emmet 文档 HTML5 教程 HTML和CSS编码规范 Sass Guidelines 中文 前端代码规范 (腾讯 AlloyTeam 团队) 学习CSS布局 通用 CSS 笔记、建议与指导 iOS Apple Watch开发初探 Google Objective-C Style Guide 中文版 iOS7人机界面指南 iOS开发60分钟入门 iPhone 6 屏幕揭秘 网易斯坦福大学公开课：iOS 7应用开发字幕文件 Java Activiti 5.x 用户指南 Apache MINA 2 用户指南 Apache Shiro 用户指南 Google Java编程风格指南 H2 Database 教程 Java Servlet 3.1 规范 Java 编码规范 Jersey 2.x 用户指南 JSSE 参考指南 MyBatis中文文档 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Spring Boot参考指南 (翻译中) Spring Framework 4.x参考文档 用jersey构建REST服务 Javascript Airbnb JavaScript 规范 AngularJS AngularJS中译本 AngularJS入门教程 AngularJS最佳实践和风格指南 在Windows环境下用Yeoman构建AngularJS项目 构建自己的AngularJS backbone.js backbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) Chrome扩展及应用开发 CoffeeScript CoffeeScript 编码风格指南 D3.js D3.js 入门系列 (还有进阶、高级等系列) 官方API文档 张天旭的D3教程 楚狂人的D3教程 ECMAScript 6 入门 (作者：阮一峰) ExtJS Ext4.1.0 中文文档 Google JavaScript 代码风格指南 Google JSON 风格指南 impress.js impress.js的中文教程 JavaScript Promise迷你书 Javascript 原理 JavaScript 标准参考教程（alpha） 《JavaScript 模式》 “JavaScript patterns”中译本 javascript 的 12 个怪癖 JavaScript 秘密花园 JavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者) Javascript编程指南 (源码) jQuery How to write jQuery plugin 简单易懂的JQuery魔法 Meteor Discover Meteor Node.js express.js 中文文档 Express框架 koa 中文文档 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 Node.js Fullstack《從零到一的進撃》 Node.js 包教不包会 Nodejs Wiki Book (繁体中文) nodejs中文文档 Node入门 七天学会NodeJS 使用 Express + MongoDB 搭建多人博客 JavaScript全栈工程师培训材料 React.js Learn React &amp; Webpack by building the Hacker News front page React Native 中文文档(含最新Android内容) React webpack-cookbook React 入门教程 React.js 中文文档 underscore.js Underscore.js中文文档 You-Dont-Know-JS (深入JavaScript语言核心机制的系列图书) Zepto.js Zepto.js 中文文档 命名函数表达式探秘 (注:原文由为之漫笔 翻译，原始地址无法打开，所以此处地址为我博客上的备份) 学用 JavaScript 设计模式 (开源中国) 深入理解JavaScript系列 LaTeX LaTeX 笔记 一份不太简短的 LaTeX2ε 介绍 大家來學 LaTeX (PDF) LISP ANSI Common Lisp 中文翻译版 Common Lisp 高级编程技术 (《On Lisp》中文版) Lua Lua 5.3 参考手册 Markdown Markdown 快速入门 Markdown 简明教程 Markdown 语法说明 献给写作者的 Markdown 新手指南 Node.js Node 入门 The NodeJS 中文文档 （社区翻译） 七天学会NodeJS 阿里出品，很好的入门资料 Perl Master Perl Today 《Modern Perl》中文版 Perl 5 教程 Perl 教程 PHP PHP 之道 PHP5中文手册 PHP扩展开发及内核应用 Symfony2 实例教程 深入理解 PHP 内核 Python Django book 2.0 Python 3 文档(简体中文) 3.2.2 documentation Python 中文学习大本营 深入 Python 3 笨办法学 Python R 153分钟学会 R (PDF) R 导论 (《An Introduction to R》中文版) (PDF) 用 R 构建 Shiny 应用程序 (《Building ‘Shiny’ Applications with R》中文版) 统计学与 R 读书笔记 (PDF) reStructuredText reStructuredText 入门 reStructuredText 简明教程 Ruby Rails 风格指南 Ruby on Rails Tutorial 原书第 2 版 Ruby on Rails 实战圣经 Ruby 风格指南 笨方法学 Ruby Rust Rust 官方教程 Rust 语言学习笔记 RustPrimer 通过例子学习 Rust Scala Effective Scala Scala 初学者指南 (The Neophyte’s Guide to Scala) Scala 课堂 (Twitter的Scala中文教程) Scheme Scheme 入门教程 (《Yet Another Scheme Tutorial》中文版) Shell Shell 编程基础 Shell 脚本编程30分钟入门 The Linux Command Line 中文版 Swift 《The Swift Programming Language》中文版 Vim Vim Manual(中文版) 大家來學 VIM Visual Prolog Visual Prolog 7初学指南 Visual Prolog 7边练边学 本文转自 free-programming-books-master]]></content>
      <categories>
        <category>资源归档</category>
      </categories>
      <tags>
        <tag>资源归档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 Fragment]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%B5%85%E8%B0%88-Fragment%2F</url>
    <content type="text"><![CDATA[fragment 用户界面管理上用到的地方非常多，fragment 相比 activity ，不同的activity之间有很强的过多效果，fragment 更加轻量级的转变，更加灵活，Fragment 也称作UI Fragment。一下我们通过几个问题来介绍 Fragment。 为什么要使用Fragment，能实现什么？在实际的开发中，虽然 Activity 可以帮助我们实现不同的页面承载，但是要遵循 Activity 的生命周期，当我们要实现更友好的用户界面，Activity 已经不能满足我们。Fragment 提供更灵活的 UI设计需求，fragment 是一种控制器对象，activity可以委派它完成一些任务，通常是管理用户界面，受管理的用户界面通常是一整屏或是屏幕的一部分。在一些需要在一个activity 进行不同操作的情况下，fragment 就能提供很好的交互。 Fragment 与 Activity 的什么关系？Fragment 必须是依存与Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期，通过两者的生命周期图来理解，fragmentonAttach()当Fragment与Activity发生关联时调用。onCreateView()创建该Fragment的视图onActivityCreated(Bundle)当Activity的onCreate方法返回时调用onDestoryView()与onCreateView想对应，当该Fragment的视图被移除时调用onDetach()与onAttach相对应，当Fragment与Activity关联被取消时调用 注意：没说的代表跟 activity 相同 如何使用 Fragment？两种方式 布局的方式 代码的方式 (一) 布局的方式 当系统构建 Activity 布局时，会实例化在布局指定的 fragment ，并调用 onCreateView（）方法。系统会直接插入onCreateView（）中返回的 view 来代替 标签 注：每个fragment都需要一个唯一的标识符，重启 Activity 时，系统可以使用该标识符来恢复fragment（您也可以使用该标识符来捕获fragment以执行某些事务，如将其移除）。 可以通过三种方式为片段提供 ID：为 android:id 属性提供唯一 ID。为 android:tag 属性提供唯一字符串。如果您未给以上两个属性提供值，系统会使用容器视图的 ID。对于 Fragment 的理解———————————————————————-官方文档 (一) 代码的方式在Activity 运行的过程中，再添加Fragment到指定的ViewGroup需要通过 FragmentManager 来管理（添加，删除，替换）事务的管理1234567getSupportFragmentManager().beginTrasaction().add(R.id.fragment,fragment)// 参数1. 指定位置添加，通过资源ID定位// 参数2.需要添加的 fragment如果需要 addToBackStack() 将此事务添加到事务返回栈，允许用户按返回键返回上一个 Fragment 状态.commit一旦通过FragmentTransaction做出修改必须 commit() 进行提交 才能生效 提示：对于每个片段事务，您都可以通过在提交前调用 setTransition()) 来应用过渡动画。 添加没有 UI 的片段上例展示了如何向您的 Activity 添加片段以提供 UI。不过，您还可以使用片段为 Activity 提供后台行为，而不显示额外 UI。要想添加没有 UI 的片段，请使用 add(Fragment, String)) 从 Activity 添加片段（为片段提供一个唯一的字符串“标记”，而不是视图 ID）。 这会添加片段，但由于它并不与 Activity 布局中的视图关联，因此不会收到对 onCreateView()) 的调用。因此，您不需要实现该方法。并非只能为非 UI 片段提供字符串标记 — 您也可以为具有 UI 的片段提供字符串标记 — 但如果片段没有 UI，则字符串标记将是标识它的唯一方式。如果您想稍后从 Activity 中获取片段，则需要使用 findFragmentByTag())。 1234567onCreateView inflater,inflate(R.layout.id,container,false);参数 1.需要填充的布局，参数 2.填充的布局显示到父ViewGroup参数 3.指示是否应该在扩展期间将扩展布局附加至（第二个参数）的布尔值。在本例中，其值为 false，因为系统已经将扩展布局插入 container传递 true 值会在最终布局中创建一个多余的视图组。 Fragment 事务该如何理解？ 理解 ：每一个继承 Fragment 的类都有与之对应的 XML 视图，这是跟 Activity 相同的地方 ，这个 XML 视图 可以看成一个动态的视图，这个视图跟主视图绑定，当我们进行交互性操作的时候，FragmentManager 管理 fragment 事务 进行添加，移除，替换 ，这个过程中遵循的是 fragment 的生命周期，只要 Activity 处于运行状态，就可以使用一个或者多个fragment 进行 事务的处理。例如：清单列表和详细内容是两个不同的 fragment 构成，先加载的是清单列表 fragment 当用户选中其中一个，触发FragmentManager 进行 替换操作，替换成详细内容fragment。 结束语fragment 的用法还有许多，包括与ViewPager 和 FragmentPagerAdapter 的使用这里我们先介绍基础性的知识，也没有给大家介绍具体的代码，因为我认为对于这个东西，先要去理解它，当你再去看代码就能很好的使用了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>UI</tag>
        <tag>用户界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-音频播放（一）]]></title>
    <url>%2F2017%2F03%2F30%2FAndroid-%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近学习了关于Android 的音频播放，以及系统中各应用之间对于音频播放的资源竞争处理。如何处理应用处于播放的状态下，其他的音频如何影响当前的状态。例如：当手机播放一个音乐，同时来了一个电话，这时音乐停止，当通话结束时再继续播放。 如何创建一个播放音频 注意：Media Player 只介绍最基础的，其他的方法后期遇到在进行详解。 Media Player 类：媒体播放器类可用于控制播放的音频/视频文件和流。 创建一个音频的语法：1MediaPlayer mMediaPlayer = MediaPlayer.create(Context context, int resid); 第一个参数：播放的位置第二个参数：音频的资源ID(一般方法哦 raw 文件夹中) 其中的方法我们只介绍常用的，以后遇到在进行总结归纳 //播放开始后暂停，再播放从上次停止的位置继续start()进行播放pause()暂停 //如果括号为0,音频回到最初的位置seekTo() 指定的时间位置reset()重置 //停止后 只有先prepare()才能 start()stop()停止prepare()准备 //当播放完后需要释放资源release()释放资源 上述其他方法可以查看生命周期图 应用播放机制要想播放音频，先要获取 Audio Focus，可以理解为只有获取到音频焦点的才可以播放，虽然 Android 2.2 之后添加了 Audio Focus，来处理系统之间音频的混乱。如果有程序在它失去AudioFocus的时候仍然在使用Audio，AudioFocus拿它也没办法，用户可能安装没遵守这种机制的程序，或者版本太老还没引入这种机制的程序，这最终会导致很差的用户体验。 如何获取 Audio Focus？ 利用 AudioManager 来管理AudioFocus，先要实例化AudioManager 1AudioManager mAudioManager=(AudioManager)getSystemService(this.AUDIO_SERVICE); mAudioManager提供两个方法 : requestAudioFocus 获取焦点 1int requestAudioFocus (AudioManager.OnAudioFocusChangeListener, int streamType, int durationHint); 参数： 焦点状态改变监听器 输入流类型 STREAM_MUSIC 一般的音频其他的可以查看官方文档) 持续时间 AUDIOFOCUS_GAIN_TRANSIENT 临时获取焦点，短时间释放 AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK 临时获取焦点，前焦点保持播放，其他降低音量 AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE 介于上两个参数之间，不能破坏像通知，语音备忘，语言识别； AUDIOFOCUS_GAIN未知的时间播放歌曲或视频 请求焦点会有两个结果1 AUDIOFOCUS_REQUEST_GRANTED 请求焦点成功2 AUDIOFICUS_REQUEST_FAILED 请求焦点失败 abandonAudioFocus 释放焦点 1int abandonAudioFocus (AudioManager.OnAudioFocusChangeListener) 焦点状态改变监听器通过一个 onAudioFocusChangeLiestener 方法回调来获得 Audiofocus 发生更改 后 的通知监听设备更改 以便做出响应 onAudioFocusChangeLiestener 是一种接口 包含一个必须实施的onAudioFocusChange 抽象类（如果获得焦点 应该做什么，失去后应该做什么 onAudioFocusChange：四个参数: AUDIOFOCUS_GAIN AUDIOFOCUS_LOSS AUDIOFOCUS_LOSS_TRANSIENT AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK 不懂的可以点看连接详细理解。 实战演练实现当失去焦点时，暂停，等恢复获得焦点后，继续播放 下面是通过 ArrayList 一个数组列表（List+ArrayAdapter实现），看不懂没关系，主要理解当点击时，先获取 AudioFocus 状态，根据焦点状态进行判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class NumbersActivity extends AppCompatActivity &#123; //定义一个音频管理的对象 private AudioManager mAudioManager; //创建一个监听音频聚焦的监听器 AudioManager.OnAudioFocusChangeListener mAudioFocusChangeListener = new AudioManager.OnAudioFocusChangeListener() &#123; @Override public void onAudioFocusChange(int i) &#123; //判断当状态 暂时失去音频焦点 暂停并并重置 if(i==AudioManager.AUDIOFOCUS_LOSS_TRANSIENT|| i==AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK)&#123; mediaPlayer.pause(); mediaPlayer.seekTo(0); &#125;else //判断当状态获取音频焦点时应该播放 if(i==AudioManager.AUDIOFOCUS_GAIN)&#123; mediaPlayer.start(); &#125;else //当前状态 永远失去焦点的时候 释放资源 if(i==AudioManager.AUDIOFOCUS_LOSS)&#123; releaseMediaPlayer(); &#125; &#125; &#125;; private MediaPlayer mediaPlayer; //？？？有必要吗？ private MediaPlayer.OnCompletionListener mCompletionListener = new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mediaPlayer) &#123; releaseMediaPlayer(); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.word_list); //获取AudioManager mAudioManager = (AudioManager) getSystemService(this.AUDIO_SERVICE); //自定义的数组列表 类型是Word类的数据 final ArrayList&lt;Word&gt; words = new ArrayList&lt;Word&gt;(); words.add(new Word(&quot;one&quot;, &quot;lutti&quot;, R.drawable.number_one, //自定义的一个适配器，继承以前的数组适配器 WordAdapter itemsAdapter = new WordAdapter(this, words, R.color.category_numbers); ListView listView = (ListView) findViewById(R.id.list); listView.setAdapter(itemsAdapter); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; Word word = words.get(i); //request 获取Audio Focus int result=mAudioManager.requestAudioFocus(mAudioFocusChangeListener , AudioManager.STREAM_MUSIC , AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK); //成功的焦点更改请求 if(result==AudioManager.AUDIOFOCUS_REQUEST_GRANTED)&#123; //创建一个MediaPlayer mediaPlayer = MediaPlayer. create(NumbersActivity.this, word.getMusicResource()); //开始播放 mediaPlayer.start(); // mediaPlayer.setOnCompletionListener(mCompletionListener); &#125; &#125; &#125;); &#125; @Override protected void onStop() &#123; super.onStop(); releaseMediaPlayer(); &#125;// 自定义的一个释放资源的类 private void releaseMediaPlayer() &#123; if (mediaPlayer != null) &#123; mediaPlayer.release(); mediaPlayer = null; //失去焦点 mAudioManager.abandonAudioFocus(mAudioFocusChangeListener); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要写博客？]]></title>
    <url>%2F2017%2F03%2F28%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[作者：陈素封链接：https://zhuanlan.zhihu.com/p/19743861来源：知乎 为什么你要写博客？ 一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。 大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？ 所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。 注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。 博客的内容写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的： 不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……； 有目的地写，要务实，追求质量； 承认真实的自己，不要吹嘘，不要装逼，无需讨好读者； 记录自己学习、思考、总结的过程； 分享你的故事、所得、感想、经验；值得写的原因 以下是一个清单，可以根据自己的情况匹配，然后选择。 重新认识自己是不是很久没有跟自己对话了？ 你可以尝试从回答一些问题开始，将你过去要回避的问题写下来，例如就可以从这个九个问题开始： 1、请你介绍一下你自己，你是个什么样的人？ 2、你有什么理想吗？这个理想是怎么形成的？ 3、你理想的伴侣关系是什么样的？你自己在这个伴侣关系中扮演什么样的角色？要承担什么样的责任？ 4、你理想的事业是什么，你正在做的工作符合你的事业理想吗？这份工作对你的意义是什么？ 5、你对亲子关系怎么看？对你来说，什么是一个理想的父亲（母亲），你期望自己成为这样一个理想父亲（母亲）吗？ 6、你对钱怎么看，你认为赚到多少钱是足够的？如果你明天一早醒来，已经有足够的钱，你将会如何继续安排自己的生活？ 7、对你来说，什么是理想的性生活？什么是理想的性道德，在你的性道德观中，什么样的性生活是禁忌的，需要避免的，什么样的性生活是美好的，需要得到鼓励和发展的？ 8、你的择友标准是什么？什么样的人你会愿意交往，什么样的人你会拒绝和他交往？ 9、你对死亡怎么看？你希望自己活到多少岁，你准备怎么度过从现在到死亡的这段时间？如果你要立遗嘱，这份遗嘱会怎么写？ 以上的这九个问题摘自《很少人能顺畅回答这9个问题——心理治疗刚开始医生常常会先问你的 》by 李孟潮。 这些问题的答案你可以选择不发，但是我强烈地建议写下来，只有在写的时候你才可以慎重地思考这些问题，而不会回避跳过或者留下空白，这是接受自己的第一步。 提供持续学习的动力例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。 详细的知识管理可以看我的这篇文章：《个人知识管理的方法》，回复「知识」可见 积累更多的知识 写并不是单纯的写。 例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。 例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。 提高将事情讲清楚的能力很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。 分享带来的连锁反应“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》 互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。 帮你找到志同道合的人在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。 如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。 即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》 记录成长隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。 更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！ 培养持续做一件事情的能力 开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」 让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。 你不相信？你不试试你怎么知道？ 默默地持续做一件事是一种难得的能力，也是一种难得的品质。 讨论反思每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。 互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。 搜寻到你意想不到东西 世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。 例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。 一个人在做一件属于自己的事很多你认为自己很牛逼的事情都是自己一个人做出来。 别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？ 如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》 互联网的身份识别：一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。 这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏 最后你可能想不到在白纸的左边（不值得写博客的原因）写什么了，想不到写个「博客时代已经过去」或者「我没有时间」也可以，但与此同时，你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」。 如果你不想思考，也可以回复「价值」看看别人的建议。 推荐写作平台： 简书（推荐）自己搭建一个独立博客新浪博客]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
