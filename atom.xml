<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>仙人掌的博客</title>
  
  <subtitle>喜欢与世无争的清静</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lowape.github.io/didiaoyuan.github.io/"/>
  <updated>2018-03-25T03:14:12.082Z</updated>
  <id>https://lowape.github.io/didiaoyuan.github.io/</id>
  
  <author>
    <name>didiaoyuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自我反思-17-12-9</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/12/09/%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D-17-12-9/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/12/09/自我反思-17-12-9/</id>
    <published>2017-12-09T11:11:15.000Z</published>
    <updated>2018-03-25T03:14:12.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很久没有写博客了，因为一直忙着比赛的事情，所以一段时间不断的练习，不断的敲代码，今天终于是结束了，再过一个星期就要考六级了，之后又要考专业课了。今天算是小阶段的休息，顺便反思总结最近的状态，并把最近的感受记录下来。</p></blockquote><h1 id="知识需要在不断地实践中巩固"><a href="#知识需要在不断地实践中巩固" class="headerlink" title="知识需要在不断地实践中巩固"></a>知识需要在不断地实践中巩固</h1><p>应该很多人都会遇到过这种情况，自己学了很久的东西，当需要用的时候，却不知道如何下手。经过这次综合的练习，我认识到其实知识是需要不断的实践与练习中巩固。而这一过程还需要自己思考。只有完成理论-实践-思考，这三步骤，才能将知识逐渐转换成自己的东西。</p><h1 id="你只是看起来很努力"><a href="#你只是看起来很努力" class="headerlink" title="你只是看起来很努力"></a>你只是看起来很努力</h1><p>回想以前的自己，每天学习，敲代码到十一点才结束，每天感觉到很累，以为自己努力的学到了东西，事实，一次实践项目练习暴露出自己学习不精，不牢的现象。每天看似很忙，其实在瞎忙。很多次遇到这种情况都感到小愤怒。后来通过读书慢慢找到了方法，知道了原因。<strong>读书，看起来没什么用，其实是因为没有在正确的情况下读正确的书</strong>。</p><blockquote><p>推荐书籍《精进：如何变成一个厉害的人》</p></blockquote><h1 id="效率很重要"><a href="#效率很重要" class="headerlink" title="效率很重要"></a>效率很重要</h1><p>知道自己的问题，我开始调整自己的作息时间，以及修改自己的学习方式。第一步作息时间很重要。发现自己越来越懒，早上起不来，晚上睡不着觉。这种状态持续很久，最近发现一本书，慢慢改善自己的睡眠。学习方式，从以前的逼迫是转变为效率最高学习，当出现注意了不集中的情况下，就进行短暂的休息。最关键的还是要思考，不能总跟这书中，视频的了进度走，因为很容易，我们从学知识，变成了<strong>抄</strong>知识，到最后还是没学会，没学好。做笔记方面，从以前的电脑笔记，转换为手写笔记。虽然电脑笔记有方便，以及方便查看的优点。但是不得不吐槽，在查询知识的同时，很容易让广告，或者其他链接忘记自己要做的正事。每次游览网页，很容易被带到别的内容上，这就是互联网，信息大量出现的弊端。我们很难再一大堆东西选出自己想要的东西。顺便说一下，目前本人十分看好大数据….哈哈哈，扯远了。最后就是你每一步的学习，都会给你一点反馈，注意你的反馈，适当的调整自己的策略…</p><blockquote><p>推荐书籍《这本书能让你睡得好》</p></blockquote><h1 id="长路漫漫"><a href="#长路漫漫" class="headerlink" title="长路漫漫"></a>长路漫漫</h1><p>以后一定是从事软件开发这一行了，入行两年，学的也只是皮毛，年轻人太浮躁，看着这个行业的工资那么诱人，总是急急忙忙投入，能早日实现经济独立，早日证明自己，有时候会迷失自己。只有慢慢的努力，扎扎实实的才能走的长久，现已看透，决定慢慢走这一条路…最后，不愿当一条咸鱼，因为我是一个有梦想的人，我要改变世界！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;很久没有写博客了，因为一直忙着比赛的事情，所以一段时间不断的练习，不断的敲代码，今天终于是结束了，再过一个星期就要考六级了，之后又要考专业课了。今天算是小阶段的休息，顺便反思总结最近的状态，并把最近的感受记录下来。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>在Atom中实时协作</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/17/%E5%9C%A8Atom%E4%B8%AD%E5%AE%9E%E6%97%B6%E5%8D%8F%E4%BD%9C/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/17/在Atom中实时协作/</id>
    <published>2017-11-17T02:34:04.000Z</published>
    <updated>2017-11-17T03:13:20.389Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://teletype.atom.io/?utm_source=announcement&amp;utm_medium=email&amp;utm_campaign=atom-teletype-1117" target="_blank" rel="external">官网地址</a><br><br><a href="https://atom.io/packages/teletype" target="_blank" rel="external">插件地址</a> <br></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>安装 <a href="https://atom.io/" target="_blank" rel="external">Atom</a></li><li>安装 teletype 插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apm install teletype</div></pre></td></tr></table></figure></li></ul><p>atom中安装</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flkw1pjau5j30yh0qzjui.jpg" alt=""></p><h1 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1flkws1y7bxg30xa0eib2b.gif" alt=""></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>点击 小信号塔，会发现跟 gif 出现的不同，我们需要先进入那个网站，进行授权</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flkw6d47y2j30l60hhta1.jpg" alt=""></p><p>然后得到这串 token 输入到刚才的位置，就可以进行正常操作了</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flkw7scgzoj30o40ksdh4.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://teletype.atom.io/?utm_source=announcement&amp;amp;utm_medium=email&amp;amp;utm_campaign=atom-teletype-1117&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
      <category term="Atom" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Atom/"/>
    
    
      <category term="Atom" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Atom/"/>
    
  </entry>
  
  <entry>
    <title>慢慢</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/15/%E6%85%A2%E6%85%A2/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/15/慢慢/</id>
    <published>2017-11-15T15:02:23.000Z</published>
    <updated>2017-11-15T15:51:21.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>连续几天没有写博客，也没有去敲代码，这几天状态超级差，逃避的在宿舍呆了三天，这三天什么都不想，就是各种耗时间。</p></blockquote><h1 id="窒息"><a href="#窒息" class="headerlink" title="窒息"></a>窒息</h1><p>每天都很忙的去学习，喜欢的东西又不能真正的去认真花时间研究，本以为上了大学能有自己的空间，其实就是扯淡，我很庆幸自己上的专科，没有本科那种各种课程，唯一遗憾的就是确实没有本科学的那么扎实，教学质量那么好，好了不吐槽了。知道我自己在专科的劣势，我每天都希望自己过的很充实，最起码毕业了能学到点东西，可是，都大三了，每天还是那么多事，不是学校让干这个就是自己需要准备这个那个的，这几天我真的逼疯了。我不想考虑学习的事情，不想考虑比赛，不想考虑六级考试，不想考虑升学考试…..我就这样在宿舍呆了三天，没有出去，吃饭都让舍友带饭，自己就不断地打游戏，看电影，明明很累了，头疼我都不停下来。</p><h1 id="逃避"><a href="#逃避" class="headerlink" title="逃避"></a>逃避</h1><p>三天，我没有理任何人，然后，第一次被女朋友狠狠的训斥了一番，点醒了自己。从小到大，每当我遇到无法解决的问题，我总是逃避，虽然我一直不承认自己是在逃避么我总觉得是我累了，需要好好放松一下就好了，可是往往就是让自己越来越累，我根本就没有想着如何处理，只是觉得休息一下就好。说到底，就是适应能力太差，从第一次经历喜欢的老师走了，然后开始不好好学习，更新老师对着干，到高中不喜欢高中的人与人之间冷漠的关系，自己跟自己赌气，明明不瞌睡，却就是不想听课。不喜欢宿舍生活，各种闹腾想回家，这些年让父母操碎了心，可是这个问题我一直逃避。结果就是没隔一段是时间我总是发一阵分，对任何人不理不睬，只想逃避，只想着找个安静的地方。可是每次发泄完，我又开始重复的那些工作，然后等待下一次爆发。</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>当被她说出自己最关键的问题，我才真的觉得自己真是在逃避现实。我无法解决现实生活中看不惯，不喜欢的事情，我总是在挣扎，可能想我这样年龄的都有吧，没想要玩着度过自己的大学，却总是在挣扎想要实现自己肩负改变整个家庭命运的使命，没有人逼迫自己，就是自己想要未来的生活，每次你感觉自己已经很努力的，但是总是抓不住你想要的结果，就非常苦恼，常常质问自己，每当你学的东西被遗忘的时候，总是感觉以前的时光被虚度了，虽然我也常常安慰自己，最后总是被现实的人或事让你觉得这个世界是多么的冷漠，是多么可笑…..可能这本身就是成长的烦恼，但是我觉得自己就是太想改变世界了，哈哈哈。</p><h1 id="慢慢"><a href="#慢慢" class="headerlink" title="慢慢"></a>慢慢</h1><p>你热爱生活吗？当我遇到这个问题，我才觉得我现在一点都不热爱生活，我被生活囚禁了。感谢小天使在我人生中出现，让我改变了很多。感谢有你在我身边不断的鼓励我。感谢有你每天都对我笑。感谢有你让我正视自己的问题….<br>我会慢慢理解生活，享受生活，热爱生活。其实我也没有那么急，每天忙忙碌碌的人，你是否知道自己忙什么吗？如果像我这样这是为了一个未来的蓝图，天天忙的只会吐槽生活，那最后收获的也仅仅是最后那一瞬间的快乐。为什么不让自己慢下来，慢慢享受生活呢？谁说输在起跑线上的人一定会比抢跑的人过的好？</p><blockquote><p>最后我可能改变不了世界，但是我可以改变我自己，不想忙忙碌碌最后才发现，拼搏那那么久原来得到的不是正真想要的生活！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;连续几天没有写博客，也没有去敲代码，这几天状态超级差，逃避的在宿舍呆了三天，这三天什么都不想，就是各种耗时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;窒息&quot;&gt;&lt;a href=&quot;#窒息&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习(六)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/09/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%85%AD/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/09/C语言复习-六/</id>
    <published>2017-11-09T12:31:02.000Z</published>
    <updated>2017-11-09T13:22:45.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><p>C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。</p><p><strong>小节-关键字：</strong></p><p>基本数据类型由 11 个关键字组成: int、long、short、unsigned、char、float、double、signed、<br>_Bool、_Complex 和 _Imaginary</p><p><strong>有符号整型</strong></p><p>表示正整数和负整数，</p><ul><li>int 为系统给定的基本整数类型。C语言规定int 类型不少于 16位</li><li>short或 short int 最大的 short 整数小于或等于最大的int类型整数。C语言规定 short 类型至少占32位。</li><li>long long 或 long long int 该类型整数大于或等于最大的int 类型整数。C语言规定 long long 类型至少占 32位</li></ul><p><strong>无符号整型</strong></p><p>无符号整型表示零或正整数。无符号整型表示方法</p><ul><li>unsignedint</li><li>unsigned long</li><li>unsigned short</li></ul><p><strong>字符类型</strong></p><p>打印出来的符号(A、&amp;he1+)都是字符 char</p><p><strong>布尔类型</strong></p><p>C语言用 1表示 true，0 表示 false。  _Bool 类型是无符号int 类型</p><p><strong>实浮点类型</strong></p><ul><li><p>float 可精确至少<br>位有效数字</p></li><li><p>double 存储浮点数范围大，至少10位有效数字和更大指数</p></li><li><p>long long 存储浮点数 的范围比 double 更大，能把表示比 double 更多的邮箱数字和更大的指数。</p></li></ul><h1 id="类型大小"><a href="#类型大小" class="headerlink" title="类型大小"></a>类型大小</h1><p>使用 sizeof()内置运算符 知道指定类型的大小。打印类型大小使用 %zd 占位符表示（C99）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%zd \n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flc53gpa3bj302j062743.jpg" alt=""></p><p>输出结果表示的是不同类型的字节，比如 char 一定为 1 字节 ，char 类型 为 16 位 ，double 为 64 位的系统中，sizeof 给出的 double 字节为 4。（4*16=64）</p><h1 id="参数和陷阱"><a href="#参数和陷阱" class="headerlink" title="参数和陷阱"></a>参数和陷阱</h1><p>printf(),””里面的内容表示参数，一般参数都用 ， 分割。一般注意，使用数据类型要判断具体使用哪一种，在使用 printf 还要注意参数匹配问题，有些会出现参数多了，参数少了，匹配的占位符与参数类型不同的等问题，会根据不同的编译器，报不同的错误！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;其他类型&quot;&gt;&lt;a href=&quot;#其他类型&quot; class=&quot;headerlink&quot; title=&quot;其他类型&quot;&gt;&lt;/a&gt;其他类型&lt;/h1&gt;&lt;p&gt;C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小节-关键字：&lt;/str
      
    
    </summary>
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>软件工程复习总结(二)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/09/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%8C/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/09/软件工程复习总结-二/</id>
    <published>2017-11-09T12:30:14.000Z</published>
    <updated>2017-11-09T12:35:34.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四、系统设计"><a href="#四、系统设计" class="headerlink" title="四、系统设计"></a>四、系统设计</h1><p><strong>理解面向对象的设计原则（7个）</strong></p><ul><li>单一职责原则</li></ul><blockquote><p>解释：可以降低类的复杂度，一个类只负责一项职责</p></blockquote><ul><li>里氏替换原则</li></ul><blockquote><p>解释：超类存在的地方，子类是可以替换的。</p></blockquote><ul><li>依赖倒置原则</li></ul><blockquote><p>解释：尽量依赖抽象，不依赖具体实现</p></blockquote><ul><li>接口隔离原则</li></ul><blockquote><p>解释：为客户端提供尽可能小的单独的接口，而不是提供大的总的接口</p></blockquote><ul><li>迪米特法则</li></ul><blockquote><p>解释：最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p></blockquote><ul><li>开闭原则</li></ul><blockquote><p>解释：面向扩展开发，面向修改关闭</p></blockquote><ul><li>组合/聚合复用原则</li></ul><blockquote><p>解释：尽量使用合成/聚合达到复用，尽量少用继承。原则：一个类中有另一个类的对象。</p></blockquote><p><strong>明确概要(系统)设计阶段的任务</strong></p><p>制定软件系统的总体设计，确定了各个模块的功能及模块之间的联系，再进一步就要考虑如何实现各个模块所规定的功能</p><p><strong>掌握数据库设计方法（E-R图–与关系模型）</strong></p><p>实体-联系图的数据模型<br> 1.实体(数据对象)<br>2.属性是实体或联系所具有的性质，一个实体对应多个属性<br>3.联系</p><ul><li>一对一的关系映射为数据库表的主外键关联，在任意端的属性中加入另一端的主键做外键；</li><li>一对多的关系映射为数据库表的主外键关联，一端的主键加入n端成为外键；</li><li>多对多的关系映射为一个单独的表，两个多端的主键成为该表的外键，两个外键的组合成为该表的主键。</li></ul><p>E-R图 矩形为实体，菱形表示联系，属性表示椭圆</p><p><strong> MVC 设计模式</strong></p><p>模型层、视图层、控制层<br>使用MVC的目的是增强代码的重用性，降低数据描述和应用操作的可耦合度，提高代码可读性，及软件的可维护性、可修复性、灵活性和封装性。</p><p><strong>软件体系结构的特点（C/S与B/S）</strong></p><p>C/S（Client/Server）结构，即客户机和服务器结构，客户端实现绝大多数数业务逻辑处理和界面显示，客户端复杂度大于服务器端。</p><p>B/S（Browser/Server）结构，即浏览器和服务器结构，用户工作界面通过浏览器实现，主要事务逻辑在服务器端实现，简化了客户端电脑载荷。</p><p><strong>理解软件结构设计原则</strong></p><ul><li><p>模块化：将功能相同或相近的代码写成模块， 便于分工合作，便于调试，便于移植，便于改进；</p></li><li><p>抽象：抽取事务最基本的特征和行为，忽略非本质细节；</p></li><li><p>逐步求精：即将系统功能按层次进行分解，每一层不断将功能细化，到最后一层都是功能单一、简单易实现的模块。</p></li><li><p>信息隐藏：采用封装技术，将程序模块的实现细节隐藏起来，使模块接口尽量简单；</p></li><li><p>局部化：保证模块之间具有松散的耦合关系，使模块内部具有较高的内聚性；</p></li><li><p>高内聚低耦合：主要是看类的内聚性是否高，耦合度是否低。</p></li></ul><p><strong>理解模块内聚性</strong></p><p>内聚性又称快内联系，指模块的功能强度的度量，模块中组成元素结合得越紧密，内聚性越高，模块的独立性也就越高。理想的类聚性要求模块的功能应明确、单一，一个模块只做一件事。耦合性又称块间联系，模块之间联系越紧密，耦合性越强。</p><ul><li><p>偶然内聚：指一个模块内的各处理元素之间没有任何联系；</p></li><li><p>逻辑内聚：模块内执行几个逻辑上相似的功能，通过参数确定该模块完成哪一个功能；</p></li><li><p>时间内聚：把需要同时执行的动作合在一起形成的模块为时间内聚模块；</p></li><li><p>通信内聚（信息内聚）：指模块内所有处理元素都在同一个数据结构上操作，或指各处理使用相同的输入数据或者产生相同的输出数据；</p></li><li><p>顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入；</p></li><li><p>功能内聚：最强的内聚，指模块内所有元素共同完成一个功能，缺一不可。</p></li></ul><p><strong>理解模块间的耦合性（6）及原则</strong></p><ul><li><p>非直接耦合：如果两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的，这就是非直接耦合。这种耦合的模块独立性最强。</p></li><li><p>数据耦合：如果一个模块访问另一个模块时，彼此之间是通过数据参数(不是控制参数、公共数据结构或外部变量)来交换输入、输出信息的，则称这种耦合为数据耦合。</p></li><li><p>印记耦合：如果一组模块通过参数表传递记录信息，就是标记耦合。</p></li><li><p>控制耦合：如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。</p></li><li><p>外部耦合：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</p></li><li><p>公共耦合：若一组模块都访问同一个公共数据环境，则它们之间的耦合就称为公共耦合。公共的数据环境可以是全局数据结构、共享的通信区、内存的公共覆盖区等。 这种耦合会引起下列问题：<br>所有公共耦合模块都与某一个公共数据环境内部各项的物理安排有关，若修改某个数据的大小，将会影响到所有的模块。<br>无法控制各个模块对公共数据的存取，严重影响软件模块的可靠性和适应性。<br>公共数据名的使用，明显降低了程序的可读性。<br>公共耦合的复杂程度随耦合模块的个数增加而显着增加。若只是两个模块之间有公共数据环境，则公共耦合有两种情况。<br>若一个模块只是往公共数据环境里传送数据，而另一个模块只是从公共数据环境中取数据，则这种公共耦合叫做松散公共耦合。若两个模块都从公共数据环境中取数据，又都向公共数据环境里送数据，则这种公共耦合叫做紧密公共耦合。只有在模块之间共享的数据很多，且通过参数表传递不方便时，才使用公共耦合。否则，还是使用模块独立性比较高的数据耦合好些。</p></li><li><p>内容耦合：如果发生下列情形，两个模块之间就发生了内容耦合。<br>一个模块直接访问另一个模块的内部数据；<br>一个模块不通过正常入口转到另一模块内部；<br>两个模块有一部分程序代码重叠(只可能出现在汇编语言中)；<br>一个模块有多个入口。<br>在内容耦合的情形，所访问模块的任何变更，或者用不同的编译器对它再编译，<br>都会造成程序出错。好在大多数高级程序设计语言已经设计成不允许出现内容<br>耦合。它一般出现在汇编语言程序中。这种耦合是模块独立性最弱的耦合。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;四、系统设计&quot;&gt;&lt;a href=&quot;#四、系统设计&quot; class=&quot;headerlink&quot; title=&quot;四、系统设计&quot;&gt;&lt;/a&gt;四、系统设计&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;理解面向对象的设计原则（7个）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则&lt;/
      
    
    </summary>
    
    
      <category term="项目管理" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习(五)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/08/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E4%BA%94/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/08/C语言复习-五/</id>
    <published>2017-11-08T14:06:50.000Z</published>
    <updated>2017-11-08T16:02:41.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="float、double、long-double"><a href="#float、double、long-double" class="headerlink" title="float、double、long double"></a>float、double、long double</h1><p>浮点数多用于金融和数学的程序。浮点数类型能表示包括小数在内更大范围的数。浮点数表示类似于科学记数法(即用小数乘以10的幂来表示数字)。<br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flb1lvn8uwj30qb067ab5.jpg" alt=""></p><p><strong>float</strong></p><p>C标准规定，float 类型必须至少能表示6位有效数字，且取值范围至少是10^-37<br>~10^38。系统要存储一个浮点数要占用32位。其中8位表示指数的值和符号，剩下24位用于表示非指数部分(也叫做尾数或有效数)及其符号。</p><p><strong>double</strong></p><p>双精度。double 类型和 float 类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double 占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数(即提高了精度)，减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double 类型的值至少有 13位有效数字，超过了标准的最低位数规定。</p><p><strong>long double</strong></p><p>比满足比 double 类型更高的精度要求。C只保证long double 类型至少与 double 类型的精度相同。</p><h2 id="声明浮点变量"><a href="#声明浮点变量" class="headerlink" title="声明浮点变量"></a>声明浮点变量</h2><p>float a;<br>double b;<br>float c=6.63e-34;<br>long double d;</p><h2 id="浮点常量的表示"><a href="#浮点常量的表示" class="headerlink" title="浮点常量的表示"></a>浮点常量的表示</h2><ol><li>有符号的数字，后面紧跟 e 或 E,可以省略小数部分，或者整数部分<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">-1.56E+12</span></div><div class="line"><span class="number">2.87e-3</span></div><div class="line"><span class="number">.2</span></div><div class="line"><span class="number">4e16</span></div><div class="line"><span class="number">.8E-5</span></div><div class="line"><span class="number">100.</span></div></pre></td></tr></table></figure></li></ol><blockquote><p>不要在浮点型常量中间加空格 如：1.56 E+12 (错误)</p></blockquote><p>默认情况下，编译器假定浮点型常量为 double 类型的精度<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> abc= <span class="number">4.0</span> * <span class="number">2.0</span>;</div></pre></td></tr></table></figure></p><p>其中的 4.0 和 2.0 常数默认为 double 类型计算后截断为float 类型。这样的程序运行速度会缓慢。使用 f 或 F 常量后缀，可以覆盖默认模式，比如：4.0f 或 2.0f 如果添加 l 或 F 可以变为 long double 类型 如：54.3L 和34.1l 建议使用大写，因为l小写与数字1 相似。</p><blockquote><p>C99 标准添加了一种新的浮点型常量格式–用十六进制表示浮点型常量，即添加 Ox 或 OX ,用 p 和 P 分别代替 e 和 E，用 2的幂代替10的幂(p 计数法)。如:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Oxa<span class="number">.1f</span>p10</div></pre></td></tr></table></figure><p>a 十进制表示 10，.1f 是 1/16，f是15所以 为15/256， 加上 p10 表示 2^10或1024。Oxa.1fp10 表示（10+1/16+15/256）* 1024</p><blockquote><p>注意：并非所有编译器都支持 C99</p></blockquote><h1 id="打印浮点值"><a href="#打印浮点值" class="headerlink" title="打印浮点值"></a>打印浮点值</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">float</span> a=<span class="number">32000.0</span>;</div><div class="line"><span class="keyword">double</span> b=<span class="number">2.14e9</span>;</div><div class="line"><span class="keyword">long</span> <span class="keyword">double</span> c=<span class="number">5.5e-6</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%f  &amp;  %e \n"</span>,a,a);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%f  &amp; %e \n"</span>,b,b);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%Lf &amp; %Le \n"</span>,c,c);</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flb3q48eagj30a60473yf.jpg" alt=""></p><p>第三个显示我有点费解，后来想到保证 6位有效数字，就可以理解了</p><h1 id="浮点数的上溢和下溢"><a href="#浮点数的上溢和下溢" class="headerlink" title="浮点数的上溢和下溢"></a>浮点数的上溢和下溢</h1><p><strong>上溢</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> toobig = <span class="number">3.4E38</span> * <span class="number">100.0f</span>；</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%e \n"</span>,toobig);</div></pre></td></tr></table></figure></p><p>以上 3.4E38 float 最大范围值*正数，超过最大值，会出现上溢，打印显示 inf 或 infinity (或者无穷含义)</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flb3wnl0loj308101c0o7.jpg" alt=""></p><p><strong>下溢</strong></p><p>以 十 进 制 为 例， 把 一 个 有 4 位 有 效 数 字 的 数（ 如， 0.1234E-10） 除 以 10， 得 到 的 结 果 是 0.0123E-10。 虽 然 得 到 了 结 果， 但 是 在 计 算 过 程 中 却 损 失 了 原 末 尾 有 效 位 上 的 数 字。 这 种 情 况 叫 作 下 溢（ underflow）。</p><p><strong>NaN</strong><br>NOT a number</p><blockquote><p>例 如， 给 asin() 函 数 传 递 一 个 值， 该 函 数 将 返 回 一 个 角 度， 该 角 度 的 正 弦 就 是 传 入 函 数 的 值。 但 是 正 弦 值 不 能 大 于 1， 因 此， 如 果 传 入 的 参 数 大 于 1， 该 函 数 的 行 为 是 未 定 义 的。 在 这 种 情 况 下， 该 函 数 将 返 回 NaN 值， printf() 函 数 可 将 其 显 示 为 nan、 NaN 或 其 他 类 似 的 内 容。<br>[美]史蒂芬·普拉达（Stephen Prata）. CPrimer Plus（第6版）中文版 (Kindle 位置 1840-1842). 人民邮电出版社.</p></blockquote><p><strong>浮点数的舍入错误</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">float</span> a,b;</div><div class="line">a=<span class="number">2.0e20</span> +<span class="number">1.0</span>;</div><div class="line">b=a<span class="number">-2.0e20</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%f \n"</span>,b);</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flb49n9h2bj307q035t8k.jpg" alt=""></p><p>出现这种问题的原因：flaot 的数字只能存储按指数比例缩放或放大的 6或7位有效数字。上面是20位，如果加1就是21位，所以出现错误</p><blockquote><p>大部分总结的内容出自《C Primer Plus 》 书中。总结是为了方便本人理解与学习</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;float、double、long-double&quot;&gt;&lt;a href=&quot;#float、double、long-double&quot; class=&quot;headerlink&quot; title=&quot;float、double、long double&quot;&gt;&lt;/a&gt;float、double、l
      
    
    </summary>
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>软件工程复习总结</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/08/软件工程复习总结/</id>
    <published>2017-11-08T08:53:22.000Z</published>
    <updated>2017-11-08T09:13:11.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、软件工程概述"><a href="#一、软件工程概述" class="headerlink" title="一、软件工程概述"></a>一、软件工程概述</h1><p><strong>什么是软件，软件与程序的区别</strong></p><p>软件=程序+数据结构+文档</p><p>程序是一系列命令代码的集合<br>软件是指一个计算机系统有关程序、过程和有关文档的完整集合</p><p><strong>什么是软件危机？其产生的原因</strong></p><p>软件危机泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题</p><ul><li>用户需求不明确</li><li>缺乏正确的理论指导</li><li>软件开发规模越来越大</li><li>软件开发复杂度越来越高</li></ul><p><strong>软件工程的概念及研究内容</strong></p><p>软件工程是采用工程的概念、原理、技术、和方法，并结合正确的管理技术和当前能够得到的最先进的技术方法，经济高效地开发和维护软件的一门工程学科。</p><p>研究的内容主要是软件开发技术和软件开发管理</p><p><strong>软件生存周期的概念及划分</strong></p><p>从形成开发软件概念起，所开发的软件使用以后，直到失去使用价值消亡为止的整个过程，成为软件生命周期</p><ul><li>定义时期<ol><li>问题定义</li><li>可行性研究</li><li>需求分析</li></ol></li><li>开发时期<ol><li>总体设计</li><li>详细设计</li><li>编码和单元测试</li><li>综合测试</li></ol></li><li>维护时期<ul><li>维护</li></ul></li></ul><p><strong>常见的软件生存周期模型(各个模型特点)</strong></p><ol><li>瀑布模型</li><li>快速原型</li><li>增量模型</li><li>螺旋模型</li><li>喷泉模型</li><li>变换模型和基于组件的模型</li></ol><p><strong>传统软件工程与面向对象软件工程的各自特点</strong></p><p>传统软件工程是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件。</p><p>面向对象软件工程把对象作为融合了数据及在数据上的操作行为的统一的软件构件，把所有对象都划分成了类，按照父类（基类）与子类（派生类）的关系，把若干个相关类组成一个层次结构的系统，对象彼此之间仅能通过发送消息相互联系。</p><h1 id="二、可行性研究"><a href="#二、可行性研究" class="headerlink" title="二、可行性研究"></a>二、可行性研究</h1><p><strong>可行性研究的任务</strong></p><p>可行性研究最根本的任务是对以后的行动方针提出建议，若问题值得解，则推荐一个好的解决方案，并制定一个初步的工程计划。若问题没有可行的解，则建议停止开发工程。<br><strong>可行性研究的步骤</strong></p><pre><code>（1）分析系统的目的；（2）分析当前系统的状况；（3）当前系统的业务流程；（4）分析当前系统的不足；（5）提出新的目标系统；（6）检查目标系统是否满足要求；（7）制定新系统的技术方案；（8）方案分析比较，对不同的系统开发方案进行分析、比较和论证，选择合理的方案；（9）推荐方案；（10）编制新系统的开发计划；（11）编制可执行的研究报告。</code></pre><p>典型的可行性研究：</p><ol><li>复查并确定系统规模和目标</li><li>研究目前正在使用的系统</li><li>建立新系统的高层逻辑模型</li><li>导出和评价各种方案</li><li>推荐可行的方案</li><li>草拟初步的开发计划</li><li>编写可行性研究报告提交审查</li></ol><p><strong>会绘制业务流程图</strong><br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flas6p2xsvj31021jk1kx.jpg" alt=""></p><h1 id="三、需求分析"><a href="#三、需求分析" class="headerlink" title="三、需求分析"></a>三、需求分析</h1><p><strong>需求分析的任务是什么?</strong></p><p>确定对目标系统提出的完整、真确、清晰、而且具体的需求</p><p><strong>需求分析的步骤</strong></p><pre><code>- 确定系统的综合需求- 分析系统的数据要求- 创建软件的逻辑模型- 编写软件需求规格说明书- 需求验证</code></pre><p><strong>结构化分析方法(SA)的要点</strong></p><p>  结构化分析方法使用简单易读的符号，根据软件内部数据传递、变更的关系，以“分解”和“抽象”为基本原则，按照自顶向下、逐层分解的分析策略，描绘满足功能要求的软件模型。适用于数据处理类型软件，利用半形式化工具“数据流图”和“数据字典”表达需求，简明易懂。</p><p><strong>数据流图的作用及绘制要领</strong></p><p>数据流图描绘数据在软件中从输入移动到输出的过程中所经受的变换，没有任何具体的物理元素。</p><p>分层绘制，采用自顶向下、逐层分解的原则，直到功能细化为止，形成若干层次的数据流图。</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flas8itj25j30ab048weg.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1flas88dactj30gp0cmgqy.jpg" alt=""></p><p><strong>面向对象的分析方法（OOA）</strong></p><p>是把实体-联系图中的概念与面向对象程序设计语言中的概念结合在一起，形成一种分析方法。面向对象分析的关键是识别、定义问题域内的类与对象，并分析它们之间的关系，根据问题域中的操作规则建立模型。</p><p><strong>掌握用例图建模方法</strong></p><p>用例模型的建立是由开发者和客户共同协商完成的，通过讨论需求的规格说明达成共识，明确系统的基本功能。</p><p><strong>数据字典概念</strong></p><p>数据字典是描述数据的信息的集合，是对系统中使用的所有数据元素的定义的集合，是数据流图的补充工具。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、软件工程概述&quot;&gt;&lt;a href=&quot;#一、软件工程概述&quot; class=&quot;headerlink&quot; title=&quot;一、软件工程概述&quot;&gt;&lt;/a&gt;一、软件工程概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;什么是软件，软件与程序的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件=程序+数
      
    
    </summary>
    
    
      <category term="项目管理" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习(四)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/07/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E5%9B%9B/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/07/C语言复习-四/</id>
    <published>2017-11-07T05:08:04.000Z</published>
    <updated>2017-11-07T15:40:52.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a>_Bool类型</h1><p>c99标准添加了 _Bool 类型，用于表示布尔值（true 和 false）。因为 C 语言用值 1 表示 true，值 0 表示 false，所以 _Bool<br>类型实际上也是一种整数类型</p><h1 id="可移植类型-stdint-h和-inttypes-h"><a href="#可移植类型-stdint-h和-inttypes-h" class="headerlink" title="可移植类型: stdint.h和 inttypes.h"></a>可移植类型: stdint.h和 inttypes.h</h1><p>c99提供了两个头文件 stdint.h 和 inttypes.h 以确保 C语言的类型在各系统中的功能相同。</p><p>C语言为现有类型创建了很多类型名。</p><ol><li>精确宽度整数类型 int32_t</li><li>最小宽度类型 int_least8_t</li><li>最快的类型 int_fast8_t</li><li>最大的有符号整数类型 intmax_t</li></ol><p>printf() 打印特定类型时要求与相应的转换说明匹配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt; //支持可移植整数类型名</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int32_t</span> me32;  <span class="comment">//me32是一个32位有符号整型变量</span></div><div class="line">me32=<span class="number">45933945</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>,me32);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%"</span> PRId32<span class="string">""</span>,me32); <span class="comment">//PRId32字符串宏</span></div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>printf(“%” PRId32””,me32);<br>等价于 printf(“%”d””,me32);</p><blockquote><p>c99/c11 的支持中，一些编译器任未实现 inttypes.h 头文件及其相关功能</p></blockquote><p><a href="http://blog.csdn.net/zhoudaxia/article/details/4704766" target="_blank" rel="external">扩展整数类型stdint.h和inttypes.h</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bool类型&quot;&gt;&lt;a href=&quot;#Bool类型&quot; class=&quot;headerlink&quot; title=&quot;_Bool类型&quot;&gt;&lt;/a&gt;_Bool类型&lt;/h1&gt;&lt;p&gt;c99标准添加了 _Bool 类型，用于表示布尔值（true 和 false）。因为 C 语言用值 1 
      
    
    </summary>
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习(三)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/04/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E4%B8%89/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/04/C语言复习-三/</id>
    <published>2017-11-04T13:44:17.000Z</published>
    <updated>2017-11-05T15:14:31.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用字符-char-类型"><a href="#使用字符-char-类型" class="headerlink" title="使用字符: char 类型"></a>使用字符: char 类型</h2><p>char 类型存储字符(8位存储单元)，从技术层面看，char 是整数类型。ASCII(0~127;只需 8 位的存储单元) 编码 比如：A用整数 65 代表。因此，存储字母 A 实际上存储的是整数 65</p><p><strong>字符常量和初始化</strong></p><p>如果要把一个字符常量初始化为字母A，不必背下 ASCII 码。用单引号括起来的单个字符被称为字符常量，编译器一发现’A’，就会将其转换成相应的代码值。单引号必不可少<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> abc; <span class="comment">//声明char 类型</span></div><div class="line">abc=<span class="string">'A'</span> <span class="comment">//正确</span></div><div class="line">abc=A <span class="comment">//错误 A 现在是一个变量；</span></div><div class="line">abc=<span class="string">"A"</span> <span class="comment">//错误 A 现在是一个字符串</span></div></pre></td></tr></table></figure></p><p><strong>非打印字符</strong><br>单引号只适用于字符、数字、标点符号</p><ol><li><p>使用 ASCII<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fl6gzyk6k6j30t30ki4qp.jpg" alt=""></p></li><li><p>转义序列<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fl6gyn2gecj30q60dwwgp.jpg" alt=""></p></li></ol><p>打印警报<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">char</span> a;</div><div class="line">a=<span class="string">'\a'</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,a); <span class="comment">//打印峰鸣声</span></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>%c 和 %d</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fl6hu2dioqj30gm09r0tm.jpg" alt=""></p><p><strong>有符号还是无符号</strong></p><ul><li>有些 C编译器把 char 实现为有符号类型，表示范围 -128~127</li><li>有些 C编译器把 char 实现为无符号类型，表示范围 0~255</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用字符-char-类型&quot;&gt;&lt;a href=&quot;#使用字符-char-类型&quot; class=&quot;headerlink&quot; title=&quot;使用字符: char 类型&quot;&gt;&lt;/a&gt;使用字符: char 类型&lt;/h2&gt;&lt;p&gt;char 类型存储字符(8位存储单元)，从技术层面看，c
      
    
    </summary>
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习(二)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/03/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0-%E4%BA%8C/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/03/C语言复习-二/</id>
    <published>2017-11-03T08:01:33.000Z</published>
    <updated>2017-11-11T10:20:34.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="其他整数类型"><a href="#其他整数类型" class="headerlink" title="其他整数类型"></a>其他整数类型</h2><p><strong>修饰基本整数类型</strong></p><ol><li>short</li><li>long</li><li>unsigned</li></ol><ul><li>short int 或者 short 占用存储空间可能比 int 类型少</li><li>long int 或者 long 占用存储空间比 int 多</li><li>long long int 或 long long (C99标准加入) 占用的存储空间可能比 long 多。至少占用 64 位。</li><li>unsigned int 或 unsigned 只用于非负数的场合。例如 16位 unsigned int 允许取值范围是 0~65535 ，而不是 -32768~32767 。</li></ul><p><strong>使用多种整数类型的原因</strong></p><ol><li>C语言规定了 short 占用的存储空间不能多于 int</li><li>long 占用的存储空间不能少于 int</li></ol><blockquote><p>这样的规定是为了适应不同的机器。例如：早期电脑中 int 和 short<br> 类型都占 16 位，long 类型占 32，后来系统都是用 16位存储 short 类型。32位存储 int 类型和 long 类型。现在，计算机普遍为 64 位处理器，为了存储 64 位的整数，才引入了 long long 整型</p></blockquote><p> 现在个人计算机最常见的设置是:</p><ol><li>long long 占 64 位</li><li>long 占 32位</li><li>short 占 16位</li><li><p>int 占 16位或者 32位(依计算机的自然字长而定)</p><p>原则上，这 4 种类型代表 4 种不同的大小，但是实际使用中，有些类型之间通常有重叠</p></li></ol><blockquote><p>对于 16 位机，short 和 int 的最小取值范围是 [-32767,32767]</p><p>对于 32 位机, long 的最小取值范围 [-2147483647,2147483647]</p><p>unsigned int 和 unsigned short 最小取值范围是[0,65535]</p><p>unsigned long 最小取值范围 [0,4294967295]</p><p>对于 64位 long long 类型比较大，就不说了</p></blockquote><p> <strong>long 常量和 long long 常量</strong></p><p>当整型存储的数值很大，编译器会一次尝试使用：</p><ol><li>unsigned int</li><li>long</li><li>unsigned long</li><li>long long</li><li>unsigned long long</li></ol><blockquote><p>如果要把一个较小的常量当做 long 类型。在值得末尾加上l或L</p></blockquote><p><strong>整数溢出 </strong></p><p>如果整数超出类型的取值范围会怎么样？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> i=<span class="number">2147483647</span>;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">4294967295</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d \n"</span>,i,i+<span class="number">1</span>,i+<span class="number">2</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%u %u %u \n"</span>,j,j+<span class="number">1</span>,j+<span class="number">2</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fl508o9vw1j30ad02q745.jpg" alt=""></p><p><strong>打印 short、long、long long和 unsigned</strong></p><ol><li>打印 unsigned 类型的值，使用 %u 转换说明</li><li>打印 long 类型的值，使用 %ld 转换说明</li><li>打印 short 类型的值，%hd 表示以十进制显示 short 类型的整数</li><li>对于 long long 类型，%lld 和%llu 分别表示有符号和无符号类型</li></ol><p>具体代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> un = <span class="number">3000000000</span>;<span class="comment">//int 为 32 位 short 为16 位的系统</span></div><div class="line"><span class="keyword">short</span> end =<span class="number">200</span>;</div><div class="line"><span class="keyword">long</span> big = <span class="number">65537</span>;</div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> verybig=<span class="number">12345678909</span>;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"un = %u and not %d\n"</span>,un,un);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"end = %hd and end %d\n"</span>,end,end);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"big = %ld and big %hd\n"</span>,big,big);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"verybig = %lld and not %ld\n"</span>,verybig,verybig);</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fl50q1a0gkj30cn04cmx7.jpg" alt=""></p><blockquote><p>在使用 printf() 函数时，切记检查每一个待打印都有对应的转换说明，还要检查转换说明的类型是否与待打印值得类型相匹配</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;其他整数类型&quot;&gt;&lt;a href=&quot;#其他整数类型&quot; class=&quot;headerlink&quot; title=&quot;其他整数类型&quot;&gt;&lt;/a&gt;其他整数类型&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;修饰基本整数类型&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;short&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>自我反思(17-11-2)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/11/02/%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D-17-11-2/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/11/02/自我反思-17-11-2/</id>
    <published>2017-11-02T13:36:30.000Z</published>
    <updated>2017-11-02T13:55:01.336Z</updated>
    
    <content type="html"><![CDATA[<p>这两个星期，可能因为面试的事情，没有过多的时间去学习，今天可以算告别面试，最近的事情比较多，需要思考这一段时间出现的问题，以及对以后的路进行反思。</p><p><strong>技术是王道</strong></p><p>不管你的简历排版有多好，在技术面试的时候总是谈的技术，所以技术才是王道，其他的只不过是给你添加加分项，毕竟一个企业招人，还是为了招能做事的人，能为这个企业带来利益的员工，一般学生素质都差不多，唯一不同的就是学习能力的多少。</p><p><strong>学历很重要</strong></p><p>不管技术有多强，这个社会总是人外有人，天外有天，学历就是把人化成了三流九等，问题不在于我们排斥这样的社会现状，而是对自己能力的一个质疑，如果比别人弱，我们到底弱到那里，为什么会产生这样的差异，一般来说人都是很了解自己的，唯一不同的是不同的人自制力不同，越是自制力强的人，做事越有条理性。专科的自己，如果现在就职了，很可能一旦跳槽就会面临学历太低，年龄太高，对方不想要的情况，我想自己现在还是又能力继续深造，如果现在放弃了，以后可能就没机会了，毕竟社会的有色眼镜太多。</p><p><strong>社会情况</strong></p><p>通过这次面试，大概了解了目前还是缺 java 工程师，Android 火爆的情况已经成为过去式，java 那么多年技术也走向成熟了，虽然新兴语言也有些不错，可能目前使用还不够普及，以及文档还不够完善。所以目前需要学习 java 相关的一些知识。当然其他的也不能拉下。</p><p><strong>对自己说的</strong></p><p>不管以后有多难找工作，在校的时候，坚持学习总是没有错的，我们在学习技术同时，也要关注未来的一个趋势，比较我们需要同过自己喜欢的技术养活自己，才能在这条路上走得更远，要想出了社会让别人尊重自己，就需要先让自己变得很强大，接下来的日子里，需要以专升本为主学习，并把比赛的事情好好准备，空闲的时间  看一下 java 和 算法 、数据结构的知识，先打好地基，否则很难有太高的成就。</p><p><strong>作息时间安排</strong></p><p>这两个星期，没有很好的安排作息时间，很明显感到身体的疲惫，今天上去谈 offer 吐了三次，熬夜还是不要了，以后要想过得很好，还得需要很长的一段路去走，坚持！！！ 总有一天实现梦想！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这两个星期，可能因为面试的事情，没有过多的时间去学习，今天可以算告别面试，最近的事情比较多，需要思考这一段时间出现的问题，以及对以后的路进行反思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术是王道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不管你的简历排版有多好，在技术面试的时候总是谈的技术
      
    
    </summary>
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Android-Gson学习</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/30/Android-Gson%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/30/Android-Gson学习/</id>
    <published>2017-10-30T02:51:26.000Z</published>
    <updated>2017-10-31T07:21:39.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h1><p>Gson 是 google 推出的工具库(JSON解析库)。不用写任何解析代码，Gson 就能自动把 JSON 数据映射到 Java 对象</p><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://github.com/google/gson/blob/master/UserGuide.md" target="_blank" rel="external">官方用户指南</a></p><h1 id="使用-Gson"><a href="#使用-Gson" class="headerlink" title="使用 Gson"></a>使用 Gson</h1><p><a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Using-Gson" target="_blank" rel="external">官方使用指南</a></p><ol><li><p>导入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile <span class="string">'com.google.code.gson:gson:2.8.2'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>Gson 基本用法</p></li></ol><p><strong>创建 Gson 对象</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Gson gson=<span class="keyword">new</span> Gson();</div></pre></td></tr></table></figure></p><p><strong>主要用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Serialization(序列化)</span></div><div class="line">Gson gson = <span class="keyword">new</span> Gson();</div><div class="line">gson.toJson(<span class="number">1</span>);            <span class="comment">// ==&gt; 1</span></div><div class="line">gson.toJson(<span class="string">"abcd"</span>);       <span class="comment">// ==&gt; "abcd"</span></div><div class="line">gson.toJson(<span class="keyword">new</span> Long(<span class="number">10</span>)); <span class="comment">// ==&gt; 10</span></div><div class="line"><span class="keyword">int</span>[] values = &#123; <span class="number">1</span> &#125;;</div><div class="line">gson.toJson(values);       <span class="comment">// ==&gt; [1]</span></div><div class="line"></div><div class="line"><span class="comment">// Deserialization(反序列化)</span></div><div class="line"><span class="keyword">int</span> one = gson.fromJson(<span class="string">"1"</span>, <span class="keyword">int</span>.class);</div><div class="line">Integer one = gson.fromJson(<span class="string">"1"</span>, Integer.class);</div><div class="line">Long one = gson.fromJson(<span class="string">"1"</span>, Long.class);</div><div class="line">Boolean <span class="keyword">false</span> = gson.fromJson(<span class="string">"false"</span>, Boolean.class);</div><div class="line">String str = gson.fromJson(<span class="string">"\"abc\""</span>, String.class);</div><div class="line">String[] anotherStr = gson.fromJson(<span class="string">"[\"abc\"]"</span>, String[].class);</div></pre></td></tr></table></figure><p>toJson()：用于将Java对象转换为相应的JSON数据<br><br>fromJson：用于将JSON数据转换为相应的Java对象<br></p><p><strong>对象用法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BagOfPrimitives</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value1 = <span class="number">1</span>;</div><div class="line">  <span class="keyword">private</span> String value2 = <span class="string">"abc"</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> value3 = <span class="number">3</span>;</div><div class="line">  BagOfPrimitives() &#123;</div><div class="line">    <span class="comment">// no-args constructor</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Serialization(序列化)</span></div><div class="line">BagOfPrimitives obj = <span class="keyword">new</span> BagOfPrimitives();</div><div class="line">Gson gson = <span class="keyword">new</span> Gson();</div><div class="line">String json = gson.toJson(obj);  </div><div class="line"></div><div class="line"><span class="comment">// ==&gt; json is &#123;"value1":1,"value2":"abc"&#125;</span></div><div class="line"></div><div class="line"><span class="comment">//Deserialization(反序列化)</span></div><div class="line">BagOfPrimitives  obj2=gson.fromJson(json,BagOfPrimitives.class);</div></pre></td></tr></table></figure></p><p><strong>数组用法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Gson gson = <span class="keyword">new</span> Gson();</div><div class="line"><span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line">String[] strings = &#123;<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Serialization序列化</span></div><div class="line">gson.toJson(ints);     <span class="comment">// ==&gt; [1,2,3,4,5]</span></div><div class="line">gson.toJson(strings);  <span class="comment">// ==&gt; ["abc", "def", "ghi"]</span></div><div class="line"></div><div class="line"><span class="comment">// Deserialization反序列化</span></div><div class="line"><span class="keyword">int</span>[] ints2 = gson.fromJson(<span class="string">"[1,2,3,4,5]"</span>, <span class="keyword">int</span>[].class);</div><div class="line"><span class="comment">// ==&gt; ints2 will be same as ints  json原先是数组对象，反序列化为java数组对象</span></div></pre></td></tr></table></figure></p><p><strong>集合用法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Gson gson = <span class="keyword">new</span> Gson();<span class="comment">//创建 Gson 对象</span></div><div class="line">Collection&lt;Integer&gt; ints = Lists.immutableList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); <span class="comment">//创建一个int 的集合清单后面表示，创建一个不可变集合</span></div><div class="line"><span class="comment">// Serialization</span></div><div class="line">String json = gson.toJson(ints);  <span class="comment">// ==&gt; json is [1,2,3,4,5]</span></div><div class="line"></div><div class="line"><span class="comment">// Deserialization</span></div><div class="line">Type collectionType = <span class="keyword">new</span> TypeToken&lt;Collection&lt;Integer&gt;&gt;()&#123;&#125;.getType();</div><div class="line">Collection&lt;Integer&gt; ints2 = gson.fromJson(json, collectionType);</div><div class="line"><span class="comment">// ==&gt; ints2 is same as ints</span></div></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/dyllove98/article/details/9246757" target="_blank" rel="external">关于   immutable</a><br><br><a href="http://blog.csdn.net/gtkknd/article/details/50890341" target="_blank" rel="external">关于 TypeToken</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Gson&quot;&gt;&lt;a href=&quot;#Gson&quot; class=&quot;headerlink&quot; title=&quot;Gson&quot;&gt;&lt;/a&gt;Gson&lt;/h1&gt;&lt;p&gt;Gson 是 google 推出的工具库(JSON解析库)。不用写任何解析代码，Gson 就能自动把 JSON 数据映射到 
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-处理 JSON数据(PhotoGallery应用)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/29/Android-%E5%A4%84%E7%90%86-JSON%E6%95%B0%E6%8D%AE/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/29/Android-处理-JSON数据/</id>
    <published>2017-10-29T14:00:21.000Z</published>
    <updated>2017-10-30T02:53:27.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解析-JSON-数据"><a href="#解析-JSON-数据" class="headerlink" title="解析 JSON 数据"></a>解析 JSON 数据</h1><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkzgwvu6zzj30lp0egmy4.jpg" alt=""></p><p>这是通过使用 google 插件 postman 排好的格式</p><blockquote><p>json.org API 提供有对应 JSON 数据的 Java 对象如 JSONObject 和 JSONArray。 使用 JSONObject(String) 构造函数，可以把 JSON 数据解析进相应的 Java 对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSONObject jsonObject=<span class="keyword">new</span> JSONObject(jsonString);</div></pre></td></tr></table></figure><p>当将 json 字符串传入 JSONObject 对象后,会生成与原始 JSON 数据对应的对象树,如上图。</p><p><strong>获取对应图片的信息并创建模型类</strong><br>创建 GalleryItems ,并在网络类创建一个方法获取每张图片信息，需要获取的信息为模型类的字段</p><ol><li>id</li><li>title</li><li>url_s</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建 parseItems() 获取 json字符串中我们想获得的并添加给 模型层*/</span></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseItems</span><span class="params">(List&lt;GalleryItem&gt; items, JSONObject jsonObject)</span> <span class="keyword">throws</span> JSONException </span>&#123;</div><div class="line"><span class="comment">//        获取 JSONObject</span></div><div class="line">       JSONObject jsonObject1 = jsonObject.getJSONObject(<span class="string">"photos"</span>);</div><div class="line"><span class="comment">//        获取对象里面的数组</span></div><div class="line">       JSONArray jsonArray = jsonObject1.getJSONArray(<span class="string">"photo"</span>);</div><div class="line"></div><div class="line"><span class="comment">//        循环遍历找出每一个对应的标题和id</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= jsonArray.length(); i++) &#123;</div><div class="line"><span class="comment">//            获取每一个 JSONObject 对象</span></div><div class="line">           JSONObject eachJSONObject=jsonArray.getJSONObject(i);</div><div class="line"><span class="comment">//            创建一个模型层的类，用于添加信息</span></div><div class="line">           GalleryItem item= <span class="keyword">new</span> GalleryItem();</div><div class="line">           item.setId(eachJSONObject.getString(<span class="string">"id"</span>));</div><div class="line">           item.setCaption(eachJSONObject.getString(<span class="string">"title"</span>));</div><div class="line"><span class="comment">//            检查 是否有 url_s 的键</span></div><div class="line">           <span class="keyword">if</span>(!eachJSONObject.has(<span class="string">"url_s"</span>))&#123;</div><div class="line">               <span class="keyword">continue</span>;</div><div class="line">           &#125;</div><div class="line">           item.setUrl(eachJSONObject.getString(<span class="string">"url_s"</span>));</div><div class="line">           items.add(item);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>创建 ViewHolder 和 Adapter 内部类 实现 RecyclerView 的视图以及数据加载(代码部分省略)</p><h1 id="从-AsyncTask-回到主线程"><a href="#从-AsyncTask-回到主线程" class="headerlink" title="从 AsyncTask 回到主线程"></a>从 AsyncTask 回到主线程</h1><blockquote><p>我们需要注意的是在后台我们获取了数据，需要把数据适配到前台中，不能再后台线程中调用设置适配器。在计算机里，内存对象间步调不一致冲突会让应用崩溃，所以不允许从后台更新 UI 线程</p></blockquote><p><a href="http://blog.didiaoyuan.com/2017/05/07/AsyncTask-%E5%92%8C-AsyncTaskLoader-%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">回顾AsyncTask</a></p><p>使用 onPostExecute(Result)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个 AsyncTask 的内部类，后台处理网络*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchItemsTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">List</span>&lt;<span class="title">GalleryItem</span>&gt;&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> List&lt;GalleryItem&gt; <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//            获取网络中的String 数据</span></div><div class="line">        <span class="comment">/* String result = new FlickerFerchr()</span></div><div class="line"><span class="comment">                 .getUrlString("http://www.bignerdranch.com");</span></div><div class="line"><span class="comment">//                log 显示 String</span></div><div class="line"><span class="comment">         Log.i("TAG","Fetched contents of URL:+"+result);*/</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FlickerFerchr().fetchItems();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(List&lt;GalleryItem&gt; items)</span> </span>&#123;</div><div class="line">        mItems = items;</div><div class="line">        setupAdapter();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行结果</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fl024mq7k5j30aa0g8q4q.jpg" alt=""></p><h1 id="清理-AsyncTask"><a href="#清理-AsyncTask" class="headerlink" title="清理 AsyncTask"></a>清理 AsyncTask</h1><blockquote><p>一开始我们保留了 fragment(调用了 setRetainInstance(true) )，这样即使设备旋转，也不会重复创建新的 AsyncTask 去获取 JSON 数据。但是有些时候必须掌控它，让他能够随时撤销或重新运行 AsyncTask</p></blockquote><p><strong>AsyncTask.cancel(boolean)撤销</strong></p><ol><li>温和的(false)</li><li>粗暴的(true)</li></ol><p>第一种，传入参数为 false ,它可能温和的设置 isCancel() 的状态，然后提前结束运行</p><p>第二种,传入参数为 true ,它会粗暴地终止 doInBackground() 方法当前所在的线程，应尽量避免使用这种方式</p><p><strong>什么时候使用撤销?</strong></p><p>当 fragment 和 activity 已经销毁了或者看不到了，就在 onStop() 方法里(看不到视图)，或者 onDestory()方法里(fragment/activity) 实例已销毁撤销 AsyncTask 实例</p><blockquote><p>fragment 和 activity 已经销毁了 不去销毁 AsyncTask 可能引发内存泄漏,也可能出现 UI 更新问题</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解析-JSON-数据&quot;&gt;&lt;a href=&quot;#解析-JSON-数据&quot; class=&quot;headerlink&quot; title=&quot;解析 JSON 数据&quot;&gt;&lt;/a&gt;解析 JSON 数据&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>简单算法(三)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/27/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E4%B8%89/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/27/简单算法-三/</id>
    <published>2017-10-27T07:08:10.000Z</published>
    <updated>2017-10-27T13:41:37.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>思路:对一组数据找到一个基准数，用这个基准数做参考，小于它的放右边(左边)，大于它的放左边(右边),然后左右两边同样实现这样的排序,直到都符合规则</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkx47062nmj30i90htq9v.jpg" alt=""></p><blockquote><p>直接上原书的图《坐在马桶上学算法》</p></blockquote><p>算法难点:</p><ol><li>使用左右两边的数据</li><li>以左边的数作为基准数</li><li>先从右边开始找比基准数小的点(从大到小排序)</li><li>当右边找到比基准数小的点，左边找到比基准数大的点时，交换两个位置的值，然后继续</li><li>当左右两点位置相等时，将该位置点与左边 1 位置交换</li><li>左右两边分别重复上面的步骤，直到一边没有数据只剩下一个结束这样的循环</li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkx4x2qx4tj30lg0lddgq.jpg" alt=""></p><p>这是具体的一个交换流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="keyword">int</span> a[<span class="number">101</span>],n; <span class="comment">// 定义全局变量</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> i,j,t,temp;</div><div class="line"><span class="keyword">if</span>(left&gt;right)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">temp=a[left];<span class="comment">//temp 中存的就是基准数</span></div><div class="line">i=left;</div><div class="line">j=right;</div><div class="line"><span class="keyword">while</span>(i!=j)  <span class="comment">//两边不想交就一直循环</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span>(a[j]&gt;=temp&amp;&amp;i&lt;j)  <span class="comment">//顺序很重要 先从右边找</span></div><div class="line">&#123;</div><div class="line">j--;</div><div class="line"><span class="comment">//在找左边</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(a[i]&lt;=temp &amp;&amp; i&lt;j)</div><div class="line">&#123;</div><div class="line">i++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(i&lt;j)</div><div class="line">&#123;</div><div class="line">t=a[i];</div><div class="line">a[i]=a[j];</div><div class="line">a[j]=t;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// i等于j</span></div><div class="line">a[left]=a[i];   <span class="comment">//最左边为停止的数字</span></div><div class="line">a[i]=temp;    <span class="comment">//停止的为基准数</span></div><div class="line">quicksort(left,i<span class="number">-1</span>);   <span class="comment">//左边的继续</span></div><div class="line">quicksort(i+<span class="number">1</span>,right); <span class="comment">//右边的继续</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> x;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"请输入需要排序的个数:"</span>);</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line"><span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=n;x++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[x]);</div><div class="line">&#125;</div><div class="line">quicksort(<span class="number">1</span>,n); <span class="comment">//快速排序调用</span></div><div class="line"></div><div class="line"><span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=n;x++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[x]);</div><div class="line">&#125;</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行结果:<br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkx42itho0j30fo08d74f.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;思路:对一组数据找到一个基准数，用这个基准数做参考，小于它的放右边(左边)，大于它的放左边(右边),然后左右两边同样实现这样
      
    
    </summary>
    
      <category term="算法" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android 网络连接(PhotoGallery应用)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/27/Android-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/27/Android-网络连接/</id>
    <published>2017-10-27T06:59:44.000Z</published>
    <updated>2017-10-30T02:22:21.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本网络连接"><a href="#基本网络连接" class="headerlink" title="基本网络连接"></a>基本网络连接</h1><p>GitHub 地址:<a href="https://github.com/LowApe/PhotoGallery" target="_blank" rel="external">关于联网显示图片的应用</a></p><p><strong>前期准备</strong></p><blockquote><p>fragment + recyclerView 实现基本框架，这就不说了，前面有介绍过，没总结过 http 与后台的知识</p></blockquote><p><strong>设置网络类</strong></p><ol><li>创建一个类，并实现两个方法分别用来获取数据的字节流并把字节流转化为字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlickerFerchr</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getUrlBytes(String urlSpec) <span class="keyword">throws</span> IOException &#123;</div><div class="line"><span class="comment">//        创建 URL 对象将 url 字符串转换为URL</span></div><div class="line">        URL url = <span class="keyword">new</span> URL(urlSpec);</div><div class="line">        <span class="comment">//        创建连接</span></div><div class="line">        HttpURLConnection connection = (HttpURLConnection) url.openConnection();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//        实例化字节流</span></div><div class="line">            ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"><span class="comment">//        getInputStream() 连接</span></div><div class="line">            InputStream in = connection.getInputStream();</div><div class="line"><span class="comment">//        判断是否连接成功</span></div><div class="line">            <span class="keyword">if</span> (connection.getResponseCode()!=HttpURLConnection.HTTP_OK)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(connection.getResponseMessage()+<span class="string">"with:"</span>+urlSpec);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">int</span> bytesRead=<span class="number">0</span>;</div><div class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="comment">//        循环读取,读取一定数量字节放入缓存区数组buffer，并以整数形式返回实际读取的字节数</span></div><div class="line">            <span class="keyword">while</span> ((bytesRead=in.read(buffer))&gt;<span class="number">0</span>)&#123;</div><div class="line">                out.write(buffer,<span class="number">0</span>,bytesRead);</div><div class="line">            &#125;</div><div class="line"><span class="comment">//        关闭输出流</span></div><div class="line">            out.close();</div><div class="line">            <span class="keyword">return</span> out.toByteArray();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            connection.disconnect();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrlString</span><span class="params">(String urlSpec)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(getUrlBytes(urlSpec));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>获取网络使用权限</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span>/&gt;</span></div></pre></td></tr></table></figure><hr><h1 id="使用-AsyncTask-在后台线程上运行代码"><a href="#使用-AsyncTask-在后台线程上运行代码" class="headerlink" title="使用 AsyncTask 在后台线程上运行代码"></a>使用 AsyncTask 在后台线程上运行代码</h1><blockquote><p>我们前面都是使用的 UI 线程，当进行网络访问的等操作，如果还在 UI 线程上，会出现程序不响应，是否结束任务的提示，所以使用 AsyncTask 工具类创建一个后台线程处理网络请求</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个 AsyncTask 的内部类，后台处理网络*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchItemsTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>,<span class="title">Void</span>,<span class="title">Void</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</div><div class="line"><span class="comment">//            获取网络中的String 数据</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String result = <span class="keyword">new</span> FlickerFerchr()</div><div class="line">                    .getUrlString(<span class="string">"http://www.bignerdranch.com"</span>);</div><div class="line"><span class="comment">//                log 显示 String</span></div><div class="line">            Log.i(<span class="string">"TAG"</span>,<span class="string">"Fetched contents of URL:+"</span>+result);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>启动后台线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//        执行AsyncTask</span></div><div class="line">        <span class="keyword">new</span> FetchItemsTask().execute();</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkx5w6nlmdj31cf07cdgw.jpg" alt=""></p><h1 id="线程与主线程"><a href="#线程与主线程" class="headerlink" title="线程与主线程"></a>线程与主线程</h1><p>网络连接需要时间。Web 服务器也需要时间响应请求，文件下载则需要更长的时间。Android 禁止任何主线程网络连接行为。如果 Android 也会抛出 NetworkOnMainThreadException 异常<br>线程：单一执行序列，单个线程代码会逐步执行。<br>Android 应用运行从主线程开始，但它并不是线程那样的预定执行序列。相反，它是一个无限循环的运行状态，等待用户或者系统触发的事件的发生。事件触发后,主线程便负责执行代码.</p><h1 id="从-Flickr-获取-JSON-数据"><a href="#从-Flickr-获取-JSON-数据" class="headerlink" title="从 Flickr 获取 JSON 数据"></a>从 Flickr 获取 JSON 数据</h1><blockquote><p>前面的网站虽然通过 web 可以进行访问，但是并没有返回我们可以使用时信息，我们通过 Flickr 提供的 JSON API 获取我们想要的信息，并显示到我们的应用上</p></blockquote><p>下面是我自己建立的，这个过程耗费我两天，因为flickr 创建的 key 一直不生效，最后发现是权限为私有，打开为公有还要上传照片、添加标签、添加 url 最后才能修改</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkzgiddxn3j30wo0k2h0k.jpg" alt=""></p><p>  <a href="https://api.flickr.com/services/rest/?method=flickr.photos.getRecent&amp;api_key=461a0d44890535444f94fd9d9643b6b6&amp;format=json&amp;nojsoncallback=1" target="_blank" rel="external">https://api.flickr.com/services/rest/?method=flickr.photos.getRecent&amp;api_key=461a0d44890535444f94fd9d9643b6b6&amp;format=json&amp;nojsoncallback=1</a></p><p>  <strong>构建 url</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/*创建一个构造url的方法*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fetchItems</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//            构建url 字符串供 getUrlString 方法使用</span></div><div class="line">    String url =Uri.parse(<span class="string">"https://api.flickr.com/services/rest/"</span>)</div><div class="line">    .buildUpon()</div><div class="line">    .appendQueryParameter(<span class="string">"method"</span>,<span class="string">"flickr.photos.getRecent"</span>)</div><div class="line">    .appendQueryParameter(<span class="string">"api_key"</span>,<span class="string">"461a0d44890535444f94fd9d9643b6b6"</span>)</div><div class="line">    .appendQueryParameter(<span class="string">"format"</span>,<span class="string">"json"</span>)</div><div class="line">    .appendQueryParameter(<span class="string">"nojsoncallback"</span>,<span class="string">"1"</span>)</div><div class="line">    .appendQueryParameter(<span class="string">"extras"</span>,<span class="string">"url_s"</span>)</div><div class="line">    .build().toString();</div><div class="line">    String jsonString=getUrlString(url);</div><div class="line">    Log.e(<span class="string">"TAG"</span>,<span class="string">"JSON: "</span>+jsonString);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>重新修改后台访问网络连接</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个 AsyncTask 的内部类，后台处理网络*/</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchItemsTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>,<span class="title">Void</span>,<span class="title">Void</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</div><div class="line"><span class="comment">//            获取网络中的String 数据</span></div><div class="line">            <span class="comment">/* String result = new FlickerFerchr()</span></div><div class="line"><span class="comment">                     .getUrlString("http://www.bignerdranch.com");</span></div><div class="line"><span class="comment">//                log 显示 String</span></div><div class="line"><span class="comment">             Log.i("TAG","Fetched contents of URL:+"+result);*/</span></div><div class="line">            <span class="keyword">new</span> FlickerFerchr().fetchItems();</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p><strong>Console 台显示 json 字符串</strong><br>  <img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkzg5rn77oj31cz0490tk.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本网络连接&quot;&gt;&lt;a href=&quot;#基本网络连接&quot; class=&quot;headerlink&quot; title=&quot;基本网络连接&quot;&gt;&lt;/a&gt;基本网络连接&lt;/h1&gt;&lt;p&gt;GitHub 地址:&lt;a href=&quot;https://github.com/LowApe/PhotoGall
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入学习: 进程与任务</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/27/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/27/深入学习-进程与任务/</id>
    <published>2017-10-27T03:37:36.000Z</published>
    <updated>2017-10-27T04:30:11.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与任务"><a href="#进程与任务" class="headerlink" title="进程与任务"></a>进程与任务</h1><ol><li><strong>对象</strong> 需要内存和虚拟机的支持才能存在</li><li><strong>进程</strong> 是操作系统创建的、供应用对象生存以及应用运行的地方</li><li><strong>进程</strong> 通常占用系统的资源，如内存、网络接口、打开的文件·进程拥有至少一个(可能多个)执行线程。</li><li>在 Android 系统中, <strong>进程</strong> 总会有一个运行的虚拟机</li><li>Android 世界里的每个应用组件都仅与一个进程相关联。应用伴随着自己的进程一并创建,该进程同时也是应用中所以组件的默认进程</li><li>每个 activity 实例都仅存在于一个进程和一个任务中。</li><li>任务只包含 activity,这些 activity 通常来自于不同的应用</li><li>而 <strong>进程</strong> 则包含应用的全部代码和对象</li></ol><h1 id="进程与任务的区别"><a href="#进程与任务的区别" class="headerlink" title="进程与任务的区别"></a>进程与任务的区别</h1><p><strong>实例1:</strong></p><ol><li>当启动一个应用的同时会创建与之对应的进程</li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkwoirrubmj30gj076aa1.jpg" alt=""></p><ol><li>当应用中设置了跳转到其他应用的操作，比如联系人 activity 会被添加到这个应用的任务中,然而它也创建了一个联系人应用的进程，当用户后退在不同 activity 间切换过程中，可能不会意识到他们正在进程间的切换</li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkwoncmmx4j30qg0djwez.jpg" alt=""></p><p><strong>实例2:</strong></p><ol><li>情况android 的所有应用，然后启动这个应用，重复启动联系人应用，然后按主屏幕键回到主屏幕点击联系人应用，并添加联系人实例，关系如下图</li></ol><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkwowssvqyj30wi0iyab4.jpg" alt=""></p><p>通过这两个实例可以看出 任务可以说是进程的分支，进程的概念比任务要大，通常任务管理器结束的任务，其实是关于这个应用的进程</p><blockquote><p>下面是别人写的我认为说的很好，可能没有学过操作系统，关于这方面的知识比较欠缺，理解能力也有限，以后会学习这方面的知识</p></blockquote><p><a href="http://blog.csdn.net/yiyaaixuexi/article/details/6232993" target="_blank" rel="external">相关链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进程与任务&quot;&gt;&lt;a href=&quot;#进程与任务&quot; class=&quot;headerlink&quot; title=&quot;进程与任务&quot;&gt;&lt;/a&gt;进程与任务&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt; 需要内存和虚拟机的支持才能存在&lt;/li&gt;
&lt;li&gt;&lt;strong
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>解析 Intent(二)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/25/%E8%A7%A3%E6%9E%90-Intent-%E4%BA%8C/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/25/解析-Intent-二/</id>
    <published>2017-10-25T13:11:03.000Z</published>
    <updated>2017-10-27T02:54:58.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前一节利用 PackageManager 查询系统所以有 Main 的 Activity,显示实现点击后进入各应用,创建显式 Intent 进行打开。</p></blockquote><ol><li>创建监听器</li><li>ResolveInfo 对象获取 activity 的包名与类名 。从 ResolveInfo 对象的 ActivityInfo 中获取</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</div><div class="line"><span class="comment">//            从 ResolveInfo 获取包名或类名</span></div><div class="line">    ActivityInfo activityInfo=mResolveInfo.activityInfo;</div><div class="line"><span class="comment">//            创建 Intent 对象</span></div><div class="line">    Intent i=<span class="keyword">new</span> Intent(Intent.ACTION_MAIN)</div><div class="line">            .setClassName(activityInfo.applicationInfo.packageName,activityInfo.name);</div><div class="line"><span class="comment">//            启动 Intent</span></div><div class="line">    startActivity(i);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkut9i7g5hg30ct0nv7g4.gif" alt=""></p><h1 id="任务与后退栈"><a href="#任务与后退栈" class="headerlink" title="任务与后退栈"></a>任务与后退栈</h1><p>任务:通俗讲就是用户关心的 activity栈，当我们点击打开一个应用就将主 activity弹到栈顶，用户看到的是栈顶，当我们点击后退键，回到系统主屏幕</p><p><strong>通过几个场景理解任务与栈</strong></p><p>场景1：我们点开应用在应用中点击启动不同的 activity 返回键总是能返回到我们上一个页面，这就是 activity 栈</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkutxh7i1ej31c40aqq3d.jpg" alt=""></p><p>场景2：任务键的切换，玩过 Android 的用过</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkutz0hh18j30ax0k6gp0.jpg" alt=""></p><p>场景3：可能会想到底要说什么 o(╥﹏╥)o 说明这个自动其他应用的任务与栈与其他的不同：当我们在这个应用点击其他应用，应该会两个任务事实上当启动其他的 activity栈 添加到了自己的任务中</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkuu3hc0t2j30om0ab3ym.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkuu8o1fw6g30ct0nvh1j.gif" alt=""></p><p>如果我们需要在启动新任务的 activity ，可以让应用拥有自己的任务，用户可以在运行的应用间自由切换，需要给 Intent 添加一个标志，作用是告诉系统我要让启动的activity 创建一个任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent i=<span class="keyword">new</span> Intent(Intent.ACTION_MAIN)</div><div class="line">                  .setClassName(activityInfo.applicationInfo.packageName,activityInfo.name)</div><div class="line">                  .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkuuci2y1tj30a30hx0uy.jpg" alt=""></p><h1 id="让-NerdLauncher-应用-作为设备主屏幕"><a href="#让-NerdLauncher-应用-作为设备主屏幕" class="headerlink" title="让 NerdLauncher 应用 作为设备主屏幕"></a>让 NerdLauncher 应用 作为设备主屏幕</h1><blockquote><p>这好比 是吧这个应用设置为主屏幕，其他应用返回的 栈底部 activty ,一般设置为主屏幕的为主题应用。</p></blockquote><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkuuhb8sulj31680hbadn.jpg" alt=""></p><p>现在你的手机主题 就是这个应用了。如果不小心设置了可以点击 Setting 应用——&gt; Apps——&gt; 选择这个应用请出默认 ——&gt; 点击主屏幕 选择系统，然后删除该应用</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkuui4w6baj30b00mb778.jpg" alt=""></p><h1 id="获取各个应用的图标"><a href="#获取各个应用的图标" class="headerlink" title="获取各个应用的图标"></a>获取各个应用的图标</h1><p>ResolveInfo.loadLabel() 方法获取各个 activity 名称,ResolveInfo还提供 loadIcon() 的方法,为每个应用加载显示图标</p><ol><li>创建布局模板 list_item (一个视图一个文本)</li><li>ViewHolder 使用这个布局加载</li><li>实例化两个控件</li><li>包名前面通过 loadLabel() 方法获取 现在通过 loadIcon() 获取图标<br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkwlspjkh1j30am0j6413.jpg" alt=""></li></ol><blockquote><p>这个很简单就不上代码了。</p></blockquote><p>本应用 GtiHub 地址:<a href="https://github.com/LowApe/NerdLauncher" target="_blank" rel="external">NerdLauncher 应用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前一节利用 PackageManager 查询系统所以有 Main 的 Activity,显示实现点击后进入各应用,创建显式 Intent 进行打开。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;创建监听器&lt;/li&gt;
&lt;li&gt;Resolv
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>简单算法(二)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/25/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E4%BA%8C/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/25/简单算法-二/</id>
    <published>2017-10-25T02:43:29.000Z</published>
    <updated>2017-10-25T09:11:04.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><blockquote><p>针对前一节讲的 “桶排序” 的问题，当我们处理很大的数据，如：0~200000000，这种范围的数据，需要申请一个 200000000 的变量：这种非常浪费空间！，如果要进行小数的排序，显然这种”桶排序” 是无法解决这些问题的，接下来介绍冒泡排序</p></blockquote><p>基本思想：每次比较两个相邻的元素,如果他们的顺序不对(就是不符合这样排序的)就把他们交换过来。</p><p>“冒泡排序” 原理是:每一趟只能确定将一个数归位。如果有 n 个数进行排序，就需要进行 n-1 趟.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//定义输入的个数最多有多少个</span></div><div class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i,j,t,n;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"请输入你想排序的个数:"</span>);</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line"><span class="comment">//循环 n 个数到数组中</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//n个数的排序，只进行 n-1 次</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</div><div class="line">&#123;<span class="comment">//这个 for 循环进行比较的次数 比如： 三个数 第一趟： 比较 3-1次 第二趟：3-2</span></div><div class="line"><span class="comment">// j表示的是数的位置</span></div><div class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n-i;j++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(a[j]&lt;a[j+<span class="number">1</span>])</div><div class="line">&#123;</div><div class="line">t=a[j];</div><div class="line">a[j]=a[j+<span class="number">1</span>];</div><div class="line">a[j+<span class="number">1</span>]=t;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出结果</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</div><div class="line">&#125;</div><div class="line">getchar();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkulvdlm3cj30b505tt8q.jpg" alt=""></p><p>如何实现带有姓名和分数的排序？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">char</span> name[<span class="number">21</span>];</div><div class="line"><span class="keyword">char</span> score;</div><div class="line">&#125;; <span class="comment">//创建结构体储存姓名和分数</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">a</span>[100],<span class="title">t</span>;</span></div><div class="line"><span class="keyword">int</span> i, j , n;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"请输入要排序的数目: \n"</span>);</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line"><span class="comment">//循环读入姓名和分数</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,a[i].name,&amp;a[i].score);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//循环遍历的趟数</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i;j++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">if</span>(a[j].score&lt;a[j+<span class="number">1</span>].score)</div><div class="line">&#123;</div><div class="line">t=a[j];</div><div class="line">a[j]=a[j+<span class="number">1</span>];</div><div class="line">a[j+<span class="number">1</span>]=t;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出排序后的名字</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>,a[i].name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkulugrwduj30cm08kwen.jpg" alt=""></p><blockquote><p>冒泡排序的核心部分是双重嵌套循环。时间复杂度 O(N2) 下一节 –快速排序</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;针对前一节讲的 “桶排序” 的问题，当我们处理很大的数据，如：0~200000000，这种范围的数
      
    
    </summary>
    
      <category term="算法" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>解析 Intent</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/24/%E8%A7%A3%E6%9E%90-Intent/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/24/解析-Intent/</id>
    <published>2017-10-24T06:00:55.000Z</published>
    <updated>2017-10-24T10:32:06.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>应用获取设备上的可启动应用，会使用 PackageManager 获取所有可启动主 activity。你可能会发现每一个应用都有一个主启动 activity 在注册清单上都有如下</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div></pre></td></tr></table></figure><p>新增 setupAdapter() 方法 负责隐式 intent 并从 PackageManager 那里获取匹配它的所有 activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//        创建一个隐式 Intent 添加分类选择</span></div><div class="line">       Intent startupIntent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</div><div class="line">       startupIntent.addCategory(Intent.CATEGORY_LAUNCHER);</div><div class="line"></div><div class="line">       PackageManager pm = getActivity().getPackageManager();</div><div class="line"><span class="comment">//        利用 pm 查询所有 startupIntent 的 activity 返回给 list 列表</span></div><div class="line">       List&lt;ResolveInfo&gt; activities = pm.queryIntentActivities(startupIntent, <span class="number">0</span>);</div><div class="line"><span class="comment">//        log 打印含有多少个 activities</span></div><div class="line">       Log.i(TAG, <span class="string">"activities have ："</span>+activities.size());</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>通过 ResolveInfo 对象中，可以获取 activity， ResolveInfo这个类是通过解析一个与IntentFilter相对应的intent得到的信息。它部分地对应于从AndroidManifest.xml的&lt; intent&gt;标签收集到的信息。</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fktifs0q3pj30sl03aweq.jpg" alt=""></p><p>我们通过 log 可以看到我们获取的 activity 现在我们完善 RecyclerView 实现数据与视图的绑定</p><p><strong>ViewHolder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*ViewHolder 内部类显示标签名*/</span></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</div><div class="line">        <span class="comment">//        创建引用信息加载获取用户标签</span></div><div class="line">        <span class="comment">//        初始化显示控件</span></div><div class="line">        <span class="keyword">private</span> ResolveInfo mResolveInfo;</div><div class="line">        <span class="keyword">private</span> TextView mNameTextView;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ActivityHolder</span><span class="params">(View itemView)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(itemView);</div><div class="line">            mNameTextView = (TextView) itemView;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindActivity</span><span class="params">(ResolveInfo resolveInfo)</span> </span>&#123;</div><div class="line">            mResolveInfo = resolveInfo;</div><div class="line">            PackageManager pm = getActivity().getPackageManager();</div><div class="line">            String appName=mResolveInfo.loadLabel(pm).toString();</div><div class="line">            mNameTextView.setText(appName);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><strong>Adapter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*ViewHolder 内部类显示标签名*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</div><div class="line"><span class="comment">//        创建引用信息加载获取用户标签</span></div><div class="line">    <span class="keyword">private</span> ResolveInfo mResolveInfo;</div><div class="line"><span class="comment">//        初始化显示控件</span></div><div class="line">    <span class="keyword">private</span> TextView mNameTextView;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActivityHolder</span><span class="params">(View itemView)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(itemView);</div><div class="line">        mNameTextView = (TextView) itemView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindActivity</span><span class="params">(ResolveInfo resolveInfo)</span> </span>&#123;</div><div class="line">        mResolveInfo = resolveInfo;</div><div class="line">        PackageManager pm = getActivity().getPackageManager();</div><div class="line">        String appName=mResolveInfo.loadLabel(pm).toString();</div><div class="line">        mNameTextView.setText(appName);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Adapter 内部了实现数据*/</span></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">ActivityHolder</span>&gt; </span>&#123;</div><div class="line"><span class="comment">//        初始化数据变量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ResolveInfo&gt; mActivities;</div><div class="line"><span class="comment">//         构造方法获取 activities</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ActivityAdapter</span><span class="params">(List&lt;ResolveInfo&gt; activities)</span> </span>&#123;</div><div class="line">        mActivities = activities;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//         创建列表布局视图样式</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ActivityHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</div><div class="line">        LayoutInflater layoutInflater = LayoutInflater.from(getActivity());</div><div class="line">        View view = layoutInflater.inflate(android.R.layout.simple_list_item_1, parent, <span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityHolder(view);</div><div class="line">    &#125;</div><div class="line"><span class="comment">//          获取每个activity 信息 并与ViewHolder 进行数据传递并绑定</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ActivityHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">        ResolveInfo resolveInfo = mActivities.get(position);</div><div class="line">        holder.bindActivity(resolveInfo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//          获取整个 list 数据</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mActivities.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后在 startupAdapter 方法下给 RecyclerView 添加Adapter,因为适配器所需要的参数，就是该方法获取到的 activity 信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mRecyclerView.setAdapter(<span class="keyword">new</span> ActivityAdapter(activities));</div></pre></td></tr></table></figure></p><hr><p>明天解决点击后跳转到其他应用 ヾ(◍°∇°◍)ﾉﾞ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;应用获取设备上的可启动应用，会使用 PackageManager 获取所有可启动主 activity。你可能会发现每一个应用都有一个主启动 activity 在注册清单上都有如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>C语言复习</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/23/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/23/C语言复习/</id>
    <published>2017-10-23T08:58:04.000Z</published>
    <updated>2017-10-24T03:08:31.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>C是强大而简洁的编程语言。</p></blockquote><h1 id="编程机制"><a href="#编程机制" class="headerlink" title="编程机制"></a>编程机制</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fksab59717j30jb0ij76a.jpg" alt=""></p><p>C编译器和链接器是把C语言源代码转换成可执行代码的程序。上图可知我们将源代码输入到编译器，生成机器语言的目标代码通过连接器把目标代码和库代码、启动代码结合生成可执行代码。启动代码在不同的系统下略有不同。</p><h1 id="C语言的语法"><a href="#C语言的语法" class="headerlink" title="C语言的语法"></a>C语言的语法</h1><p>大概举一些例子</p><ol><li>每个程序必须包含一个 main() 函数</li><li>声明语句</li><li>分号结尾</li><li>函数体是花括号</li><li>stdio.h 是输入输出的函数在声明语句中不引用它，就不能使用 printf 和 scanf 函数</li><li>关键字不能作为函数名称</li><li>注意 C语言的 数据类型，没有 string</li><li>注释 /**/</li><li>占位符的使用 %d %s %c %f 代表的意思</li><li>要使用函数前先要声明函数</li><li>。。。。</li></ol><h1 id="数据和-C"><a href="#数据和-C" class="headerlink" title="数据和 C"></a>数据和 C</h1><p>关键字：</p><ol><li>int</li><li>short</li><li>long</li><li>unsigned</li><li>char</li><li>float</li><li>double</li><li>_Bool</li><li>_Complex</li><li>_Imaginary</li></ol><p>运算符： sizeof() 返回一个变量内容的大小<br>函数：scanf()</p><p>练习 float 相关：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">float</span> weight;<span class="comment">//重量</span></div><div class="line"><span class="keyword">float</span> value; <span class="comment">//相等的白金价格</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"输入白金的重量？"</span>);</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;weight);</div><div class="line">value=<span class="number">1700</span> *weight *<span class="number">14.5833</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"你的白金价值：%.2f"</span>,value);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>%f 占位符替换浮点类型</li><li>&amp;weight 代表 scanf 函数获取用户的值赋值给 weight</li></ul><h2 id="数据类型关键字"><a href="#数据类型关键字" class="headerlink" title="数据类型关键字"></a>数据类型关键字</h2><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fksi68v1g1j30pr07g0ts.jpg" alt=""></p><p>根据计算机的存储类型分为两个基本类型：</p><ol><li>整数类型</li><li>浮点数类型</li></ol><p><strong>位、字节和字</strong></p><ol><li>位：最小的存储单元(bit) 位是计算机内存的基本构建块</li><li>字节：最常用的计算机存储单位(byte) 1byte = 8 bit</li><li>字：设计计算机给定的自然存储单位。32位的微型计算机，一字长32位</li></ol><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>概念：没有小数部分的数 如：22 -44 。计算机以二进制数存储整数，例如 7，二进制为 111</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fksie08g4mj30g706st96.jpg" alt=""></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>与整数相反: 如 2.75 3.18E2 4.00 2e-2 。<br>3.18E2：表示 3.18 X 100(3.18 乘以 10 的二次方)E后面的表示10的指数<br>计算机把浮点数分成小数部分和指数部分分别表示以及存储这两部分。</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fksintz3b3j30gc06b3yy.jpg" alt=""></p><h1 id="C语言的基本数据类型"><a href="#C语言的基本数据类型" class="headerlink" title="C语言的基本数据类型"></a>C语言的基本数据类型</h1><h2 id="int-类型"><a href="#int-类型" class="headerlink" title="int 类型"></a>int 类型</h2><p>概念：int 类型是有符号整型，必须为整数可以为正整数、负整数或零</p><p><strong>声明 int 变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int one,two,three;</div></pre></td></tr></table></figure><p>变量获取值：</p><ol><li>赋值</li><li>函数获取</li><li>初始化赋值 -_-|| 其实就是初始化变量同时赋值</li></ol><hr><p>变量创建和存储空间</p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fksizpt90jj30l509lwf9.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> ten = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> two = <span class="number">2</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d minus %d = %d \n"</span>,ten,two,ten - two);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d minus %d is %d \n"</span>,ten);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkt4xwvwtkj30bm055jrc.jpg" alt=""></p><blockquote><p>由于没有给后面两个参数赋值，所以打印出的值是内存的任意数</p></blockquote><p><strong>八进制与十六进制</strong></p><blockquote><p>通常 C语言都假定整型常量是十进制数。程序员喜欢八进制和十六进制，因为他们是 2 的幂，而 10 不是。例如：十进制 65536 经常出现在 16 位机中，用十六进制表示 10000 。十六进制数的每一位都是 4 位二进制数表示。例如， 十六进制 3 是 0011 ，5是 0101 。十六进制数 35 组合 00110101. 这种方式使得二进制与十六进制转换非常方便。 0X前缀表示 十六进制 而八进制的前缀为 0</p></blockquote><p><strong>显示八进制和十六进制</strong></p><ol><li>显示十进制的数字 %d   </li><li>显示八进制的数字 %o   显示前缀 %#o</li><li>显示十六进制的数字 %x 显示前缀 %#x</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"dec = %d; octal = %o;hex = %x \n;"</span> , x , x , x);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"dec = %d; octal = %#o;hex = %#x \n"</span> , x , x , x);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkt5qc4i39j30ao03hmx3.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;C是强大而简洁的编程语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;编程机制&quot;&gt;&lt;a href=&quot;#编
      
    
    </summary>
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Excel VBA基础语法</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/19/Excel-VBA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/19/Excel-VBA基础语法/</id>
    <published>2017-10-19T10:42:37.000Z</published>
    <updated>2017-10-19T11:42:04.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknr64y4vmj30q40ge0x3.jpg" alt=""></p><h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Dim 变量名 As 数据类型</div><div class="line">Dim i As String</div></pre></td></tr></table></figure><p>String 可以存20亿个字符，如果我们声明定长的 String 变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dim i As String*10</div></pre></td></tr></table></figure></p><p><strong>使用类型声明符</strong><br>只有部分有</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknrb22fwuj30q305w3ys.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Dim str$</div><div class="line">表明这是字符串的变量</div></pre></td></tr></table></figure></p><p><strong>声明多个变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dim str As String,nu As Integer</div></pre></td></tr></table></figure></p><p><strong>Variant</strong><br>如果不声明数据类型默认 Variant 变体型</p><blockquote><p>默认会根据赋值的类型自己判断</p></blockquote><p><strong>强制声明所有变量</strong></p><p>Option Explicit<br>在模块的第一句手动输入代码：会提示你变量没有规定数据类型</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknrmcecifj30o90hlaaj.jpg" alt=""></p><p><strong>三种语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Dim str As String 公共变量</div><div class="line">private Dim str As String 私有变量</div><div class="line">static Dim str As String 静态变量</div></pre></td></tr></table></figure><p><strong>变量的作用域</strong></p><ol><li>单个过程</li><li>单个模块</li><li>所有模块</li></ol><p><strong>使用变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set  str = “hello”</div></pre></td></tr></table></figure></p><p>给对象变量赋值时 必须加 Set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Option Explicit</div><div class="line">Sub test()</div><div class="line">    Dim a As Range</div><div class="line">    Set a = Range(&quot;A3&quot;)</div><div class="line">    a = &quot;123&quot;</div><div class="line">End Sub</div></pre></td></tr></table></figure><p><strong>使用常量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dim str As String = &quot;123&quot;</div></pre></td></tr></table></figure><p><strong>使用数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Dim 数组名(a to b) As 类型</div><div class="line">Dim 三年级1班(1 To 50) As String</div><div class="line">Dim box位置(1 To 50，1 To 50) As String</div></pre></td></tr></table></figure></p><p>赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">三年级1班(1) = &quot;张三&quot;</div><div class="line">box位置(1，2) = &quot;张三&quot;</div></pre></td></tr></table></figure></p><p><strong>动态数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Dim 数组名称()</div></pre></td></tr></table></figure></p><blockquote><p>最近超级不在状态，可能没有休息过来，每天都有课，有点厌倦了，有些课一点都没有意思，总感觉现在的课让我越来越缓慢，可能我的大脑能有点着急┭┮﹏┭┮</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/006rAlqhly1fknr64y4vmj30
      
    
    </summary>
    
      <category term="Office" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Office/"/>
    
    
      <category term="Excel" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Vultr 搭建 VPS</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/18/Vultr-%E6%90%AD%E5%BB%BA-VPS/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/18/Vultr-搭建-VPS/</id>
    <published>2017-10-18T14:15:32.000Z</published>
    <updated>2017-11-17T02:56:24.643Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不废话，这是一篇关于购买 vps 搭建 科(v)学(p)上(n)网的教程，包括服务器的优化</p></blockquote><h1 id="获取-VPS"><a href="#获取-VPS" class="headerlink" title="获取 VPS"></a>获取 VPS</h1><p><a href="https://www.vultr.com/?ref=7223311" target="_blank" rel="external">官方网站进入注册</a></p><ol><li>注册</li><li>充值</li><li>购买vps</li><li>搭建</li></ol><blockquote><p>对于充值 支持支付宝，推荐充值 10$ 也就是60多，Vultr 是按小时收费的，你所购买的类型每月有上限，超过这个上限不收费。比如 ： 2.5$ 每月的服务器，一个小时 0.004 一月按照 670 小时 也就是28天计算。充一次用很久</p></blockquote><h1 id="选择-vps"><a href="#选择-vps" class="headerlink" title="选择 vps"></a>选择 vps</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknsrwwgf8j31gn0mxn3p.jpg" alt=""></p><p>2.5$ 每月 只有 Miami 和 New York了</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknssvzb7yj314x0mp452.jpg" alt=""></p><p>然后直接确定部署</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknstnatl0j31bf0na40x.jpg" alt=""></p><p>现在我们需要下载一个软件去连接它，当天它自己也提供了连接，但是不推荐，因为后面有很长命令，不能粘贴复制</p><h1 id="Xshell-5"><a href="#Xshell-5" class="headerlink" title="Xshell 5"></a>Xshell 5</h1><p>百度云盘链接：<a href="http://pan.baidu.com/s/1kVehzSV" target="_blank" rel="external">http://pan.baidu.com/s/1kVehzSV</a> 密码：<code>uy5w</code></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknsv4k4xgj30i00hd758.jpg" alt=""></p><p>第一步:<br>创建<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknsy6otvmj30ij0h1wfb.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknszf8yh9j30ij0h1my1.jpg" alt=""></p><blockquote><p>名称随便，主机是在注册页面的ip 端口号 22，账号 root 密码 如下图。<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknt0bqebnj318p0i976x.jpg" alt=""></p></blockquote><p>连接成功 然后开始配置文件</p><h1 id="搭建-Shadowsocks"><a href="#搭建-Shadowsocks" class="headerlink" title="搭建 Shadowsocks"></a>搭建 Shadowsocks</h1><p><strong>安装组件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ yum install m2crypto python-setuptools</div><div class="line">$ easy_install pip</div><div class="line">$ pip install shadowsocks</div></pre></td></tr></table></figure></p><p><strong>安装完成后配置服务器参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ vi  /etc/shadowsocks.json</div></pre></td></tr></table></figure></p><p><strong>多端口的如下：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;server&quot;:&quot;47.x.x.x&quot;,</div><div class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</div><div class="line">    &quot;local_port&quot;:1080,</div><div class="line">    &quot;port_password&quot;: &#123;</div><div class="line">         &quot;7777&quot;: &quot;password1&quot;,</div><div class="line">         &quot;8888&quot;: &quot;password2&quot;</div><div class="line">     &#125;,</div><div class="line">    &quot;timeout&quot;:300,</div><div class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</div><div class="line">    &quot;fast_open&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后保存退出。</p><blockquote><p>vi 的命令: 按 “i” 进入编辑模式，编辑后按 “esc” 退出编辑模式， 输入 “:wq” 保存退出vi。</p></blockquote><p><strong>配置防火墙</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 安装防火墙</div><div class="line">$ yum install firewalld</div><div class="line"># 启动防火墙</div><div class="line">$ systemctl start firewalld</div></pre></td></tr></table></figure><p><strong>启动 Shadowsocks 服务</strong><br>推荐直接第二个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssserver -c /etc/shadowsocks.json</div></pre></td></tr></table></figure></p><p>如果想干点其他的实现后台运行，使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ssserver -c /etc/shadowsocks.json &amp;</div></pre></td></tr></table></figure></p><h1 id="连接-Shadowsocks"><a href="#连接-Shadowsocks" class="headerlink" title="连接 Shadowsocks"></a>连接 Shadowsocks</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fknt5mv5vzj30fn0af3zi.jpg" alt=""></p><h1 id="VPS加速引擎：Linux版锐速全自动安装包"><a href="#VPS加速引擎：Linux版锐速全自动安装包" class="headerlink" title="VPS加速引擎：Linux版锐速全自动安装包"></a>VPS加速引擎：Linux版锐速全自动安装包</h1><blockquote><p>不废话 直接别人总结很好<br><a href="https://www.landiannews.com/archives/28720.html" target="_blank" rel="external">VPS加速引擎：Linux版锐速全自动安装包</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;不废话，这是一篇关于购买 vps 搭建 科(v)学(p)上(n)网的教程，包括服务器的优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;获取-VPS&quot;&gt;&lt;a href=&quot;#获取-VPS&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="VPS" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Excel VBA 速记</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/17/Excel-VBA-%E9%80%9F%E8%AE%B0/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/17/Excel-VBA-速记/</id>
    <published>2017-10-17T10:06:02.000Z</published>
    <updated>2017-10-17T10:49:52.651Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>VBA</li><li>VBA 面板</li><li>试写一个简单的 VBA 程序</li></ol><a id="more"></a><h1 id="VBA"><a href="#VBA" class="headerlink" title="VBA"></a>VBA</h1><p>VBA(Visual Basic For Application)是一种建立在 Office 中的编程语言。<br>上一节讲了宏，顺便引出 VBA,录制宏就是一种 VBA 程序，只不过这个程序是自己生成的。在使用 Excel 过程中有很多不能用宏解决的问题，比如循环，做复杂操作…. 只有我们进入 VBA 编程，自己编写宏。</p><h1 id="VBA-面板"><a href="#VBA-面板" class="headerlink" title="VBA 面板"></a>VBA 面板</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkles8a0k8j31h70owace.jpg" alt=""></p><p>打开方式：</p><ol><li><code>alt+F11</code></li><li>查看宏 ——&gt; 编辑</li><li>开发工具选项卡 ——&gt; 查看代码</li><li>工作区 ——&gt; 右键菜单 ——&gt; 查看代码<br><br>…</li></ol><h1 id="试写一个简单的-VBA-程序"><a href="#试写一个简单的-VBA-程序" class="headerlink" title="试写一个简单的 VBA 程序"></a>试写一个简单的 VBA 程序</h1><h3 id="添加或删除模块"><a href="#添加或删除模块" class="headerlink" title="添加或删除模块"></a>添加或删除模块</h3><p>不多说，直接上图，简单明了<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fklf0c7nbsg31gt0r0dve.gif" alt=""></p><h3 id="开始编写"><a href="#开始编写" class="headerlink" title="开始编写"></a>开始编写</h3><p>双击模块 ——&gt; 插入菜单 ——&gt; 过程 ——&gt; 命名并确定<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fklf1c2ls1j30qg0epwfu.jpg" alt=""><br>中间添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Public Sub mysub()</div><div class="line">    MsgBox &quot;学习 VBA hahahahha&quot;</div><div class="line">End Sub</div></pre></td></tr></table></figure></p><p>然后点击运行</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fklff4enzbj306f05mq31.jpg" alt=""></p><h3 id="一键查询"><a href="#一键查询" class="headerlink" title="一键查询"></a>一键查询</h3><p><code>F1</code> 查询,比如刚才的 MsgBox 是什么意思? 选择 MsgBox 按 F1</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fklfq8r664j30es0k5gra.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VBA&lt;/li&gt;
&lt;li&gt;VBA 面板&lt;/li&gt;
&lt;li&gt;试写一个简单的 VBA 程序&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Office" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Office/"/>
    
    
      <category term="Excel" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Android 虚拟机和 Docker 虚拟机冲突</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/15/Android-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C-Docker-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%B2%E7%AA%81/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/15/Android-虚拟机和-Docker-虚拟机冲突/</id>
    <published>2017-10-15T06:20:21.000Z</published>
    <updated>2017-10-16T06:08:41.416Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当最近下载 Docker 并学习 Docker 相关知识发现不能启动 android 虚拟机了</p></blockquote><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>Android studio 启动模拟器报错-Turn off Hyper-V<br>2.</li></ol><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>虽然网上查询资料，但都没有解决【Hyper-V】与【VirtualBox】【VMware】 虚拟机冲突的问题，但是有两个解决方案</p><ol><li>在 VMware 里的系统进行操作</li><li>如果两个类型的虚拟机在 windows 上可通过 关闭与打开 Hyper -V (比较麻烦，需要重启)</li></ol><p>打开控制面板 ——&gt; 卸载 ——&gt; 启动或关闭 windows 功能 ——&gt;  选择关闭打开 Hyper -V<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkk1rxzfhsj30z20ky0vn.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkk1td7c3nj30dg0do3zo.jpg" alt=""></p><p><a href="http://blog.csdn.net/sarah98/article/details/72654916" target="_blank" rel="external">相关链接1</a><br><br><a href="http://blog.csdn.net/qwsamxy/article/details/50533007" target="_blank" rel="external">相关链接2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当最近下载 Docker 并学习 Docker 相关知识发现不能启动 android 虚拟机了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="问题解决" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="日常问题" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Excel 初学宏</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/15/Excel-%E5%88%9D%E5%AD%A6%E5%AE%8F/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/15/Excel-初学宏/</id>
    <published>2017-10-15T05:10:43.000Z</published>
    <updated>2017-10-15T06:04:41.628Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>宏的定义</li><li>实现工资条的宏</li><li>定义宏的按钮</li><li>定义宏的快捷功能区</li><li>宏安全</li></ol><a id="more"></a><h1 id="宏的定义"><a href="#宏的定义" class="headerlink" title="宏的定义"></a>宏的定义</h1><p>什么是宏? 通俗讲就是类似与 gif 动态图，重复做一系列操作，对于宏，就是重复录制的操作，录制的不是图像，而是在重复操作的过程。宏方便于大批量的操作，使用宏可以做到一键操作。</p><h1 id="实现工资条的宏"><a href="#实现工资条的宏" class="headerlink" title="实现工资条的宏"></a>实现工资条的宏</h1><p>是否遇到过一下形式的 excel 方便打印后裁剪<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkivdmi3fzj30hd08i3yx.jpg" alt=""></p><p>通常我们的表格是这样的</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkivfx8lw0j30ga05zq34.jpg" alt=""></p><p>实现1：使用<code>ctrl + c</code>和 <code>ctrl + v</code> 实现<br></p><p>这种方式对于数量较小的操作可能比较方便，当遇到大量的数据推荐使用宏定义。</p><p>实现2：使用宏</p><p>步骤1：选取行的第一个单元格定位 ——&gt; 录制宏 ——&gt; 操作1：辅助第一行 ——&gt; 操作2：插入辅助到第三行  ——&gt; 停止录制</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkivxxmiv1g312o0ouwww.gif" alt=""></p><h1 id="定义宏的按钮"><a href="#定义宏的按钮" class="headerlink" title="定义宏的按钮"></a>定义宏的按钮</h1><p>插入一个宏按钮，进行宏操作<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkiw2un54rg312o0ou4ot.gif" alt=""></p><h1 id="定义宏的快捷功能区"><a href="#定义宏的快捷功能区" class="headerlink" title="定义宏的快捷功能区"></a>定义宏的快捷功能区</h1><p>有时候我们经常使用的宏，相同的操作我们不希望每次都打开录制，我们可以把我们的这个按钮放到快捷功能区里。</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkiwadh6mag319v0p61bb.gif" alt=""></p><h1 id="宏安全"><a href="#宏安全" class="headerlink" title="宏安全"></a>宏安全</h1><p>有时候在工作中打开文档，不能使用宏，因为设置了宏安全为高级，禁用了宏。我们可以通过宏安全选项，取消禁用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;宏的定义&lt;/li&gt;
&lt;li&gt;实现工资条的宏&lt;/li&gt;
&lt;li&gt;定义宏的按钮&lt;/li&gt;
&lt;li&gt;定义宏的快捷功能区&lt;/li&gt;
&lt;li&gt;宏安全&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Office" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Office/"/>
    
    
      <category term="Excel" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>Android Master-Detail</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/14/Android-Master-Detail/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/14/Android-Master-Detail/</id>
    <published>2017-10-14T07:05:48.000Z</published>
    <updated>2017-10-17T11:35:16.369Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>主从用户界面</li><li>增加布局灵活性</li><li>使用别名系统</li><li>fragment 回调接口</li></ol><h1 id="主从用户界面"><a href="#主从用户界面" class="headerlink" title="主从用户界面"></a>主从用户界面</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkk15mhdb2j30ml0cymz0.jpg" alt=""><br>本来对应手机设备，一般都是单版面，上图这种双版面可以叫做主从界面</p><h1 id="增加布局灵活性"><a href="#增加布局灵活性" class="headerlink" title="增加布局灵活性"></a>增加布局灵活性</h1><ol><li>手机的布局都是单版面(single-pane)</li><li>在平板上，因为同时显示主从用户的界面，我们需要生成双版面(two-pane)布局</li></ol><p>如何实现?</p><ol><li>修改托管 fragment 的 setContentView 方法</li><li>创建两个 fragment 容器布局</li><li>修改托管的 Activity 实现在手机中显示单版面，在平板上实例化双版面</li></ol><p>具体到项目:</p><blockquote><ol><li>修改布局，从单版面修改为双版面</li><li>给父类 SimpleFragmentActivity 中的加载 fragment 改为 获取布局的方法</li><li>分别给水平，垂直布局修改布局</li><li>覆写 getLayoutResID 返回 需要加载的布局</li></ol></blockquote><h1 id="使用别名系统"><a href="#使用别名系统" class="headerlink" title="使用别名系统"></a>使用别名系统</h1><p>别名系统是一种指向其他资源的特殊资源</p><ol><li>在 res/values 创建refs.xml 别名资源文件</li><li><p>创建默认的别名资源值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"activity_masterdetail"</span> <span class="attr">type</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">        @layout/activity_fragment</div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>创建规定屏幕范围的资源值</p></li></ol><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkk085hx55j309h04kjrg.jpg" alt=""><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"activity_masterdetail"</span> <span class="attr">type</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">        @layout/activity_twopane</div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p><p>上面两种别名资源，可以通过设备屏幕的大小改变不同的布局文件。</p><ul><li>当屏幕小于 600dp 将使用 R.layout.activity_fragment 单版面布局</li><li>当屏幕大学 600dp 将使用 R.layout.activity_twopane<br>双版面的布局</li></ul><h1 id="fragment-回调接口"><a href="#fragment-回调接口" class="headerlink" title="fragment 回调接口"></a>fragment 回调接口</h1><blockquote><p>当我们在双版面的情况下，不在启动新的页面，在第一个页面的 fragment 中的点击事件获取第二个页面的 FragmentManager ，然后提交一个 fragment<br> 事务，将第二个 Fragment 添加到双版面的布局。虽然这种方法行的通。</p><p>fragment 天生是独立的开发构件。如果用 fragment 用来添加其他 fragment 到 activity 的 FragmentManager，那么这个 fragment 就必须知道托管 activity 是如何工作的。</p></blockquote><p><strong>托管 activity 将实现回调接口，履行托管 fragment 的任务</strong></p><blockquote><p>接口回调是用接口句柄来得到并调用实现这个接口的子类的引用</p></blockquote><ol><li>在 fragment 定义回调接口，托管 activity 强制转化为 CallBacks 对象并赋值给 CallBacks 类型变量(强制转化的目的是托管 activity 必须实现回调接口，这种机制将 fragment 需要完成的事务托管给 activity)</li><li>托管的 activity 实现 .CallBacks 接口</li><li>实现接口的方法，方法内写事务</li></ol><p>实例:</p><ol><li>当为手机设备，启动 activity</li><li>当为平板设备，将 fragment 放入 双版面的详情页面</li></ol><p>以下是实现接口的回调方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCrimeSelected</span><span class="params">(Crime crime)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(findViewById(R.id.detail_fragment_container)==<span class="keyword">null</span>)&#123;</div><div class="line">            Intent intent=CrimePagerActivity.newIntent(<span class="keyword">this</span>,crime.getId());</div><div class="line">            startActivity(intent);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            Fragment newDetail=CrimeFragment.newInstance(crime.getId());</div><div class="line"></div><div class="line">            getSupportFragmentManager().beginTransaction()</div><div class="line">                    .replace(R.id.detail_fragment_container,newDetail)</div><div class="line">                    .commit();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><p>当点击不同列表，显示不同详情页，调用全部回调方法。</p><ol><li>点击列表调用显示详情页的回调方法</li><li>点击添加按钮时，调用显示详情页的回调方法<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkl0vjnbdlg30cj0ktad0.gif" alt=""></li></ol><h1 id="回调函数刷新"><a href="#回调函数刷新" class="headerlink" title="回调函数刷新"></a>回调函数刷新</h1><ol><li>将列表清单刷新私有方法改为公有方法</li><li>将详细面板创建 Callbacks 回调方法，并创建 onAttach()将 activity 赋值给 Callbacks 对象。frgament 结束方法 onDetach() 将 null 复制 Callbacks 对象</li><li>托管 activity 实现接口方法，并在方法中实现托管的代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主从用户界面&lt;/li&gt;
&lt;li&gt;增加布局灵活性&lt;/li&gt;
&lt;li&gt;使用别名系统&lt;/li&gt;
&lt;li&gt;fragment 回调接口&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;主从用户界面&quot;&gt;&lt;a href=&quot;#主从用户界面&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 快速记忆总结</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/14/Android-%E5%BF%AB%E9%80%9F%E8%AE%B0%E5%BF%86/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/14/Android-快速记忆/</id>
    <published>2017-10-14T05:59:19.000Z</published>
    <updated>2017-10-24T10:38:20.654Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>托管 UI fragment</li><li>使用 RecyclerView</li><li>使用 fragment argument</li><li>使用 ViewPager</li><li>使用 DialogFragmen</li></ol><a id="more"></a><blockquote><p>在初学 android 中总是记不住一个控件的使用，用法，通过这种提纲加一点详细说明的方式，方便以后再开发中，快速找到和回忆起相关操作，减少百度查资料的时间。可能总结的不是那么完善，通过后期不断的翻看，以及实践过程中的不断使用，完善这种总结。</p></blockquote><h1 id="托管-UI-fragment"><a href="#托管-UI-fragment" class="headerlink" title="托管 UI fragment"></a>托管 UI fragment</h1><h2 id="fragment的生命周期"><a href="#fragment的生命周期" class="headerlink" title="fragment的生命周期"></a>fragment的生命周期</h2><h2 id="托管的两种方式"><a href="#托管的两种方式" class="headerlink" title="托管的两种方式"></a>托管的两种方式</h2><h2 id="fragment-使用"><a href="#fragment-使用" class="headerlink" title="fragment 使用"></a>fragment 使用</h2><pre><code>- 定义容器视图(FrameLayout)- 创建 UI fragment 类        - onCreateView 定义布局文件中的组件        - 将 fragment 添加到 托管actiivty中 FragmentManager(负责发 fragment添加到 activity 视图层级结构)        - fragment 事务组装用户界面</code></pre><h1 id="添加-UI-fragment-到-FragmentManager"><a href="#添加-UI-fragment-到-FragmentManager" class="headerlink" title="添加 UI fragment 到 FragmentManager"></a>添加 UI fragment 到 FragmentManager</h1><h2 id="FragmentManager的概念"><a href="#FragmentManager的概念" class="headerlink" title="FragmentManager的概念"></a>FragmentManager的概念</h2><h2 id="FragmentManager的管理"><a href="#FragmentManager的管理" class="headerlink" title="FragmentManager的管理"></a>FragmentManager的管理</h2><pre><code>1. fragment 队列2. fragment 事务回退栈</code></pre><h2 id="fragment-事务"><a href="#fragment-事务" class="headerlink" title="fragment 事务"></a>fragment 事务</h2><h2 id="FragmentManager-与-fragment-的生命周期"><a href="#FragmentManager-与-fragment-的生命周期" class="headerlink" title="FragmentManager 与 fragment 的生命周期"></a>FragmentManager 与 fragment 的生命周期</h2><hr><p> 使用 RecyclerView 显示列表</p><blockquote><p>基本流程： 创建Adapter 获取模型层数据并绑定 ViewHolder 给视图，然后将 Adapter 添加个 RecyclerView</p><h1 id="使用抽象-activity-托管-fragment（将相同的activity-将重复部分封装为抽象类，每个-activity-都继承这个抽象类）"><a href="#使用抽象-activity-托管-fragment（将相同的activity-将重复部分封装为抽象类，每个-activity-都继承这个抽象类）" class="headerlink" title="使用抽象 activity 托管 fragment（将相同的activity 将重复部分封装为抽象类，每个 activity 都继承这个抽象类）"></a>使用抽象 activity 托管 fragment（将相同的activity 将重复部分封装为抽象类，每个 activity 都继承这个抽象类）</h1><h1 id="RecyclerView、Adapter-和-ViewHolder"><a href="#RecyclerView、Adapter-和-ViewHolder" class="headerlink" title="RecyclerView、Adapter 和 ViewHolder"></a>RecyclerView、Adapter 和 ViewHolder</h1><h2 id="ViewHolder-和-Adapter"><a href="#ViewHolder-和-Adapter" class="headerlink" title="ViewHolder 和 Adapter"></a>ViewHolder 和 Adapter</h2><pre><code>- viewholder-adapter</code></pre><h1 id="使用-RecyclerView"><a href="#使用-RecyclerView" class="headerlink" title="使用 RecyclerView"></a>使用 RecyclerView</h1><pre><code>- 导入依赖- 定义容器视图(RecyclerView)- 通过代码实例化视图(onCreateView方法中，需要 LayoutManager 的支持)- 定义 ViewHolder 的内部类 （继承 RecyclerView.ViewHolder）- 创建 adapter 的内部类 ( 继承 RecyclerView.Adapter&lt;ViewHolder&gt; )</code></pre></blockquote><pre><code>1.  onCreateViewHolder() --需要使用列表布局2. onBindViewHolder()3. getItemCount()- 给 RecyclerView 设置适配器</code></pre><h1 id="响应点击"><a href="#响应点击" class="headerlink" title="响应点击"></a>响应点击</h1><p>验证每个 ItemView 是否有效</p><pre><code>- 添加 View.OnClickerListerner 接口- 覆写 onClick 方法- 给每个 ItemView 设置监听器</code></pre><hr><h1 id="使用-fragment-argument"><a href="#使用-fragment-argument" class="headerlink" title="使用 fragment argument"></a>使用 fragment argument</h1><p>每个 fragment 实例都可附带一个 Bundle 对象。格式为键值对形式，一个键值对即一个 argument</p><ul><li>先创建 Bundle</li><li>使用 bundle put 类型方法，将 argument 添加到 bundle 中</li></ul><p>code</p><h1 id="附加-argument-给-fragment"><a href="#附加-argument-给-fragment" class="headerlink" title="附加 argument 给 fragment"></a>附加 argument 给 fragment</h1><p>格式： Fragment.setArguments(Bundle)<br>必须在 fragment 创建后、添加给 activity 前完成</p><p>利用 getArguments（）.get 获取</p><h1 id="通过-fragment-获取返回结果"><a href="#通过-fragment-获取返回结果" class="headerlink" title="通过 fragment 获取返回结果"></a>通过 fragment 获取返回结果</h1><p>类似与 Activity 调用 startActivityForResult() ,转而调用 Fragment.startActivityForResult()<br>接受也是从 Activity 到 Fragment 中，其中要注意的是 fragment 对返回结果处理不同</p><pre><code>- 自身无法持有返回结果，只用 activity 拥有返回结果</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p183</div></pre></td></tr></table></figure><hr><h1 id="使用-ViewPager"><a href="#使用-ViewPager" class="headerlink" title="使用 ViewPager"></a>使用 ViewPager</h1><ul><li>创建 一个 ViewPager 类</li><li>定义容器组件</li><li>在 ViewPager 关联 ViewPager 和 adapter</li><li>修改</li></ul><h1 id="ViewPager-和-PagerAdapter"><a href="#ViewPager-和-PagerAdapter" class="headerlink" title="ViewPager 和 PagerAdapter"></a>ViewPager 和 PagerAdapter</h1><h2 id="PagerAdapter-子类-FragmentStatePagerAdapter"><a href="#PagerAdapter-子类-FragmentStatePagerAdapter" class="headerlink" title="PagerAdapter 子类 FragmentStatePagerAdapter"></a>PagerAdapter 子类 FragmentStatePagerAdapter</h2><p>FragmentStatePagerAdapter 的抽象方法</p><ul><li>getCount()</li><li>getItem(int)<br>还有实例需要 FragmentManager</li></ul><hr><h1 id="使用-DialogFragment"><a href="#使用-DialogFragment" class="headerlink" title="使用 DialogFragment"></a>使用 DialogFragment</h1><pre><code>1. 创建 DialogFragment 类2. 继承 DialogFragment3. 覆写 onCreateDialog 方法4. 方法内返回 AlertDialog.builder 创建的 Builder 对象（setView-setTitle-setPositiveButton）5. 创建 FragmentManager6. show(manger,xxx) 显示对话框</code></pre><hr><h1 id="工具栏菜单"><a href="#工具栏菜单" class="headerlink" title="工具栏菜单"></a>工具栏菜单</h1><pre><code>1. 定义 XML 菜单文件2. onCreateOptionsMenu()方法创建菜单3. onOptionsItemSelected（）对菜单进行操作处理</code></pre><p>实现层级式导航</p><pre><code>1. 在注册文件清单上向详情 Activity 上添加 向上按钮parentActivityName（）</code></pre><hr><h1 id="SQLite-数据库"><a href="#SQLite-数据库" class="headerlink" title="SQLite 数据库"></a>SQLite 数据库</h1><pre><code>1. 创建一个数据库表字段的类2. 创建初始化数据库，用到SQLiteOpenHelper类3. 覆写两个方法，一个 onCreate 创建数据库 一个 onUpgrade创建数据库4. 初始化数据库并授权权限5. ContentValues 负责处理数据库写入和更新操作。格式为键值对数据（这个类用户数据库操作使用）6. 数据库的insert update delete 操作</code></pre><hr><h1 id="CursorWrapper-类"><a href="#CursorWrapper-类" class="headerlink" title="CursorWrapper 类"></a>CursorWrapper 类</h1><p>封装数据表的原始数据 从cursor 获取数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;托管 UI fragment&lt;/li&gt;
&lt;li&gt;使用 RecyclerView&lt;/li&gt;
&lt;li&gt;使用 fragment argument&lt;/li&gt;
&lt;li&gt;使用 ViewPager&lt;/li&gt;
&lt;li&gt;使用 DialogFragmen&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>隐式 Intent</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/12/%E9%9A%90%E5%BC%8F-Intent/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/12/隐式-Intent/</id>
    <published>2017-10-12T11:56:28.000Z</published>
    <updated>2017-10-12T12:38:02.397Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>使用隐式 Intent</li><li>隐式 Intent 的组成<ul><li>执行操作</li><li>数据的位置</li><li>涉及的数据类型</li><li>可选类别</li></ul></li><li>一些实例</li></ol><a id="more"></a><blockquote><p>最近学习《Android 权威编著》,这几天学的总结一下，加深印象，也是方便以后忘记了，能快速找到相关内容，本节主要是关于 隐式 Intent 的使用</p></blockquote><h1 id="使用隐式-Intent"><a href="#使用隐式-Intent" class="headerlink" title="使用隐式 Intent"></a>使用隐式 Intent</h1><p>隐式 Intent 区别与显示 Intent 的主要区别在于，在实现 Intent 通信我们不需要想显示 Intent 提供以及编写指定具体的 activity，只需要告诉操作系统我们想要做什么，通过系统内置的属性就可以简单实现我们想要的。</p><h1 id="隐式-Intent-的组成"><a href="#隐式-Intent-的组成" class="headerlink" title="隐式 Intent 的组成"></a>隐式 Intent 的组成</h1><h3 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h3><p>通常 Intent 类中的常量来表示。</p><ul><li>Intent.ACTION_VIEW 查看某个 URL</li><li>Intent.ACTION_SEND 发送邮件</li><li>Intent.ACTION_DITL 拨号界面等待拨号</li><li>Intent.ACTION_CALL 拨打电话</li></ul><h3 id="数据的位置"><a href="#数据的位置" class="headerlink" title="数据的位置"></a>数据的位置</h3><ol><li>设备外的资源使用 URL</li><li>指向文件的 URI</li><li>指向 ContentProvider 中的某个内容 URI (content URI)</li></ol><h3 id="涉及的数据类型"><a href="#涉及的数据类型" class="headerlink" title="涉及的数据类型"></a>涉及的数据类型</h3><p>MIME 数据类型，如 text/html , audio/mpeg3.如果一个 intent 包含数据位置，那么通常可以从中推测出数据的类型</p><p><a href="https://baike.baidu.com/item/MIME/2900607?fr=aladdin" target="_blank" rel="external">关于 MIME</a></p><h3 id="可选类别"><a href="#可选类别" class="headerlink" title="可选类别"></a>可选类别</h3><p>如果操作用于描述具体要做什么，那么通常用来描述我们是何时、何地或者如何使用某个 activity 的。</p><ol><li>通过简单的 Intent</li><li>通过配置文件的 intent 过滤器</li></ol><h1 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h1><ul><li>打开短信，发送消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</div><div class="line">i.setType(<span class="string">"text/plain"</span>);</div><div class="line"><span class="comment">/*添加正文内容*/</span></div><div class="line">i.putExtra(Intent.EXTRA_TEXT, <span class="string">"TEXT"</span>);</div><div class="line">i.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"SUBJECT"</span>);</div><div class="line">i = Intent.createChooser(i, <span class="string">"选择你想使用的应用"</span>);</div><div class="line">startActivity(i);</div></pre></td></tr></table></figure><p>使用 ShareCompat 类创建发送消息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ShareCompat.IntentBuilder intentBuilder = ShareCompat.IntentBuilder.from(getActivity());</div><div class="line">                intentBuilder.setType(<span class="string">"text/plain"</span>);</div><div class="line">                intentBuilder.setText(<span class="string">"text"</span>);</div><div class="line">                intentBuilder.setSubject(<span class="string">"what"</span>);</div><div class="line">                intentBuilder.setChooserTitle(<span class="string">"select"</span>);</div><div class="line">                intentBuilder.startChooser();</div></pre></td></tr></table></figure></p><ul><li>打开联系人，选择联系人</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent pickContact = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI);</div><div class="line"> startActivityForResult(pickContact, REQUEST_CODE);</div></pre></td></tr></table></figure><p>这需要处理返回的 Intent ，因为系统会把联系人数据发送个 Intent，其中包含了临时的权限。onActivityResult方法中一下注释前是通过 查询名称，注释后查询电话号，并拨打电话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">f (requestCode == <span class="number">1</span> &amp;&amp; data != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">/*创建一个Uri 数据地址*/</span></div><div class="line">            Uri contactUri = data.getData();</div><div class="line">            <span class="comment">/*创建查询语句*/</span></div><div class="line">            String[] queryFields = <span class="keyword">new</span> String[]&#123;</div><div class="line"><span class="comment">//                    ContactsContract.Contacts.DISPLAY_NAME</span></div><div class="line">                    ContactsContract.Contacts._ID</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">/*查询联系人数据库，并返回一个 cursor*/</span></div><div class="line">            Cursor c = getActivity().getContentResolver().query(contactUri, queryFields, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                c.moveToFirst();</div><div class="line">            <span class="comment">/*判断返回结果是否为0 表示没有数据*/</span></div><div class="line">                <span class="keyword">if</span> (c.getCount() == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">/*String suspect=c.getString(0);</span></div><div class="line"><span class="comment">                mCrime.setPeopleName(suspect);</span></div><div class="line"><span class="comment">                mSuspect.setText(suspect);*/</span></div><div class="line">                Uri number = Uri.parse(<span class="string">"tel:"</span> + c.getString(<span class="number">0</span>));</div><div class="line">                Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, number);</div><div class="line">                startActivity(i);</div><div class="line"></div><div class="line"></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                c.close();</div><div class="line">            &#125;</div></pre></td></tr></table></figure><ul><li>打开相机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent captureImage = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">startActivityForResult(captureImage, 2);</div></pre></td></tr></table></figure><blockquote><p>因为 Intent 打开应用两种情况，一种是很多应用支持，可以使用选择器。一种是没有内置的应用，这种情况会让应用崩溃，可以通过 packageManager 自检，如果没有就，禁用按钮</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PackageManager packageManager = getActivity().getPackageManager();</div><div class="line">        <span class="keyword">if</span> (packageManager.resolveActivity(pickContact, PackageManager.MATCH_DEFAULT_ONLY) == <span class="keyword">null</span>) &#123;</div><div class="line">            mSuspect.setEnabled(<span class="keyword">false</span>);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用隐式 Intent&lt;/li&gt;
&lt;li&gt;隐式 Intent 的组成&lt;ul&gt;
&lt;li&gt;执行操作&lt;/li&gt;
&lt;li&gt;数据的位置&lt;/li&gt;
&lt;li&gt;涉及的数据类型&lt;/li&gt;
&lt;li&gt;可选类别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一些实例&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
      <category term="intent" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/intent/"/>
    
  </entry>
  
  <entry>
    <title>常用的字体表情</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/12/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E4%BD%93%E8%A1%A8%E6%83%85/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/12/常用的字体表情/</id>
    <published>2017-10-12T07:43:20.000Z</published>
    <updated>2017-10-12T08:05:44.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>生活中不管是发消息，还是编辑文档，写个人简介，编写 README … 都会使用表情图标💪，增加文本的互动性，提高文本的可阅读性，今天想总结一下这一类的图标资源😃😄😅😆😉😊😋</p></blockquote><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>这个使用起来很方便就是 <code>ctrl + C </code>&amp;&amp; <code>ctrl + V </code></p><blockquote><p>需要注意的是表情在不同页面，应用，以及平台上的表现效果是不同的</p></blockquote><p>来看一组图</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkfiiyzqpdj30m01umgt2.jpg" alt=""></p><p>哈哈，有没有觉得好笑，但是这不是重点，重点是我们只要使用了，比不适用的好的多的多。(#^.^#)</p><h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><p>🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥</p><p><strong>常用emoji符号一(非图片可复制)</strong></p><p>😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂</p><p><strong>常用emoji符号二(非图片可复制)</strong></p><p>🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴</p><p><strong>常用emoji符号三(非图片可复制)↑返回顶部</strong></p><p>🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣🌿🚧💒☎📟💽⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞</p><h1 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h1><p><a href="https://emojipedia.org/smirking-face/" target="_blank" rel="external">首选 emoji 网站</a><br><br><a href="http://www.fhdq.net/emoji.html" target="_blank" rel="external">常用emoji符号</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;生活中不管是发消息，还是编辑文档，写个人简介，编写 README … 都会使用表情图标💪，增加文本的互动性，提高文本的可阅读性，今天想总结一下这一类的图标资源😃😄😅😆😉😊😋&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>自我鞭策(2017-10-10)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/10/%E8%87%AA%E6%88%91%E9%9E%AD%E7%AD%96-2017-10-10/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/10/自我鞭策-2017-10-10/</id>
    <published>2017-10-10T13:10:55.000Z</published>
    <updated>2017-10-11T03:34:00.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回过头看这几个月，发现自己什么都没有做好，假期回去了，本来打算好的好好学技术也没有去做，去参加夏利营培训，也就前几天认真完成任务，后面开始有点松懈了。开学也是，也就前几天每天都忙如狗，可是有没有什么特别的成绩。</p></blockquote><a id="more"></a><p>也就这几天有点进步,知道的概念多点，每天写写博客，但是，长点心吧，曲家诚，你马上都快要毕业了，你明知道要考6级，要比赛，要专升本，为什么每天都在浑浑噩噩的，想想虽然每天自己很忙，但是有成效的却很少，而且忙的都是不怎么重要的，你的英语，高数，你根本没有给出时间去看。你就是缺少自我控制，和自我管理的能力，虽然对未来你有目标，但是这些目标没有计划，没有付出与行动。即使你现在每天写博客，但是一天下来就一篇博客?</p><p>我真不知道你怎么还能受得了自己，想想以后要面试的时候，你拿什么跟人家比，拿什么让别人留下你，你该好好想想以后去做了，该去指定一个计划，然后每天按照这个计划一步一步实现自己想要的结果。你还想再经历高考那种耻辱吗？如果不想重蹈覆辙，就着眼于眼下，想想目前来说，什么才是重要的?你在乎的是什么?知道了，就应该想想如何去实现他们。</p><hr><p>骂了自己那么多，其实也清楚了自己现在最重要的事</p><ol><li>专升本</li><li>英语六级</li><li>Android 比赛</li></ol><p>既然知道了在乎的三件事，需要去实现它们，我还要走很长的路，但是，说句实话，我现在真的是对新的技术，语言，还是工具感兴趣，我这十几天每天写博客，能坚持的原因就是喜欢，可能遇到了困难，但是我清楚这之中我浪费了很多时间和精力做了跟他们无关的事情，我缺少了专注了，以至于现在一天做的事情太少。</p><hr><p>现在我清楚离六级考试，离专升本已经还有几个月的时间了，今天就想鞭笞一下自己，并且确定接下来的日子应该怎么度过，我觉得这是有必要的，我需要制定一个实际并有效的计划让我的生活有节奏，并且从中得到成就感。否则，我很快就会过那种颓废，而且每天胡思乱想的生活了。</p><hr><p>现在，每天坚持的:</p><ol><li>早起</li><li>锻炼</li><li>写博客</li><li>看看书</li></ol><p>我还要其他的事情，让他成为一种习惯，因为习惯的事情，做起来不觉得别扭，而且坚持下来对自己很有好处。我希望在接下来的一个月每天能坚持的：</p><ol><li>早上能抽出时间看英文原版书</li><li>晚上做做高数</li></ol><p>就这两条吧，我怕多了，有点违背现实，以及高估自己的自控力。</p><hr><p>虽然以前也有过自己自责自己，然后让自己去改变的想法，但是从来没有把这个当成博客来写，以后会经常写。因为对于自己来说写博客，能加深自己对自己写的东西的印象。这个现象是我这半个月来发现的。我觉得这个学习方法比较适合我。</p><hr><p>总有一天，我会写夸自己的博客！！！O(∩_∩)O哈哈~</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;回过头看这几个月，发现自己什么都没有做好，假期回去了，本来打算好的好好学技术也没有去做，去参加夏利营培训，也就前几天认真完成任务，后面开始有点松懈了。开学也是，也就前几天每天都忙如狗，可是有没有什么特别的成绩。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-9)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/09/%E5%AD%A6%E4%B9%A0Docker-2017-10-9/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/09/学习Docker-2017-10-9/</id>
    <published>2017-10-09T02:08:42.000Z</published>
    <updated>2017-10-19T01:19:52.229Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ul><li>高级网络配置<ul><li>快速配置指南</li><li>配置DNS</li><li>容器访问控制</li><li>端口映射实现</li><li>配置 docker0 网桥</li><li>自定义网桥</li></ul></li></ul><a id="more"></a><h1 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h1><p>当 docker 启动时，会自动创建一个 docker0 虚拟网桥，实际上是 Linux 的一个bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，Docker 随机分配一个本地未占用的私有网段(zai RFC 1918 中定义)中的一个地址给 docker0 接口.<br>比如:<br>172.17.42.1,掩码为255.255.0.0 。此后启动的容器内的网口也会自动分配一个同一网段(172.17.0.0/16)的地址。</p><p>当创建一个Docker 容器的时候，同时创建一对 veth pair 接口。这对端口一段在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头，通过这个方式，主机可以跟容器通信，容器之间也可以相互通信。 Docker 就创建了在主机和所以容器之间的虚拟共享网络</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkbsl7wz1lj30k10d6mzx.jpg" alt=""></p><p><a href="https://baike.baidu.com/item/RFC%201918/1528155?fr=aladdin" target="_blank" rel="external">关于1 RFC 1918</a><br><br><a href="https://tools.ietf.org/html/rfc1918" target="_blank" rel="external">关于2 RFC 1918</a><br><br><a href="http://blog.csdn.net/ztguang/article/details/56479154" target="_blank" rel="external">veth pair</a></p><h2 id="快速配置指南"><a href="#快速配置指南" class="headerlink" title="快速配置指南"></a>快速配置指南</h2><p>下面关于 Docker 网络相关的命令列表。<br>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-b BRIDGE or --bridge=BRIDGE (指定容器挂载的网桥)</div><div class="line">--bip=CIDR (定制 docker0 的掩码)</div><div class="line">-H SOCKET... or --host=SOCKET... (Docker 服务端接收命令的通道)</div><div class="line">--icc=true|false (是否支持容器之间进行通信)</div><div class="line">--ip-forward=true|false (请看下文容器之间的通信)</div><div class="line">--iptables=true|false (是否允许 Docker 添加 iptables 规则)</div><div class="line">--mtu=BYTES (容器网络中的 MTU)</div></pre></td></tr></table></figure><p>下面两个命令在启动服务时指定，也可以在 Docker 容器启动指定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">--dns=IP_ADDRESS... (使用指定的DNS服务器)</div><div class="line">--dns-search=DOMAIN... (指定DNS搜索域)</div></pre></td></tr></table></figure></p><p>下面的选项只有在 docker run 命令下执行，因为它们是针对容器的特性内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-h HOSTNAME or --hostname=HOSTNAME (配置容器主机名)</div><div class="line">--link=CONTAINER_NAME:ALIAS (添加到另一个容器的连接)</div><div class="line">--net=bridge|none|container:NAME_or_ID|host (配置容器的桥接模式)</div><div class="line">-p SPEC or --publish=SPEC (映射容器端口到宿主主机)</div><div class="line">-P or --publish-all=true|false (映射容器所有端口到宿主主机)</div></pre></td></tr></table></figure><h2 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h2><p>Docker 没有为每个容器专门定制镜像，那么怎么自定义配置容器的主机名和 DNS 配置呢?利用虚拟文件挂载容器的 3 个相关配置文件。在容器中使用 mount 命令可以看到挂载信息。<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkbt9zfrwcj30xd04n3z3.jpg" alt=""></p><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 dns 配置通过 /etc/resolv.conf 文件立即得到更新。如果想要手动指定容器的配置。可以使用下面的选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-h HOSTNAME or --hostname=HOSTNAME</div></pre></td></tr></table></figure></p><p>会被写到容器内的 /etc/hostname 和 /etc/hosts 但在容器外看不到，即不会再 docker ps 中显示，也不会在其他的容器的 /etc/hosts 看到</p><blockquote><p>–link=CONTAINER_NAME:ALIAS 选项会在创建容器的时候，添加一个其他容器的主机名到 /etc/hosts 文件中，使用主机名 alias 就可以连接它</p><p>–dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 的主机名</p><p>–dns-search=DOMAIN 设定容器的搜索域，当设定的搜索域为 .example.com ，在搜索一个名为 host 的主机，DNS 不仅搜索 host，还会搜索 host.example.com</p><p>默认用主机上的 /etc/resolv.conf 来配置容器</p></blockquote><h2 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h2><p>容器访问控制，主要通过 Linux 上的 自带防火墙 iptables 进行管理和实现</p><p><strong>容器访问外部网络</strong><br><br>需要本地系统的转发支持</p><blockquote><p>sysctl net.ipv4.ip_forward</p></blockquote><p>如果为 0 ，说明没有开启转发，需要手动开启</p><blockquote><p>sysctl -w net.ipv4.ip_forward=1</p><p>在启动 Docker 服务的时候设定 –ip-forward=true,<br>就会自动设置为 1 。</p></blockquote><p><strong>容器之间的访问</strong><br></p><ol><li>容器之间网络拓补是否互联</li><li>本地系统的防火软件 iptables 是否允许通过</li></ol><p><strong>访问所有端口</strong><br><br>当启动 Docker 服务时，添加 iptables 的 FORWARD 链上。策略通过还是禁止取决于配置 –cc=true 还是 –cc=false 则不会添加 iptables 规则。<br></p><p><strong>访问指定端口</strong><br></p><p>再通过 –icc=false 关闭网络访问后，还可以通过 –link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。</p><blockquote><p>CONTAINER_NAME 必须是 Docker 分配的名字,或使用 –name 参数指定的名字。主机名则不会被识别</p></blockquote><h2 id="映射容器端口到宿主主机的实现"><a href="#映射容器端口到宿主主机的实现" class="headerlink" title="映射容器端口到宿主主机的实现"></a>映射容器端口到宿主主机的实现</h2><p>默认情况下容器可以访问外部网络，但是外部不能访问容器</p><p><strong>容器访问外部实现</strong></p><blockquote><p>因为 windows 无法识别 iptables 这部分放弃了 ┭┮﹏┭┮ 我想换系统</p></blockquote><h2 id="配置-docker0-网桥"><a href="#配置-docker0-网桥" class="headerlink" title="配置 docker0 网桥"></a>配置 docker0 网桥</h2><p>Docker 默认制定了 docker0 接口的 IP 地址和子网掩码，让主机和容器之间可以通过网桥互相通信，他们还给出了 MTU (接口允许接受的最大的传输单元)，通常是 1500 Bytes</p><blockquote><p>–bip=CIDR – IP 地址加掩码格式</p><p>–mtu=BYTES – 覆盖默认的 Docker mtu 配置 也可以在配置文件中配置 DOCKER_OPTS 然后重启服务。</p></blockquote><p>每次创建一个新的容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所以容器的默认网关。</p><h2 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h2><p>除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器<br>，使用 -b BRIDGE 或 –bridge=BRIDGE 来指定使用的网桥<br>。如果服务已经运行，需要停止服务，并删除旧的网桥</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkbwlana9gj30n60hsdjy.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkbwm7dxygj30md0ga41p.jpg" alt=""></p><hr><p>o(╥﹏╥)o 总结不下去，windows根本用不了，这本书让我好蛋疼啊，前面还介绍了 windows 后面直接全部 Linux 下的命令。<br>但是通过进入bash 可以执行，但是文件查看还是很麻烦<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkbwt25lnij30is04gwes.jpg" alt=""></p><p>先告一段落，后期有时间继续学习相关知识</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高级网络配置&lt;ul&gt;
&lt;li&gt;快速配置指南&lt;/li&gt;
&lt;li&gt;配置DNS&lt;/li&gt;
&lt;li&gt;容器访问控制&lt;/li&gt;
&lt;li&gt;端口映射实现&lt;/li&gt;
&lt;li&gt;配置 docker0 网桥&lt;/li&gt;
&lt;li&gt;自定义网桥&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-8)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/08/%E5%AD%A6%E4%B9%A0Docker-2017-10-8/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/08/学习Docker-2017-10-8/</id>
    <published>2017-10-08T05:41:12.000Z</published>
    <updated>2017-10-11T03:33:49.249Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>Docker 中网络功能介绍<ol><li>外部访问容器<ul><li>映射所有接口地址</li><li>映射指定地址的指定端口</li><li>映射到指定地址的任意端口</li><li>查看映射端口配置</li></ul></li><li>容器互联<ul><li>自定义容器命名</li><li>容器互联</li></ul></li></ol></li></ol><a id="more"></a><p>Docker 提供 <strong>外部访问</strong> 或 <strong>容器之间互联</strong> 的方式提供网络服务。</p><h1 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h1><p><code>-P</code> 或<code>-p</code>参数来指定端口映射.</p><ol><li>当使用<code>-P</code>,Docker 会随机映射一个 49000-49900 的端口到内部容器开放的网络端口。   </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -P training/webapp python app.py</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkax1yflwmj30mt095gmk.jpg" alt=""></p><p>使用<code>docker ps -l</code>查看端口号，可以看出，本地主机的 32768 被映射到容器的 5000 端口。此时访问本地的 32768 端口就可以访问容器内 web 应用提供的界面。(可能每个人机器的的端口号不同，访问通过 loc)<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkax38zdwoj314x02kjri.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkax563zbdj30c505zt8t.jpg" alt=""></p><p><code>- p</code>小写 p，可以指定要映射的端口，在指定端口只可以绑定一个容器<br>三种格式：<br></p><ol><li>ip：hostPort：containerPort<br></li><li>ip::containerPort<br></li><li>hostPort:containerPort<br></li></ol><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 hostPort：containerPort 格式本地的 5000 端口映射 容器的 5000 端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 training/webapp python app.py</div></pre></td></tr></table></figure></p><p>此时默认会绑定本地所有接口上的所有地址。</p><blockquote><p>问题:不是指定端口映射?为什么说默认映射所有端口?<br>解决: 在本机上访问端口 5000 就是 访问容器端口 5000</p></blockquote><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>ip：hostPort：containerPort 格式指定映射特定地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</div></pre></td></tr></table></figure></p><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>ip::containerPort 格式指定ip的任意端口到容器 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1::5000 training/webapp python app.py</div></pre></td></tr></table></figure><p>还可以指定 udp 来指定 udp 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</div></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/item/UDP/571511?fr=aladdin" target="_blank" rel="external">关于udp</a></p><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p><code>docker port </code> 查看映射端口配置，以及配置绑定的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker port NAMES 5000</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkayfoc9uzj30f502gt8m.jpg" alt=""></p><blockquote><p>注意: 容器有自己的内部网络和 ip 地址(docker inspect 可以获取所以变量)<br>-p 标记可以多次使用来绑定多个端口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py</div></pre></td></tr></table></figure><h1 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h1><p>容器的连接系统是除了端口映射外，另一种跟容器中应用交互的方式。<br>该系统会在源容器和接受容器之间创建一个隧道，接受容器可以看到源容器指定的信息</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>连接系统依赖容器的名称来执行。因此，首先需要自定义名称来执行。因此，首先需要自定义一个好记的名称.</p><p>使用 –name 标记可以为容器自定义命名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -P --name web training/webapp python app.py</div></pre></td></tr></table></figure></p><p><code>docker ps -l</code>查看容器自定义名称</p><h3 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h3><p><code>–link</code> 参数可以让容器之间安全的进行交互。</p><p>实例：<br><br>创建新的数据库容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d --name db training/postgres</div></pre></td></tr></table></figure></p><p>删除并重新创建 web 容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker rm -f web</div><div class="line"></div><div class="line">docker run -d -P --name web --link db:db training/webapp python app.py</div></pre></td></tr></table></figure></p><p>这样，db容器和 web 容器 创建互联关系</p><p>格式： –link name:alias</p><ol><li>name 表示连接的容器名称</li><li>alias 表示是这个连接的别名</li></ol><blockquote><p>Docker 在两个互联的容器之间建立的安全隧道，不用映射他们的端口到宿主主机。<br>再启动 db 容器并没有使用 -p 和 -P 标记，从而避免了暴露数据库端口到外部网络上。</p></blockquote><p>Docker 2中方式为容器公开连接信息:</p><ol><li>环境变量</li><li>更新 /etc/hosts 文件</li></ol><p>实例1:<br>使用 <code>env</code> 命令查看环境变量</p><p>实例2:<br>除了环境变量，Docker 还添加 host 信息到父容器的 /etc/hosts 的文件。下面<br>是父容器 web 的 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -t -i --rm --link db:db training/webapp /bin/bash</div><div class="line">进入终端</div><div class="line">cat /etc/hosts</div></pre></td></tr></table></figure><p>截图</p><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个<br>是 db 容器的 ip 和主机名。 可以在 web 容器中安装 ping 命令来测试跟db容器的连通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping db</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fkb04z8d3zj30mo0fedho.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker 中网络功能介绍&lt;ol&gt;
&lt;li&gt;外部访问容器&lt;ul&gt;
&lt;li&gt;映射所有接口地址&lt;/li&gt;
&lt;li&gt;映射指定地址的指定端口&lt;/li&gt;
&lt;li&gt;映射到指定地址的任意端口&lt;/li&gt;
&lt;li&gt;查看映射端口配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容器互联&lt;ul&gt;
&lt;li&gt;自定义容器命名&lt;/li&gt;
&lt;li&gt;容器互联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-7)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/07/%E5%AD%A6%E4%B9%A0Docker-2017-10-7/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/07/学习Docker-2017-10-7/</id>
    <published>2017-10-07T01:33:17.000Z</published>
    <updated>2017-10-11T03:33:46.522Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>数据管理<ul><li>数据卷</li><li>数据卷容器</li><li>备份、恢复、迁移数据卷</li></ul></li></ol><a id="more"></a><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>本小节学习在 Docker 内部以及容器之间管理数据，主要方式:</p><ol><li>数据卷(Data volumes)</li><li>数据卷容器 (Data volume containers)</li></ol><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p>数据卷是一个提供一个或者多个容器使用的 <strong>特殊目录</strong> 它绕过 UFS ，可以提供很多有用的特性:</p><ol><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的更新可以立马生效</li><li>数据卷的更新不会影响镜像</li><li>数据卷默认一直存在，即使容器被删除</li></ol><p><strong>创建一个数据卷</strong><br>在使用 docker run 命令，使用 -v 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p><p>实例:<br><br>下面创建一个名为 web 的容器，并加装一个数据卷到容器的 /webapp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -P --name web -v /webapp training/webapp python app.py</div></pre></td></tr></table></figure></p><blockquote><p>注意: 也可以在 Dockerfile 中使用 VOLUME 来添加一个或者多个新的卷到由该镜像创建的任意容器。</p></blockquote><p><strong>删除数据卷</strong></p><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，也不出现垃圾回收机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除命令加 <code>-v </code>参数，docker rm -v 命令删除容器移除数据卷</p><p><strong>挂载一个主机目录作为数据卷</strong></p><p>-v 标记也可以指定挂载一个本地主机的目录到容器中去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -P  --name web -v /src/webapp:/opt/webapp training/webapp python app.py</div></pre></td></tr></table></figure></p><p>上面的命令加载主机 /src/webapp 目录到容器的 /opt/webapp目录。</p><blockquote><p>注意： Dockerfile 不支持这种用法，这是因为Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以现在还不能支持</p><p>Docker 挂载数据卷默认权限是读写，用户也可以通过:ro指定为只读</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</div></pre></td></tr></table></figure><p>加了 :ro 之后，就挂载为只读了</p><p><strong>查看数据卷的具体信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker inspect web ...</div></pre></td></tr></table></figure></p><p>在输出的内容中找到其中和数据卷相关的部分</p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>如果你有一些持续更新的数据需要在容器之间共享,最好创建数据卷容器。专门提供数据卷为其他容器挂载的。</p><p>实例：创建 dbdata 数据卷容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -v /dbdata --name dbdata  training/postgres echo Data-only container for postgres</div></pre></td></tr></table></figure></p><p>在其他容器中 使用 –volumns-from 来挂载dbdata 容器中的数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker run -d -volumns-from dbdata --name db1 training/postgres</div><div class="line"></div><div class="line">docker run -d -volumns-from dbdata --name db2 training/postgres</div><div class="line"></div><div class="line">docker run -d -volumns-from db1 --name db3 training/postgres</div></pre></td></tr></table></figure></p><blockquote><p>注意：使用 –volumes-from 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p></blockquote><h3 id="利用数据卷容器来备份、恢复、迁移数据卷"><a href="#利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="利用数据卷容器来备份、恢复、迁移数据卷"></a>利用数据卷容器来备份、恢复、迁移数据卷</h3><p><strong>备份</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker run --volumes-from dbdata -v $(pwd):/backup ubuntu</div><div class="line">tar cvf /backup/backup.tar /dbdata</div></pre></td></tr></table></figure><p>创建一个挂载 dbdata 的容器，并从主机挂载到 backup 目录，之后执行 tar 命令生成一个 .tar 文件的备份</p><p><strong>恢复</strong><br>如果恢复一个数据到一个容器，首先创建带空数据卷的容器 dbdata2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</div></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载容器卷中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --volumes-from dbdata2 -v $(pwd): /backup busybox tar xvf /backup/backup.tar</div></pre></td></tr></table></figure></p><p>为了查看或者验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --volumes-from dbdata2 busybox /bin/ls /dbdata</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据管理&lt;ul&gt;
&lt;li&gt;数据卷&lt;/li&gt;
&lt;li&gt;数据卷容器&lt;/li&gt;
&lt;li&gt;备份、恢复、迁移数据卷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-6)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/06/%E5%AD%A6%E4%B9%A0Docker-2017-10-6/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/06/学习Docker-2017-10-6/</id>
    <published>2017-10-06T08:18:07.000Z</published>
    <updated>2017-10-11T03:33:42.786Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>访问仓库<ul><li>Docker Hub</li><li>私有仓库</li><li>仓库配置文件</li></ul></li></ol><a id="more"></a><h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><p>仓库是集中存放镜像的地方。Registry 注册服务器是管理仓库的具体服务器，每个服务器上面有很多个仓库，每个仓库对应有许多镜像。从这方面来说，仓库可以被认为是一个具体的项目或者目录。需要我们对注册服务器做区分。</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker Hub 是官方维护的公共仓库 Docker Hub ，其中已经包括了超过 15,000 的镜像。大部分都可以从 Docker Hub 中下载镜像来实现。</p><p><strong>登录</strong></p><p><strong>基本操作</strong></p><p>用户无需登录即可通过在 <code>docker search</code>查找官方仓库中的镜像，<code>docker pull</code>来下载到本地</p><p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker search centos</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8mpzjemxj311f0g5whg.jpg" alt=""><br>docker search + 搜索的关键词,其中我们可以看出，搜索出来的字段，包括镜像名称，描述，星级，是否官方创建、是否自动创建。</p><ol><li>名称:一般官方创建、维护、支持的镜像都是单个单词作为名字。用户创建的镜像一般名称格式 username/</li><li>描述:对镜像的说明</li><li>星级:表示该用户的受欢迎程度</li></ol><blockquote><p>-s N 参数可以在查找中指定显示 N 星以上的镜像(新版本推荐filter=starts=N 参数)</p></blockquote><p>方式 1:<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8n6mif7vj30zb03lq39.jpg" alt=""></p><p>方式 2:<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8n7otbg6j30ym039weq.jpg" alt=""></p><p><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></p><p><strong>自动创建</strong><br>Automated Builds 自动创建功能对于需要经常升级镜像的程序来说，十分方便。自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站(支持 GitHub 和 BitBucket )上的项目，一旦项目发生新的提交，则自动执行创建。</p><p>操作：</p><ol><li>登录 Docker Hub ，以及目标网站;</li><li>在目标网站中连接到 Docker Hub；</li><li><p>Docker Hub 中配置一个自动创建<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8ntdlmpyj31af0bcjsk.jpg" alt=""></p></li><li><p>选取一个目标网站中的项目(需要含 Dockerfile)<br>和分支； 指定 Dockerfile 的位置，并提交创建</p></li><li>在 Docker Hub 自动创建页面跟踪每次创建的状态</li></ol><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>有时候使用 Docker Hub 不方便，用户可以创建一个本地仓库供私人使用。<br>docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库</p><p><strong>安装运行docker-registry</strong></p><p>容器运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 registry</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8o49sb9hj30il0530t4.jpg" alt=""></p><p>使用官方的 registry 镜像来启动本地的私有仓库</p><p>默认情况下，仓库会被创建在容器的 /var/lib/registry 下。可以通过 -v 参数来将镜像文件存放在本地的指定路径。下面将上传的镜像放到 /opt/data/registry 目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry</div></pre></td></tr></table></figure></p><p><a href="http://www.cnblogs.com/lienhua34/p/4922130.html" target="_blank" rel="external">Docker私有仓库Registry的搭建验证</a><br><br><a href="https://my.oschina.net/3233123/blog/873118" target="_blank" rel="external">搭建docker本地镜像仓库</a></p><p><strong>在私有仓库上传、下载、搜索镜像</strong></p><p>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送到仓库里，别的机器就可以下载</p><ol><li>docker images 查看已有的镜像</li><li>docker tag 将 deal194 标记为 127.0.0.1:5000/test</li></ol><p>(格式:docker tag images[:tag][registryhost/][username/name[:tag])</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8qvot09hj30hf012q2s.jpg" alt=""></p><ul><li>docker push 127.0.0.1:5000/test 使用 push 上传标记的镜像</li></ul><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8qunuiv3j30g104d0sy.jpg" alt=""></p><ul><li>curl 查看仓库中的镜像</li></ul><h3 id="仓库配置文件"><a href="#仓库配置文件" class="headerlink" title="仓库配置文件"></a>仓库配置文件</h3><p>Docker 的 Registry 利用配置文件提供了一些仓库的模板，用户直接使用它们来进行开发或生产部署</p><p><strong>模板</strong><br><br>在 config_sample.yml 文件中,可以看到一些模板段:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">common ：基础配置</div><div class="line">local ：存储数据到本地文件系统</div><div class="line">s3 ：存储数据到 AWS S3 中</div><div class="line">dev ：使用 local 模板的基本配置</div><div class="line">test ：单元测试使用</div><div class="line">prod ：生产环境配置（基本上跟s3配置类似）</div><div class="line">gcs ：存储数据到 Google 的云存储</div><div class="line">swift ：存储数据到 OpenStack Swift 服务</div><div class="line">glance ：存储数据到 OpenStack Glance 服务，本地文件系统为后备</div><div class="line">glance-swift ：存储数据到 OpenStack Glance 服务，Swift 为后备</div><div class="line">elliptics ：存储数据到 Elliptics key/value 存储</div></pre></td></tr></table></figure></p><p>用户也可以添加自定义的模板段:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问仓库&lt;ul&gt;
&lt;li&gt;Docker Hub&lt;/li&gt;
&lt;li&gt;私有仓库&lt;/li&gt;
&lt;li&gt;仓库配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-5)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/05/%E5%AD%A6%E4%B9%A0Docker-2017-10-5/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/05/学习Docker-2017-10-5/</id>
    <published>2017-10-05T12:23:04.000Z</published>
    <updated>2017-10-11T03:33:40.020Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ul><li>镜像的实现原理<ol><li>操作 Docker 容器<ul><li>启动容器</li><li>后台(background)运行</li><li>终止容器</li><li>进入容器</li><li>导出和导入容器</li><li>删除容器</li><li>清理所有处于终止状态的容器</li></ul></li></ol></li></ul><a id="more"></a><h1 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h1><p>Docker 镜像是怎么实现增量的修改和维护的?每个镜像都由很多层次构成，<br>Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。</p><p>通常 Union FS 有两个用途:</p><ol><li><p>一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下</p></li><li><p>另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p></li></ol><p><a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="external">关于 UFS</a></p><h1 id="操作-Docker-容器"><a href="#操作-Docker-容器" class="headerlink" title="操作 Docker 容器"></a>操作 Docker 容器</h1><p>容器是 Docker 又一核心概念</p><blockquote><p>容器对应虚拟机可以理解为模拟运行的一整套操作系统(提供了运行态环境和其他操作系统)和跑在上面的应用。下面学习容器的创建、启动和停止等</p></blockquote><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><ol><li>基于镜像创建一个容器并启动</li><li>将在终止状态(stopped)的容器重新启动</li></ol><p>实例1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos; Hello world</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8ajf8xf1j30op023q2v.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -i ubuntu:14.04 /bin/bash</div></pre></td></tr></table></figure><p>-t 选项让 Docker 分配一个伪终端，并绑定到容器的标准输入上，-i 则让容器的标准输入保持打开，进入交互终端，用户可以通过所创建的终端来输入命令,<br><img src="http://ww1.sinaimg.cn/large/006rAlqhgy1fk8ag73blxj30k404bwep.jpg" alt=""></p><blockquote><p>当利用 docker run 来创建容器时， Docker 在后台运行的标准操作包括:</p><ol><li>检查本地是否存在指定镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器</li><li>分配一个文件系统,并在只读的镜像层外面挂载一层 <strong>可读写层</strong></li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去，从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ol></blockquote><p><a href="https://baike.baidu.com/item/pwd/3730074?fr=aladdin" target="_blank" rel="external">关于 pwd</a></p><p>实例2:<br>利用 <code>docker start</code> 命令，直接将一个已经终止的容器启动运行。</p><blockquote><p>容器的核心是为所执行的应用程序，所需要的资源都是应用程序运行所必须的。在终端中利用 <code>ps</code> 和 <code>top</code> 来查看进程信息。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8baqua2ij30it065dg9.jpg" alt=""></p><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源利用率极高，体现了 Docker 轻量级虚拟化</p><p>top:<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8bbsxqloj30n403sq31.jpg" alt=""></p><h3 id="后台-background-运行"><a href="#后台-background-运行" class="headerlink" title="后台(background)运行"></a>后台(background)运行</h3><blockquote><p>通常的时候需要让 Docker 在后台运行，而不是直接将执行结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现</p></blockquote><p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div></pre></td></tr></table></figure></p><p>容器会把输出的结果打印到宿主机上面</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8bnz5rb3j30ru050glq.jpg" alt=""></p><p>使用 <code>-d</code>参数运行容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8bqk9upaj30qx01gjre.jpg" alt=""></p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id ,也可以通过 <code>docker ps</code> 命令来查看容器信息</p><p>要获取容器的输出信息，可以通过 <code>docker logs [container ID or Names]</code></p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>使用 <code>docker stop </code> 命令来终止一个运行中的容器<br><br>终止状态的容器可以用 <code>docker ps -a</code> 命令看到。<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8c25eyv7j30rk09j40c.jpg" alt=""><br>现在我们可以用我们刚才讲的<code>docker start</code> 重启结束的容器</p><blockquote><p><code>docker restart</code> 可以结束正在运行的容器，然后重新启动</p></blockquote><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 -d 参数时，容器启动后进入后台。某些时候需要进入容器进行操作：</p><ol><li>attach 命令</li><li>nsenter 命令</li></ol><p>实例1：<br>attach 命令<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8d687xc4j30rs07emy6.jpg" alt=""></p><p>当多个窗口同时 attach 到同一个容器的时候,所以窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口也无法执行操作。</p><p>实例2：<br>nsenter 命令</p><blockquote><p>书上介绍的都是 Linux 系统下进行的，因为自己电脑上 windows 这一部分，先暂停</p></blockquote><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><p><strong>导出容器</strong><br>导出本地容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps -a</div></pre></td></tr></table></figure></p><p>查询已经停止的容器 ID<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8djp382aj30pv01xwej.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export commitID &gt; xxx.tar</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk8dm0wxb2j30ke01a744.jpg" alt=""><br><strong>导入容器快照</strong></p><p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import - test/ubuntu:v1.0</div></pre></td></tr></table></figure></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p><code>docker rm</code>命令删除处于终止状态的容器。 -f 强制删除容器，用在运行的容器中。</p><h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker rm &amp;(docker ps -a -q)</div></pre></td></tr></table></figure><p>windows 下进入 git bash 运行上面的命令删除</p><blockquote><p>注意；这个命令其实会尝试删除所有的包括还运行中的容器，不过就像上面提过的 docker rm 默认不会删除运行中的容器。这个命令是在 linux 系统下执行</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像的实现原理&lt;ol&gt;
&lt;li&gt;操作 Docker 容器&lt;ul&gt;
&lt;li&gt;启动容器&lt;/li&gt;
&lt;li&gt;后台(background)运行&lt;/li&gt;
&lt;li&gt;终止容器&lt;/li&gt;
&lt;li&gt;进入容器&lt;/li&gt;
&lt;li&gt;导出和导入容器&lt;/li&gt;
&lt;li&gt;删除容器&lt;/li&gt;
&lt;li&gt;清理所有处于终止状态的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-4)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/04/%E5%AD%A6%E4%B9%A0Docker-2017-10-4/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/04/学习Docker-2017-10-4/</id>
    <published>2017-10-04T02:30:02.000Z</published>
    <updated>2017-10-11T03:33:37.231Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录:</p><ol><li>其他生成镜像的方法<br><ul><li>从 rootfs 压缩包导入</li><li>docker save 和 docker load</li></ul></li><li>删除本地镜像<ul><li>用 ID、镜像名、摘要删除镜像</li><li>Untagged 和 Deleted</li><li>用 docker images 命令来配合</li></ul></li></ol><a id="more"></a><blockquote><p>今天可能要出去，所以一大早上就要把今天要学习的内容学完ヾ(◍°∇°◍)ﾉﾞ</p></blockquote><h1 id="其他生成镜像的方法"><a href="#其他生成镜像的方法" class="headerlink" title="其他生成镜像的方法"></a>其他生成镜像的方法</h1><p>除了使用 Dockerfile 生成镜像的方法外,由于各种特殊需求和历史原因，还提供了其他方法用以生成镜像</p><h3 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h3><p>格式: docker import [选项]&lt;文件&gt;|<url>|-[&lt;仓库名&gt;[:&lt;标签&gt;]]</url></p><p>解释: 压缩包可以是本地文件、远程 Web 文件、甚至是从标准输入中得到。 压缩包将会在镜像/目录展开，并直接作为镜像的第一次提交</p><p>实践:</p><blockquote><p>比如我们想要创建一个 OpenVZ 的 Ubuntu 14.04 模板的镜像:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker import</div><div class="line"> http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</div><div class="line"> openvz/ubuntu:14.04</div></pre></td></tr></table></figure><p>因为命令过长 上面一条命令 我把他分为三行，这条命令下载 .tar.gz 文件，并作为根文件系统展开导入，并保存为镜像  openvz/ubuntu:14.04，导入成功后，<code>docker images</code>查看镜像，或者<code>docker history openvz/ubuntu:14.04</code>查看历史</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk615ufvdgj30rx02i3yl.jpg" alt=""></p><p><a href="https://baike.baidu.com/item/openVZ/3270542?fr=aladdin" target="_blank" rel="external">关于 openVZ </a></p><h3 id="docker-save-和-docker-load"><a href="#docker-save-和-docker-load" class="headerlink" title="docker save 和 docker load"></a>docker save 和 docker load</h3><p>Docker 还提供 docker save 和 docker load 命令用于将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来</p><blockquote><p>这是在没有 Docker Registry 时的做法，现在已经不推荐,镜像迁移应该直接使用 Docker Registry ，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p></blockquote><p><strong>保存镜像</strong><br>使用 docker save 将镜像保存为归档文件。</p><p>实践:</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk618f5exxj30p9021jrf.jpg" alt=""></p><p>保存镜像命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save apline | gzip &gt; apline-latest.tar.gz</div></pre></td></tr></table></figure></p><blockquote><p>问题： windows 不识别 gzip 命令<br>解决： 下载 gzip for windows 版本</p></blockquote><p>将 alpine-latest.tar.gz 复制到另一个机器上，然后使用下面命令加载镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -i alpine-latest.tar.gz</div></pre></td></tr></table></figure></p><blockquote><p> 如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我<br>们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功<br>能：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &apos;cat | do</div><div class="line">cker load&apos;</div></pre></td></tr></table></figure><p><a href="https://baike.baidu.com/item/ssh/10407?fr=aladdin" target="_blank" rel="external">关于 ssh</a><br><br><a href="http://blog.csdn.net/benpaobagzb/article/details/50768382" target="_blank" rel="external">关于 pv</a></p><h1 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h1><p>格式: docker rmi [选项]&lt;镜像1&gt;[&lt;镜像2&gt;…]</p><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>实践:</p><blockquote><p>比如我们要删除,apline 镜像，可以执行;</p></blockquote><ul><li>docker iamges 查看镜像信息</li></ul><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk61o95xc9j30py0840tv.jpg" alt=""></p><ul><li>docker rmi 镜像ID 如果删除不了 加 -f 强制删除<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk61t7iir4j30q605zjs5.jpg" alt=""></li></ul><p>或者 <code>docker ps -a</code> 查看所有 container id ，然后先 停止所有 container ID 然后在删除</p><ul><li>使用 镜像名，删除 <code>docker rmi 仓库名:标签</code></li></ul><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk61wa270pj30n303cmxd.jpg" alt=""></p><ul><li>更准确的使用 镜像摘要删除镜像 <code>docker images –digests</code></li></ul><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk61ziwlobj319g09xabz.jpg" alt=""></p><h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>如果仔细发现，删除行为 有两类</p><ol><li>Deleted</li><li>Untagged</li></ol><blockquote><p>前面介绍过,镜像的唯一标识是其 ID 和 摘要</p></blockquote><ol><li>我们都知道镜像的唯一标示是 ID 和 摘要 ，而一个镜像可以有更多个标签，因此当我们指定标签删除镜像，如果还有其他标签的对应这个镜像，就不会发生delete 行为，而 untaggged 使我们取消了所有的标签，当所有标签取消后就可以出发 delete 行为</li><li>镜像之间的依赖，镜像是多层结构，删除的时候也是从上层向基础层方向依次进行判断删除，如果其他镜像依赖于待删除的某一层，也不会触发 delete 效果</li><li>容器对镜像的依赖，如果有用这个镜像启动的容器存在，那么就不能删除镜像。容器是以镜像为基础添加一层容器存储器，组成的多层存储结构去运行。因此该镜像如果被这个容器所依赖的，就需要先删除容器，在删除镜像</li></ol><h1 id="用-docker-images-命令来配合"><a href="#用-docker-images-命令来配合" class="headerlink" title="用 docker images 命令来配合"></a>用 docker images 命令来配合</h1><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker rmi $(docker images -q -f dangling=true)</div></pre></td></tr></table></figure><p>删除所有仓库名为 redis 的镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker rmi $(docker images -q redis)</div></pre></td></tr></table></figure></p><p>删除所有 mongo:3.2 之前的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker rmi $(docker images -q -f before=mongo:3.2)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其他生成镜像的方法&lt;br&gt;&lt;ul&gt;
&lt;li&gt;从 rootfs 压缩包导入&lt;/li&gt;
&lt;li&gt;docker save 和 docker load&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;删除本地镜像&lt;ul&gt;
&lt;li&gt;用 ID、镜像名、摘要删除镜像&lt;/li&gt;
&lt;li&gt;Untagged 和 Deleted&lt;/li&gt;
&lt;li&gt;用 docker images 命令来配合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-3)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/03/%E5%AD%A6%E4%B9%A0Docker-2017-10-3/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/03/学习Docker-2017-10-3/</id>
    <published>2017-10-03T01:54:41.000Z</published>
    <updated>2017-10-11T03:33:34.227Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录：</p><ol><li>ENV 设置环境变量</li><li>ARG 构建参数</li><li>VOLUME 定义匿名类</li><li>EXPOSE 声明端口</li><li>USER 指定当前用户</li><li>HEALTHCHECK 检查健康</li><li>ONBULID 为他人做嫁衣</li></ol><blockquote><p>接着上一节学习 Dockerfile 的指令</p></blockquote><a id="more"></a><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>标题中已经告诉我们 ENV 是设置环境变量的，环境变量大家都不陌生，就是定义一个环境变量，可以在程序中重复使用，一般用在需要大量使用该参数的地方。这个好处就是，方便代码的维护。</p><p>格式：</p><ol><li>ENV key value</li><li>ENV key1=value1 key2=value2</li></ol><p>这个指令很容易理解，直接上图吧</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk4u0yesfgj30r40iqjxc.jpg" alt=""></p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>跟 ENV 效果一样，都是设置环境变量，但 ARG 的区别在于，它是设置 构建环境 的环境变量。意思就是当时用构建命令时使用的。</p><p>格式：<br>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p><p>在 Dockerfile 中 的 ARG 指令是定义参数名称,以及定义其默认值。该默认值可以在构建命令中覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker --build-arg&lt;参数名&gt;=&lt;值&gt;</div></pre></td></tr></table></figure><blockquote><p>需要注意的是，在1.13版本之前 要求使用 –build-arg 中的参数名,必须在 Dockerfile 中用 ARG 定义。在1.13开始，这种严格的限制解除了，不会报错退出，而只是显示警告信息。</p></blockquote><p>实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">FROM xxx</div><div class="line">ARG user=xxx</div><div class="line">...</div></pre></td></tr></table></figure><p>在上面的 Dockerfile 中 ARG 指定了我们 user ，当我们构建这个镜像的时候，如果想更换用户，就可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker --build-arg user=2xxx 构建后的名称</div></pre></td></tr></table></figure></p><h3 id="VOLUME-定义匿名类"><a href="#VOLUME-定义匿名类" class="headerlink" title="VOLUME 定义匿名类"></a>VOLUME 定义匿名类</h3><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用,其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件保存目录挂载为卷。在 Dockerfile 中，我们事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会像容器存储层写入大量数据。<br><a href="https://baike.baidu.com/item/%E6%8C%82%E8%BD%BD/2366421?fr=aladdin" target="_blank" rel="external">关于挂载</a></p><p>格式：<br>VOLUME [“&lt;路径1&gt;”，”&lt;路径2&gt;”…]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VOLUME /data</div></pre></td></tr></table></figure><p>该命令表示，在运行时自动挂载为匿名类,任何想 /data 中写入的信息都不会记录进容器存储层，从而保证容器存储层的无状态化。运行时也可以覆盖掉这个匿名挂载设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker run -d -v mydata:/data xxxx</div><div class="line">&lt;!--mydata这个命名卷挂载了 /data</div><div class="line"> 这个位置--&gt;</div></pre></td></tr></table></figure></p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式：<br>EXPOSE 端口1[端口2…]</p><p>EXPOSE 只是声明运行时容器提供服务端口号,这个只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile中写入声明的好处：</p><ol><li>帮助镜像使用者理解这个镜像服务的守护进程，以方便映射</li><li>在运行使用随机端口映射时,也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ol><blockquote><p>以前的 Docker 所以容器是互通的，这存在于安全性问题。现在通过自定义网络可以实现容器间的互联与隔离。要将 EXPOSE 和 运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt;区分开来。</p><p>-p 是映射宿主端口和容器端口，就是容器对应的端口服务公开给外界访问,而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p></blockquote><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式：<br>WORKDIR  工作目录路径</p><p>该指令指定工作目录，以后各层的当前目录就会被改为指定的目录，如果不存在，就自动创建</p><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：USER 用户名<br>USER 指令与 WORKDIR 相似，都是改变环境状态并影响以后的层。一个改变目录，一个是改变之后执行命令的身份。</p><h3 id="HEALTHCHECK-检查健康"><a href="#HEALTHCHECK-检查健康" class="headerlink" title="HEALTHCHECK 检查健康"></a>HEALTHCHECK 检查健康</h3><p>格式： HEALTHCHECK [选项] CMD &lt;命令&gt; :设置检查容器健康状况的命令</p><p>HEALTHCHECK NONE :如果基础镜像有检查健康检查指令，可以屏蔽其他健康检查指令。<br>之前没有什么 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主程序是否退出来判断容器是否状态异常。在程序进入死锁状态或者，死循环状态，应用进程并不退出，也就无法提供服务了。</p><p>当使用 HEALTHCHECK 指令后,用其启动容器,初始状态会变成 starting ，在 HEALTHCHECK 指令检查成功后变为 healthy ,如果连续一定次数失败,则会变为 unhealthy 。</p><p>选项：<br><br>–interval=&lt;间隔&gt;：两次健康检查的间隔，默认30秒<br><br>–timeout=&lt;时长&gt;：如果超过这个时间，表示失败<br><br>–retries=&lt;次数&gt;:当连续失败状态为 unhealthy 默认 3 次</p><p>假设我们的镜像是一个最简单的 Web 服务，我们希望增加健康检查来判断其Web服务是否在正常工作，我们可以用 curl 帮助判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FROM nginx</div><div class="line">RUN apt-get update \</div><div class="line">&amp;&amp; apt-get install -y curl \</div><div class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line">HEALTHCHECK --interval=5s --timeout=3s \</div><div class="line">CMD curl -fs http://localhost/ || exit 1</div></pre></td></tr></table></figure></p><p>构建 <code>docker build -t myweb:v1 .</code><br><br>启动容器<code>docker run -d –name web -p 81:80 myweb:v1</code><br><br>查询状态<code>docker ps</code><br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk54bh1xwwj312n02lglr.jpg" alt=""></p><h3 id="ONBULID-为他人做嫁衣"><a href="#ONBULID-为他人做嫁衣" class="headerlink" title="ONBULID 为他人做嫁衣"></a>ONBULID 为他人做嫁衣</h3><p>格式: ONBULID  其他指令<br><br>这是一个特殊的指令,它后面跟的是其它指令,比如 RUN , COPY 等, 而这些指令,在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像,去构建下一级镜像的时候才会被执行。</p><p>假设我们要制作 Node.js 所写的应用的镜像.Node 使用 npm进行包管理。<br>有依赖、配置、启动信息等会放 package.json 文件里。一般 npm install 获取依赖，然后 npm start 启动应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">COPY ./package.json /app</div><div class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></p><p>如果我们构建第二个相同项目，我们可能会复制，如果有很多文件，文件副本也很多，版本控制就越困难。如果第一个文件出现需要修改的问题，我们如何同步多个项目?</p><ol><li>写一个基础镜像，让各个需要构建的项目都指向基础镜像，重新构建，会继承基础镜像的更新。构建 <strong>基础</strong> 镜像，起名 my-node   (docker build -t my-node .)<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk54z174uaj30en06paaw.jpg" alt=""></li></ol><p>其他项目的 Dockerfile 指向基础镜像 my-node，就是上面那幅图<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk550ut2o1j30g4077dgv.jpg" alt=""></p><p>（问题解决了一半，如果我需要给npm install 加一些参数）</p><ol><li>ONBUILD 可以解决这个问题。 使用 ONBUILD 重写 Dockerfile <strong>基础镜像my-node</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FROM node:slim</div><div class="line">RUN mkdir /app</div><div class="line">WORKDIR /app</div><div class="line">ONBUILD COPY ./package.json /app</div><div class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]</div><div class="line">ONBUILD COPY . /app/</div><div class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</div></pre></td></tr></table></figure></li></ol><p>加上 ONBUILD 的指令并不会执行，然后各个项目的 Dockerfile 都为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FROM my-node</div></pre></td></tr></table></figure><p>只有一行的 Dockerfile 构建的时候，就执行 基础镜像里面的 ONBUILD 后面的，成功的将但钱项目的代码复制进镜像，当遇到修改时 我们知道修改一份 镜像，然后构建成基础镜像，供其他镜像使用。</p><hr><p>最后是关于网上我觉得不错的博客，很崇拜比自己写的好的人，对于我这个快要毕业的人来说，还有许多要学，现在唯一能做的就是让自己不骄不躁，安心做好当下的事情，我相信即使毕业了，自己的技术还不够找一份好工作，我也会坚持学习！ヾ(◍°∇°◍)ﾉﾞ<br><br><a href="https://deepzz.com/post/dockerfile-reference.html#toc_20" target="_blank" rel="external">如何写Dockerfile，Dockerfile 参考文档</a><br><br><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Docker 官方文档</a><br><br><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="external">Dockerfile 实践文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ENV 设置环境变量&lt;/li&gt;
&lt;li&gt;ARG 构建参数&lt;/li&gt;
&lt;li&gt;VOLUME 定义匿名类&lt;/li&gt;
&lt;li&gt;EXPOSE 声明端口&lt;/li&gt;
&lt;li&gt;USER 指定当前用户&lt;/li&gt;
&lt;li&gt;HEALTHCHECK 检查健康&lt;/li&gt;
&lt;li&gt;ONBULID 为他人做嫁衣&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;接着上一节学习 Dockerfile 的指令&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>简单算法(一)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/02/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95-%E4%B8%80/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/02/简单算法-一/</id>
    <published>2017-10-02T11:34:41.000Z</published>
    <updated>2017-10-25T02:42:11.066Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从极客学院 wiki 中下载的电子书《坐在马桶上学算法》,虽然入门编程已经两年了，但从来没有学习有关算法的知识，因为以后励志想要成为一名合格的程序员，知道算法在编程中是不可或缺的，但现在太正式的学习又会让自己失去信心，所以网上找到这本书，算是培养一下自己的兴趣吧，这本书特点是图文并茂，风趣易懂。(要求:C语言基础) 我用的编译器：Pelles C</p></blockquote><a id="more"></a><h1 id="最快最简单的排序-桶排序"><a href="#最快最简单的排序-桶排序" class="headerlink" title="最快最简单的排序(桶排序)"></a>最快最简单的排序(桶排序)</h1><blockquote><p>问题：生活中有许多需要处理排序的问题，考试中，评奖学金等等，如何编写一段程序</p></blockquote><p>解决:只需借助一个一维数组就可以解决。<br>假设:我们编写一个排序 5 个数的大小</p><ol><li>申请一个大小为 11 的数组 int a[11]</li><li>初始化 a[0]~a[10] 都为 0 ,表示没有分数</li><li>处理这 5 个数 ,因为是排序分数 ，利用数组输出特性,将分数的值存在对应的位置，比如 5分 就存在 a[5] 中,并把值改为 1 ，表示出现过的次数</li><li>输出:遍历数组，依次打印，数值&gt;0 的数组多少就打印几次</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">int</span> a[<span class="number">11</span>],i,j,t;</div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</div><div class="line">a[i]=<span class="number">0</span>;<span class="comment">//初始化为0</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</div><div class="line">&#123;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</div><div class="line">a[t]++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)</div><div class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=a[i];j++)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">getchar();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fkuah24mr1j307n04za9x.jpg" alt=""></p><p>这种排序方法我们暂且叫”桶排序”,这个不是正真的桶排序,这个程序好比 11 个桶,编号从 0~10 每出现一个数,就将对应编号的桶加1，然后按顺序将通的编号打印出来，打印的次数为桶中的个数</p><p>上面的只接受 10 以内的排序，如果需要更大范围排序，需要修改数组的大小。如何实现从大到小排序？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 只需要将数组从大到小遍历就可以了</span></div><div class="line"><span class="keyword">for</span>(i=<span class="number">10</span>;i&gt;=<span class="number">0</span>;i--)</div><div class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=a[i];j++)</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div></pre></td></tr></table></figure><p>时间复杂度: O(m+n+m+n)<br>m:桶的数量<br>n:输入的次数</p><blockquote><p> 如果每个数据对应一个名字 这种简单算法就无法进行,这就要用到冒泡排序</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从极客学院 wiki 中下载的电子书《坐在马桶上学算法》,虽然入门编程已经两年了，但从来没有学习有关算法的知识，因为以后励志想要成为一名合格的程序员，知道算法在编程中是不可或缺的，但现在太正式的学习又会让自己失去信心，所以网上找到这本书，算是培养一下自己的兴趣吧，这本书特点是图文并茂，风趣易懂。(要求:C语言基础) 我用的编译器：Pelles C&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-2)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/02/%E5%AD%A6%E4%B9%A0Docker-2017-10-2/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/02/学习Docker-2017-10-2/</id>
    <published>2017-10-02T02:47:10.000Z</published>
    <updated>2017-10-11T03:33:31.710Z</updated>
    
    <content type="html"><![CDATA[<p>本节目录</p><ol><li>Dockerfile 指令详解<ol><li>COPY 复制文件</li><li>ADD 更高级的复制文件</li><li>CMD 容器启动命令</li><li>ENTRYPOINT 入口点</li></ol></li></ol><a id="more"></a><h1 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h1><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：<br>COPY &lt;源路径&gt;…&lt;目标路径&gt;<br>COPY [“&lt;源路径&gt;”,…”&lt;目标路径&gt;”]<br>和 RUN指令一样,也有两种格式,一种命令行，一种函数调用的方式</p><p>COPY 指令将从构建上下文目录中 &lt;源路径&gt;的文件 / 目录 复制到新的一层镜像内的 &lt;目标路径&gt; 位置。 比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">COPY package.json /usr/src/app/</div></pre></td></tr></table></figure></p><p>&lt;源路径&gt;可以是多个，可以使用通配符，规则要满足 Go 的 filepath.Match 规则<br>&lt;目标路径&gt;可以是容器内的绝对路径，也可以是相对于工作目录的相对路径，目标目录不需要事先创建，当目录不存在会在复制文件前创建确实目录</p><blockquote><p>使用 COPY 指令，源文件的各种元数据都会保留。比如 读、写、执行权限、文件变更时间等</p></blockquote><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令更 COPY 的格式和性质基本一致。但是在 COPY 的基础上增加了一些功能。</p><ol><li><p>&lt;源路径&gt; 可以是一个 URL ,这种情况下， Docker 引擎会尝试去下载这个链接的文件。下载后文件权限自动设置为600，当需要修改权限，还需要额外的一层 RUN 进行权限调整，如果 URL 是一个压缩文件，需要解压缩，同样也需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令然后使用工具处理权限，解压缩，然后清理无用的文件  —-扯了那么多，就是这个功能不实用？？</p></li><li><p>&lt;源路径&gt;是一个 tar 压缩文件的话，压缩格式为 gzip , bzip2 以及 xz 的情况下， ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt;  </p></li></ol><blockquote><p> ADD 最适合的场景就是自动解压缩的时候，并且需要注意 ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得缓慢? 所以在 COPY 和 ADD 指令中，当文件复制使用 COPY 指令，当涉及到自动解压缩的场合使用 ADD</p></blockquote><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>格式：</p><ol><li>shell 格式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CMD &lt;命令&gt;</div></pre></td></tr></table></figure><ol><li>exec 格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;]</div></pre></td></tr></table></figure></li></ol><p>容器是进程，当启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是注定默认的容器的启动命令的</p><p>比如，ubuntu 镜像默认CMD 是 /bin/bash ,如果我们在 <strong>运行时</strong> 指定运行别的命令,如 docker run -it ubuntu cat /etc/os-release。就是用 cat  /etc/os-release 命令替换默认命令，输出系统信息。(注意cat后面跟空格)</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk3zdwfy5hj30mx071wf2.jpg" alt=""></p><blockquote><p>在指令格式上，一般推荐 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要是使用双引号 “”。如果使用 shell 格式的话,实际的命令会被包装为 sh -c 的参数的形式进行执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CMD echo $HOME</div></pre></td></tr></table></figure><p>实际执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $HOME&quot;]</div></pre></td></tr></table></figure><p>使用环境变量的原因,因为这些环境变量会被 shell 进行解析处理</p><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的目的和 CMD 一样，就是在指定容器启动程序及参数，ENTRYPOINT 在运行时也可以替代，需要通过 docker run 的参数 –entrypoint 来指定。当entrypoint指定后，CMD 的含义就发生了改变。将 CMD 的内容作为参数传给 ENTRYPOINT 指令 。实际执行时，变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ENTRYPOINT&gt; &quot;CMD&quot;</div></pre></td></tr></table></figure></p><p>第一次看的这种解释有点怪。</p><p><strong>场景一:让镜像变成像命令一样使用</strong></p><p>假设我们需要一个得知自己当前公网 IP 的镜像,那么可以先用 CMD 来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FROM ubuntu：16.04</div><div class="line">RUN apt-get update \</div><div class="line">&amp;&amp; apt-get install -y curl \</div><div class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line">CMD [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;]</div></pre></td></tr></table></figure></p><p>还记得前一节讲的如何通过 Dockerfile 构建镜像? 将上述信息写入 Dockerfile 文件中 运行 <code>docker build -t myip . </code> 创建镜像。加入我们需要查询当前公网 IP ,只需要执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run myip</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk415fc4gtj30et020aa0.jpg" alt=""></p><p>这样看来我们把镜像当做命令使用了，不过命令总有参数，那么如果我们希望显示 HTTP 头信息，就需要添加 -i 参数,直接添加对吗?<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk413385h5j30uu02l3yn.jpg" alt=""><br>我们之前说过，跟在镜像后面的是命令，会替换原来的 CMD ,而不是添加在<code>curl -s <a href="http://ip.cn" target="_blank" rel="external">http://ip.cn</a> </code>后面，替换命令为 -i 不是命令，他只是参数，所以报出错误找不到文件。</p><blockquote><p>如何解决这个问题?</p></blockquote><ol><li><p>如果我们希望加入 -i 这参数，就必须重写新的完整输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run myip curl -s http://ip.cn -i</div></pre></td></tr></table></figure></li><li><p>使用 ENTRYPOINT 就可以解决这个问题。(如果不记得ENTRYPOINT是什么翻到上面再看一下概念)<br>Dockerfile文件中</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FROM ubuntu:14.04</div><div class="line">RUN apt-get update \</div><div class="line">&amp;&amp; apt-get install -y curl \</div><div class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</div><div class="line">ENTRYPOINT [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;]</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk41v6r0nnj30hm0dq3zr.jpg" alt=""></p><p>docker run 设置的命令参数或者 CMD 指令的命令，都将作为ENTRYPOINT指令的命令参数，追加到ENTRYPOINT指令的命令之后。其中上述 的 -i 作为参数天交到 curl 之后。</p><p><a href="https://baike.baidu.com/item/apt-get/2360755?fr=aladdin" target="_blank" rel="external">关于 apt-get</a></p><p><a href="http://aiezu.com/article/linux_curl_command.html" target="_blank" rel="external">关于 curl </a></p><blockquote><p>问题:如何删除镜像？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker ps -l  (列出正在运行的详情)</div><div class="line">docker stop &lt;containerid&gt;</div><div class="line">docker rm &lt;containerid&gt;</div><div class="line">docker rmi &lt;imageid&gt;</div><div class="line">docker rmi $(docker images -q)(删除全部镜像)</div><div class="line">docker rm $(docker ps -a -q)(删除所有的容器)</div></pre></td></tr></table></figure><p><strong>场景二:应用运行前的准备工作</strong><br>启动容器就是启动主进程,但有些时候,启动主进程前,需要一些准备工作。而这些准备工作是跟容器 CMD 无关的，无论 CMD 为神马，都需要事先进行一个预处理的工作。比如：</p><ol><li>mysql 类的数据库,可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</li><li>可能希望避免使用 root 用户启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行，方便调试</li></ol><p>这些情况，可以写一个脚本,然后放入 ENTRYPOINT 中去执行,而这个脚本会将接到的参数(也就是 CMD)作为命令，在脚本最后执行。因为对 shell 脚本不熟悉 所以用照片记录脚本的使用。</p><p><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="external">shell 教程 | 菜鸟教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dockerfile 指令详解&lt;ol&gt;
&lt;li&gt;COPY 复制文件&lt;/li&gt;
&lt;li&gt;ADD 更高级的复制文件&lt;/li&gt;
&lt;li&gt;CMD 容器启动命令&lt;/li&gt;
&lt;li&gt;ENTRYPOINT 入口点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-10-1)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/10/01/%E5%AD%A6%E4%B9%A0Docker-2017-10-1/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/10/01/学习Docker-2017-10-1/</id>
    <published>2017-10-01T01:55:05.000Z</published>
    <updated>2017-10-11T03:33:29.190Z</updated>
    
    <content type="html"><![CDATA[<p>本节学习目录</p><ol><li>使用 Dockerfile 定制镜像</li><li>Dockerfile 的使用</li><li>构建镜像<ol><li>直接用 Git repo 进行构建</li><li>用给定的 tar 压缩包构建</li><li>从标准输入中读取 Dockerfile 进行构建</li><li>从标准输入中读取上下文压缩包进行构建</li></ol></li></ol><blockquote><p>继续学习 Docker 相关知识，上节学习了如何列出镜像，以及镜像的理解，关于 commit 生成定制的镜像，最后对 commit 生成镜像的缺点分析。 今天从 Dockerfile 定制镜像开始学习，并完成笔记。</p></blockquote><a id="more"></a><h1 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h1><p><strong>Dockerfile</strong><br>Dockerfile 是一个文本文件，其中包含一条条指令(Instrution),每一条指令构建一层,因此每条指令的内容，就是描述该层的应当如何构建。</p><p><strong>Dockerfile 的使用</strong></p><p>在一个文件夹中创建一个 Dockerfile 的文本,其中写入两条命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM ngix</div><div class="line">RUN echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt; /usr/share/ngix/html/index.html</div></pre></td></tr></table></figure></p><p><strong>FROM 指定基础镜像</strong></p><blockquote><p>回顾我们上节课的 nginx 镜像，就是一个基础镜像，在此基础做出定制。基础镜像是必须指定的。而 FROM 就是指定基础镜像，每个 Dockerfile 中 FROM 是必备的，而且必须是第一条指令。</p></blockquote><p>知识：在 Docker Hub 上有非常多的高质量的官方镜像</p><ol><li>可以直接拿来使用的 <strong>服务器镜像：</strong><br> nginx、redis、mongo、mysql、httpd、php、tomcat 等</li><li>方便开发、构建、运行各种 <strong>语言应用的镜像：</strong><br> node、openjdk、python、ruby、galang 等</li><li>基础的 <strong>操作系统镜像：</strong><br> ubuntu、debian、centos、fedora、alpine 等</li><li>特殊镜像 scratch ,表示虚拟的概念，并不存在，是一个空白的镜像<br> FROM scratch … 表示不以任何镜像为基础，接下来的命令作为镜像第一层开始存在。<blockquote><p>知识：不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd 对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经让镜像体积更加小巧了。因此 FROM scratch 会让镜像体积更加小巧。<br>实用 Go 语言开发的应用用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言之一。—来自《Docker 从入门到实践》</p></blockquote></li></ol><p><strong>RUN 执行命令</strong><br>RUN 指令是执行命令行的命令。<br>RUN 指令在定制镜像时是最常见的指令之一。其格式有两种:</p><ol><li>shell格式：RUN &lt;命令&gt; ，就像直接在命令行中输入的命令一样。</li><li>exec 格式：RUN [“可执行文件”,”参数1”,”参数2”],这更像是函数调用中的格式</li></ol><blockquote><p>问题：既然 RUN 就像 shell 脚本一样可以执行命令,那么我们是否就可以像 shell脚本一样把每个命令对应一个 RUN 呢?</p></blockquote><p>之前说过， Dockerfile 中每一个指令都会建立一层, RUN 也不例外。 每一个 RUN 的行为,就和刚才我们手工建立镜像的过程一样：新建一层，然后执行这些命令,commit 这层的修改，构成新的镜像。如果每条指令都是用 RUN 就创建了很多 镜像，所以又出现了上一节的问题，增加了镜像的臃肿程度。</p><p>Union FS 是有最大层数限制,比如 AUFS,曾经42层，现在127层</p><blockquote><p>关于 <a href="https://coolshell.cn/articles/17061.html" target="_blank" rel="external">Union FS</a></p></blockquote><p>解决：仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需要的命令串联起来。<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2ldj31cdj30lq0edads.jpg" alt=""></p><blockquote><p>Dockerfile 支持 Shell 类的行尾添加 \ 命令换行，以及行首 # 进行注释格式</p></blockquote><p>理解：阅读上图可能发现最后删除了编译构建所需要的软件，清理了所以下载、展开的文件，并清理了 apt 缓存文件，现在我们可能理解了 commit 和 Dockerfile 的区别，commit 直接生成了我们没有处理干净的镜像，其中包括很多自动生成的东西。利用 Dockerfile 相当一个”一键生成”的功能，把我们所要执行的工作，包括最后清理的工作，全部合成到一起，避免了 commit 忘记每一层构建的时候产生的文件。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>回到我们刚才的 nginx 镜像，让我们构建这个镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker build -t nginx:v3 .</div><div class="line">&lt;!-- 格式：docker build [选项] &lt;上下文路径/URL/-&gt;--&gt;</div></pre></td></tr></table></figure></p><p>遇到的问题</p><blockquote><p><strong>问题1：</strong> 输入命名显示格式错误提示！<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2lwju6rlj30ql0a4abe.jpg" alt=""><br>解决： 后来发现后面需要添加 . 点：表示当前目录</p><p><strong>问题2：</strong> 未找到 Dockerfile 文件在你的目录<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2m69c2crj31di01zwem.jpg" alt=""><br>解决：知道了找不到文件，思考了一下可能文件格式不对，书上没说什么格式，我的是txt格式，后来改成 无后缀的ok了<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2mccaf47j30nw05tgm5.jpg" alt=""></p><p><strong>问题3：</strong> build 成功后 windows 提示 权限问题<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2mecwp1rj30rv06w0tg.jpg" alt=""><br>解决：<br><a href="https://segmentfault.com/q/1010000004429905" target="_blank" rel="external">解决方法</a></p></blockquote><p>验证：</p><ol><li>启动<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2mh718f3j30kg01y74a.jpg" alt=""></li><li>进入验证</li></ol><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2mgd5mkpj30ae05qdfz.jpg" alt=""></p><h3 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文 (Context)"></a>镜像构建上下文 (Context)</h3><p>构建镜像命令后面有个<code>.</code>，表示当前目录，对应命令格式，是上下文路径<br>，什么是上下文？</p><p>Docker build 工作原理<br>Docker 运行：</p><ol><li>Docker 引擎(服务端守护进程)</li><li>客户端工具</li></ol><p>Docker 的引擎提供了一组 REST API (Docker Remote API),使用 docker 命令的客户端工具是通过这个 API 与引擎进行交互的。因此，虽然从表面上看我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端完成。这种 C/S设计，让我们轻松的操作远程服务器的 Docker 引擎。</p><p>当我们进行构建镜像的时候，并非是在本地构建，而是在服务端，也就是 Docker 引擎中进行。其中使用了上下文概念。</p><blockquote><p>上下文路径的作用：当用户执行 docker build 命令，获取上下文路径，会将这个路径的内容打包上传到 Docker 引擎，引擎展开这个包获得构建镜像所需的一切文件</p><p>需要注意的是:我们上传的内容不要在硬盘的根目录，也就是 C,D 盘，这会在执行 docker build 命令后 发送一个 几十 GB 的文件，这是一种错误的做法。正确的做法是创建一个空目录，或者项目目录，把需要的文件复制一份，如果目录下有不想构建的内容，可以用 <code>.gitignore</code>一样的语法创建一个<code>dockerignore</code></p></blockquote><h3 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h3><p>docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建:</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk2rg1u265j30m50e2wiy.jpg" alt=""></p><h3 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build http://server/context.tar.gz</div></pre></td></tr></table></figure><p>所给的 URL 不是git repo，而是 tar 压缩包，那么 Docker 引擎会下载这个包，自动解压，以其作为上下文，开始构建。</p><h3 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dockerfile -&lt; Dockerfile</div></pre></td></tr></table></figure><p>如果标准输入传入的是文本文件，则将其视为 Dockerfile ，并开始构建。</p><blockquote><p>这种形式读取内容，没有上下文，因此不可以将本地文件 COPY 进镜像之类的事情</p></blockquote><h3 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -&lt; context.tar.gz</div></pre></td></tr></table></figure><p>如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节学习目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Dockerfile 定制镜像&lt;/li&gt;
&lt;li&gt;Dockerfile 的使用&lt;/li&gt;
&lt;li&gt;构建镜像&lt;ol&gt;
&lt;li&gt;直接用 Git repo 进行构建&lt;/li&gt;
&lt;li&gt;用给定的 tar 压缩包构建&lt;/li&gt;
&lt;li&gt;从标准输入中读取 Dockerfile 进行构建&lt;/li&gt;
&lt;li&gt;从标准输入中读取上下文压缩包进行构建&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;继续学习 Docker 相关知识，上节学习了如何列出镜像，以及镜像的理解，关于 commit 生成定制的镜像，最后对 commit 生成镜像的缺点分析。 今天从 Dockerfile 定制镜像开始学习，并完成笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-9-30)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/30/%E5%AD%A6%E4%B9%A0Docker-2017-9-30/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/30/学习Docker-2017-9-30/</id>
    <published>2017-09-30T09:30:25.000Z</published>
    <updated>2017-10-11T03:33:26.590Z</updated>
    
    <content type="html"><![CDATA[<p>本节学习目录</p><ul><li>虚悬镜像</li><li>中间层镜像</li><li>列出部分镜像</li><li>利用 Commit 理解镜像构成</li><li>慎用 docker commit</li></ul><blockquote><p>衔接上一篇的内容,继续学习 Docker 的相关知识<br><a id="more"></a></p></blockquote><p><strong>虚悬镜像</strong></p><p><strong>中间层镜像</strong></p><p><strong>列出部分镜像</strong></p><blockquote><p>docker images 会列出所以镜像，当添加多个镜像只好几个参数</p></blockquote><p><strong>以特定格式显示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images -q 显示所有镜像的id信息</div></pre></td></tr></table></figure><p>下面的命令会直接列出镜像结果,并且只包含镜像 ID 和仓库名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images -format &quot;&#123;&#123;.ID&#125;&#125;:&#123;&#123;.Repository&#125;&#125;&quot;</div></pre></td></tr></table></figure></p><p>或者打算以表格等距显示,并且有标题行,和默认一样，不同自己定义列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1rystoqwj30oc046glt.jpg" alt="效果"></p><h1 id="利用-Commit-理解镜像构成"><a href="#利用-Commit-理解镜像构成" class="headerlink" title="利用 Commit 理解镜像构成"></a>利用 Commit 理解镜像构成</h1><blockquote><p>回顾知识:镜像是多层存储,每一层是前一层的基础上进行的修改；而容器也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层</p><p>我们定制一个 Web 服务器为例子,来讲解镜像是如何构建的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name webserver -d -p 80:80 nginx</div></pre></td></tr></table></figure><p>这条命令会用nginx镜像启动一个容器，名称为webserver，并且映射了80端口，如果使用的是 Docker for Windows 直接 通过 loclhost 访问。如果使用的是 Docker Toolbox ,或者是在虚拟机、云服务器上安装的 Docker ,则需要将 loclhost 换位虚拟机地址或者云服务器的地址</p><p>出现问题图片<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1t2nyaaoj30qe027aa5.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker: Error response from daemon: Conflict. The container name &quot;/webserver&quot;</div><div class="line">is already in use by container</div><div class="line"> &quot;9ea8beeb72c9f62b300ce1628f9a1660b37091636c8fc95774a3cb682b8b0819&quot;.</div><div class="line"> You have to remove (or rename) that container to be able to reuse that name.</div><div class="line">See &apos;docker run --help&apos;.</div></pre></td></tr></table></figure></p><blockquote><p>问题：上述命令下载nginx 镜像后，再次报错？<br>解决：上述出错信息是你不能使用80端口，所以我们修改了端口，解决后的命令如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name webserver -d -p 81:80 nginx</div></pre></td></tr></table></figure><p>如果你的机器运行失败，使用<code>docker ps -l</code>查看正在运行的镜像，然后<code>docker kill commit_ID</code>结束并删除<code>docker rm commit_ID<code>,然后在使用上面的命令，成功后返回一个 id<br><img src="http://ww1.sinaimg.cn/large/006rAlqhgy1fk1terva5wj30jt02i74b.jpg" alt=""><br>最后通过<a href="http://localhost:81/" target="_blank" rel="external">localhost:81</a>访问</code></code></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhgy1fk1tfqg9haj30rj0873zb.jpg" alt=""></p><p>我们可以通过<code>docker exec</code>命令进入容器，修复其内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it webserver bash</div></pre></td></tr></table></figure></p><p>解释:我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令, 也就是获得一个可以操作的 Shell。<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1tjbtqu1j30dp01p0sm.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1tlkfzgoj30og02nzkc.jpg" alt=""></p><p>然后，我们用 Hello ,Docker! 内容覆盖<code>/usr/share/nginx/html/index.html</code>的内容</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1tplv8n7j30cc05bdfz.jpg" alt=""></p><blockquote><p>我们修改了容器的文件，也就是改动了容器的储存层。我们可以通过 docker diff 命令看到具体的改动</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff webserver</div></pre></td></tr></table></figure><p>现在我们定制好了变化，将其保存下来形成镜像。Docker 提供了一个 docker commit 命令, 可以将容器的存储层保存下来成为镜像。 换句话说，就是在原有镜像的基础上，在叠加容器的存储层，并构成新的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker commit [选项] &lt;容器ID或容器名&gt;[&lt;仓库名&gt;[:&lt;标签&gt;]]</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">docker commit \</div><div class="line">--author &quot;didiaoyuan &lt;didiaoyuan@gmail.com&gt;&quot; \</div><div class="line">--message &quot;修改了默认网页&quot; \</div><div class="line">webserver \</div><div class="line">nginx:v2</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1uejduglj30y5032mxc.jpg" alt=""></p><p>现在我们可以在 docker images 中看到这个修改后的镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker images nginx</div><div class="line">(注意在生成新nginx：v2的时候注意拼写错误，本人在这上面卡了一会！)</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk1umx4go5j30q003jaa8.jpg" alt=""></p><p>通过<code>docker history</code>查看镜像内的历史变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker history nginx:v2</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fk1up5obguj30zp07ogn3.jpg" alt=""></p><p>然后我们允许新的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name web2 -d -p 82:80 nginx:v2</div></pre></td></tr></table></figure></p><p>通过<a href="http://localhost:82/" target="_blank" rel="external">localhost:82</a>访问</p><h1 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h1><blockquote><p>大部分引用书上的解释和自己的理解，文书出处与 GitBook《Docker 从入门与实践》</p></blockquote><p>虽然，上面解释 docker commit 可以直观的理解镜像的分层概念，但是实际上不会使用 commit 来生成镜像，而是使用 dockerfile 生成镜像。</p><p>原因：</p><ol><li>如果你仔细发现 docker diff webserver 的结果，会发现，除了我们修改的 index.html 文件外还有许多文件被改动了或者添加。如果是安装了软件包、编译构建，那会产生大量的无关内容被添加进来，会导致镜像十分臃肿。</li><li>使用 docker commit 对镜像的操作都是暗箱操作，生成的镜像都是黑箱镜像，因为除了制作人知道怎么生成，别人都不清楚，何况时间久了制作人也不清楚具体的操作，所以这种操作维护起来很难。</li><li>回顾之前的分层储存概念，除当前层外，之前的层是不会发生变化的，就是任何改变结果仅仅是在当前层进行操作(标记、添加、修改..)而不会改动上一层，使用 commit 制作镜像，以及后期修改，每一层都会让镜像更臃肿一次，所删除的上一层的东西不会消失，会一直如影随形的跟着这个镜像，只会让这个镜像更加臃肿。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节学习目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚悬镜像&lt;/li&gt;
&lt;li&gt;中间层镜像&lt;/li&gt;
&lt;li&gt;列出部分镜像&lt;/li&gt;
&lt;li&gt;利用 Commit 理解镜像构成&lt;/li&gt;
&lt;li&gt;慎用 docker commit&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;衔接上一篇的内容,继续学习 Docker 的相关知识&lt;br&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>学习Docker(2017-9-29)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/29/%E5%AD%A6%E4%B9%A0Docker-2017-9-29/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/29/学习Docker-2017-9-29/</id>
    <published>2017-09-29T12:11:21.000Z</published>
    <updated>2017-10-11T03:33:20.075Z</updated>
    
    <content type="html"><![CDATA[<p>本节学习目录</p><ol><li>Docker的优势</li><li>Docker 基本概念</li><li>Docker 安装</li><li>使用 Docker 镜像<ol><li>获取镜像</li><li>运行</li><li>列出镜像</li><li>镜像体积</li></ol></li></ol><blockquote><p>通过自学关于 Docker 的知识,因为不太懂详细的说明，所以在编写的时候，采用目录总结(通过先理清楚整体框架，然后在进行知识的填充,我喜欢用这种方式，因为有条理性吧,自创方法,不要见笑！)的方式</p></blockquote><a id="more"></a><h1 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h1><ol><li>更高效的利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松的迁移</li><li>更轻松的维护与扩展</li></ol><h1 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h1><ol><li>Docker 镜像</li><li>Docker 容器</li><li>Docker 仓库<ol><li>Docker Registry 公开服务</li><li>Docker Registry 私有服务</li></ol></li></ol><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><ol><li>Docker 版本介绍</li><li><p>Docker 各环境的安装(CE)</p><ol><li>Linux Docker</li><li><p>Windows 10</p><ol><li>下载安装 Docker for Windows</li><li>注册 <a href="https://cloud.docker.com" target="_blank" rel="external">Docler Hub</a> 账号</li><li>注册<a href="http://warjiang.github.io/devcat/2016/11/28/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/" target="_blank" rel="external">阿里云加速器</a>和<a href="http://www.daocloud.io" target="_blank" rel="external">DaoCloud</a></li><li><p>settings 配置 Daemon 配置 JSON 字符串</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk0r0flq8gj30sy0iu0um.jpg" alt=""></p></li><li><p>检查加速器是否生效(Linux 系统下配置完加速器需要检查是否生效)</p></li></ol></li><li><p>macOS</p></li></ol></li></ol><h1 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h1><p><strong>获取镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</div></pre></td></tr></table></figure><ol><li>Docker Registry地址: &lt;域名/IP&gt; [:端口号] 默认地址是 Docker Hub</li><li>仓库名：使用两段式名称&lt;用户名&gt;/&lt;软件名&gt; 对于 Docker Hub,如果不给出用户名，则默认为Library ,也就是官方镜像</li></ol><p>Test：<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk0rgeqewsj30hj04qwet.jpg" alt=""></p><p>解释：镜像是由多层存储结构所构成，所有下载也是一层层得去下载，并非单一文件。命令默认地址就是从 Docker Hub 获取镜像</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk0rj2uhlzj30ob05uq3g.jpg" alt=""></p><p>解释: 下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载的一致性</p><blockquote><p>思考问题：windows下的文件去哪了？(以下为网上搜索的解释)<br>解决：1、<a href="https://segmentfault.com/q/1010000006745913/a-1020000007015262" target="_blank" rel="external">windows上的docker本质上还是借助与windows平台的hyper-v创建一个linux虚拟机，你执行的所有命令都是在这个虚拟机里执行的，所有pull到本地的image都会在虚拟机的Virtual hard disks目录的文件中，这个文件就是虚拟硬盘文件（有点类似与vmware的原理）。<br>因此你打开hyper-v管理器，可以找到docker创建的虚拟机，点击左侧的虚拟机名称，然后再点击右边的移动选项，按照向导将虚拟机移动到其他目录即可。<br>另外还可以在菜单栏点击:操作-&gt;Hyper-v设置，来调整你所有虚拟机的虚拟硬盘文件的默认存储位置。</a><br>2、网上的关于pull 的镜像 <a href="http://blog.csdn.net/stemq/article/details/53150939" target="_blank" rel="external">路径地址转移</a></p></blockquote><p><strong>运行</strong></p><p>如果我们打算运行刚才的镜像，可以执行以下的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -it --rm ubuntu:14.04 bash</div></pre></td></tr></table></figure></p><p>docker run：运行容器命令<br>-it：-i、交互式操作，一个是-t、终端。我们打算进入 bash 执行一些命令并查看返回结果，因此需要交互式终端<br>–rm：容器退出后将删除，避免空间浪费<br>exit 退出</p><blockquote><p>思考问题：bash 是什么?<br>解决：百度–bash 是一个为GNU计划编写的Unix shell。</p></blockquote><p><strong>列出镜像</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fk0sfryu99j30rs045aa8.jpg" alt=""><br>列表包括：</p><ol><li>仓库名</li><li>标签</li><li>镜像 ID</li><li>所占控件</li></ol><p><strong>镜像体积</strong></p><ol><li>标识的体积和 Docker Hub 上的不同。<br>因为 Docker Hub 中显示的是体积压缩的，在镜像下载和上传过程中镜像是保持着压缩状态，所以显示的是网络传输中关系的流量大小，本地是解压后的大小</li><li>docker images 下的体积综合并不是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构,并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union Fs ，相同的层只需要保存一份即可,所以实际镜像要小的多</li></ol><blockquote><p><a href="http://www.cnblogs.com/wish123/p/5573098.html" target="_blank" rel="external">Docker —几个概念的理解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节学习目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Docker的优势&lt;/li&gt;
&lt;li&gt;Docker 基本概念&lt;/li&gt;
&lt;li&gt;Docker 安装&lt;/li&gt;
&lt;li&gt;使用 Docker 镜像&lt;ol&gt;
&lt;li&gt;获取镜像&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;li&gt;列出镜像&lt;/li&gt;
&lt;li&gt;镜像体积&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;通过自学关于 Docker 的知识,因为不太懂详细的说明，所以在编写的时候，采用目录总结(通过先理清楚整体框架，然后在进行知识的填充,我喜欢用这种方式，因为有条理性吧,自创方法,不要见笑！)的方式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Docker笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Docker%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Git服务器搭建</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/29/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/29/Git服务器搭建/</id>
    <published>2017-09-29T05:45:57.000Z</published>
    <updated>2017-10-26T02:32:28.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>git中远程仓库与本地仓库没什么区别，只是提供了一个24小时不关机的服务器，方便不同的机器获取和开发，然而托管于在线GitHub网址是开源的，大多数公司不希望自己的代码被别人知道，所以那么选择SVN集中式版本开发，要么自己搭建Git服务器，这节主要学习搭建Git服务器的知识<br><a id="more"></a></p><h1 id="Git服务器搭建"><a href="#Git服务器搭建" class="headerlink" title="Git服务器搭建"></a>Git服务器搭建</h1></blockquote><p>准备工作：</p><ol><li>准备一台 Linux 的机器（Ubuntu或者 Debian）</li><li><p>安装 git:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure></li><li><p>创建git用户，用来运行 git 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo adduser git</div></pre></td></tr></table></figure></li></ol><blockquote><p>收集所有需要访问用户的GitHub上面的公钥 就是用户自己的id_rsa.pub文件，把所有公钥导入到<code>/home/git/.ssh/authoriz ed_keys</code>文件里，一行一个</p></blockquote><ol><li>初始化版本仓库,假定是/srv/sample.git,在/srv目录下输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo git init --bare sample.git</div></pre></td></tr></table></figure></li></ol><p>Git 就会创建一个裸仓库,裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享,所有不让用户直接登记到服务器上去改服务区,并且服务器上的 Git 仓库通常都是 <code>.git</code> 结尾。然后，把owner 改为git:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chown -R git:git sample.git</div></pre></td></tr></table></figure></p><ol><li>禁用 shell<blockquote><p>处于安全考虑，创建git的用户不允许登录shell，找到etc/passwd文件找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</div><div class="line">改为</div><div class="line">git:x:1001:1001:,,,:/home/usr/bin/git-shell</div></pre></td></tr></table></figure></blockquote></li></ol><p>这样git用户可以正常通过ssh使用git，但无法登录shell，因为为git用户指定的shell登录就自动退出。</p><ol><li>验证服务器<br>git clone 克隆远程库</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@server:/srv/sample.git</div></pre></td></tr></table></figure><blockquote><p>涉及到的知识:</p><ol><li><strong>apk</strong> 是Debian及其派生发行版的软件包管理器</li><li><strong>Sudo</strong> 是一种程序，用于类Unix操作系统如BSD，Mac OS X，以及GNU/Linux以允许用户通过安全的方式使用特殊的权限运行程序（通常为系统的超级用户）。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;git中远程仓库与本地仓库没什么区别，只是提供了一个24小时不关机的服务器，方便不同的机器获取和开发，然而托管于在线GitHub网址是开源的，大多数公司不希望自己的代码被别人知道，所以那么选择SVN集中式版本开发，要么自己搭建Git服务器，这节主要学习搭建Git服务器的知识&lt;br&gt;
    
    </summary>
    
      <category term="Git笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Git%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Git/"/>
    
      <category term="服务器" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git继续学习(二)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/27/Git%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/27/Git继续学习-二/</id>
    <published>2017-09-27T13:40:15.000Z</published>
    <updated>2017-10-11T03:34:30.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前的仓库操作跟SVN操作没甚区别，现在学习git独特的功能之一，远程仓库，配合GitHub网站托管代码块</p></blockquote><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p><strong>Git仓库与GitHub仓库的SSH加密</strong><br><a id="more"></a><br><strong>第1步：</strong> 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa<code>和</code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><p><code>$ ssh-keygen -t rsa -C “youremail@example.com”</code></p><p>id_rsa 是私钥<br>id_rsa.pub 是公钥</p><p><strong>第2步：</strong><br>登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：</p><blockquote><p>ssh Key 目的是让 GitHub 识别推送上来的是自己的内容，并且GitHub支持添加多个Key  也意味着 你可以有若干的电脑往github上提交东西</p></blockquote><p><strong>注意</strong>：既然github是公共网站，所以提交上去的代码都是公开的<br>要想让自己的代码不公开有两种方法</p><ol><li>给github缴费使用私有版本库</li><li>自己搭建Git服务器</li></ol><p><strong>Git与GitHub进行同步</strong></p><p>GitHub上创建一个版本库,获取ssh地址，用来对接</p><p><code>git remote add origin git@github.com:xxx/仓库名称</code></p><p>添加远程库的名称是origin,这是Git默认的叫法，也可以改成其他的,但是origin这个名字一看就知道是远程库,完成之后,就可以把本地的文件上传到远程库中了。</p><p><code>git push -u origin master</code></p><p>因为第一次推送到github,所以添加 -u 的参数，因为提交的是本地master分支，远程库是空的，所以会把master分支内容推送的远程库的master分支，还会把本地master与远程库master分支关联起来，在以后的推送或者拉取时就可以简化命令。以后直接使用<code>git push origin master</code>就可以了。</p><p><strong>克隆远程版本库</strong></p><p><code>git clone 版本库地址</code><br>git支持多种协议</p><ol><li>https</li><li>ssh</li></ol><p>其中通过<code>ssh</code>原生<code>git</code>协议速度最快</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><strong>创建与合并分支</strong><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="external">原网站分支图</a></p><p>总结:</p><ol><li><code>git branch</code> 查看分支</li><li><code>git branch ‘name’ </code> 创建分支</li><li><code>git checkout ‘name’</code> 切换分支</li><li><code>git checkout -b ‘name’</code> 创建并切换分支</li><li><code>git merge ‘name’</code> 合并分支</li><li><code>git branch -d ‘name’</code> 删除分支</li></ol><p><strong>解决冲突</strong></p><blockquote><p>当两个分支进行合并出现冲突的时候，会出现冲突，冲突发生在两个分支在相同的位置上进行了修改，我们需要选在保留的部分删去不要的，处理后在进行提交</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjz3a75zk4j30fx0abdgd.jpg" alt=""><br>如何处理冲突可以查看<a href="http://blog.didiaoyuan.com/2017/07/03/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">文章下方</a><br>如何处理冲突</p><p><code>git log –graph</code> 查看分支合并图</p><p><strong>分支管理策略</strong></p><p>我们在合并分支的时候，一般会进入Fast forward快速合并模式，这个模式有个弊端是，直接删除分支，会丢失分支信息使用<code>–no-ff</code>参数普通合并，保留分支信息记录</p><p><strong>Bug分支</strong></p><blockquote><p>场景：当我们在分支进行开发的时候，发现一个bug，可能通过建立一个修复bug的分支进行修复，但是你的开发分支正在编写，但是并不想提交，因为还为完成工作，但是你又必须现在就修复bug</p></blockquote><p>Git提供了一个<code>stash</code>功能，可以把你的工作展示保存，等使用的时候再恢复，如何使用呢？</p><ol><li>在开发分支下<code>git stash</code></li><li><code>git status</code>查看工作区是空的</li><li>bug修复后切换到开发分支</li><li><code>git stash list </code>查看储存的</li><li>恢复工作区<code>git stash pop </code>删除list列表，并恢复工作区内容</li></ol><p><strong>feature分支</strong></p><blockquote><p>场景:当我们有很多想法的时候，添加很多特效，功能的时候，通常创建一个feature分支，进行开发,但是会出现开发完好，突然说不需要添加这个功能了,在还没有合并提交的情况下删除</p></blockquote><ol><li><code>git branch -d feature</code>会提示错误，未合并</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D ‘name’ <code>强行删除。</code></code></li></ol><p><strong>多人协助</strong></p><p><code>git remote -v</code>查看远程库的详细信息<br>推送分支：</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjz4b4t9h9j30na0813zh.jpg" alt=""></p><p>总结：</p><ol><li>首先 <code>git push origin 分支名称</code> 将本地推送到远程库中</li><li>如果推送失败，因为远程分支比你的本地更新，<code>git pull 远程库 分支</code>命令获取最近版本，然后视图合并</li><li>如果合并冲突，解决冲突，并在本地提交<code>git push origin 分支名称</code></li><li>如果git pull 提示”no tracking information “,说明本地分支，和远程分支的连接关系没有创建，<code>git branch –set-upstream 分支名称 origin/分支名称</code></li></ol><p>以上就是多人协作的工作模式</p><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><blockquote><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013762144381812a168659b3dd4610b4229d81de5056cc000" target="_blank" rel="external">原链接</a></p></blockquote><p>在需要打标签的分支下执行下面的命令<br><code>git tag v1.0</code></p><blockquote><p>默认标签是打在最新的commit 上的，如果忘记打标签，可以找到需要打标签的commit_ID,然后打上标签<code>git tag v1.1   commit_ID</code></p></blockquote><p>查看所有标签<br><code>git tag</code></p><p>根据标签的名称查看详细信息<br><code>git show 标签名称</code></p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhgy1fjz8fvauz0j30jv06baah.jpg" alt=""></p><h1 id="忽略特殊文件-9月29日"><a href="#忽略特殊文件-9月29日" class="headerlink" title="忽略特殊文件(9月29日)"></a>忽略特殊文件(9月29日)</h1><blockquote><p>场景:当我们在开发自己的项目的时候，是否会遇到配置文件保存密码，获取自动生成的文件，这些文件我们不需要让他添加到版本库中，所以git中<code>.gitigore</code>文件就是存放需要忽略的文件信息<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" target="_blank" rel="external">原文介绍</a></p></blockquote><ol><li><p>如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p></li><li><p>文件格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#python 文件基本忽略</div><div class="line">*.py[cod]</div><div class="line">*.so</div><div class="line">*.egg</div><div class="line">*.egg-info</div><div class="line">dist</div><div class="line">build</div></pre></td></tr></table></figure></li><li><p>将编辑好的.gitignore文件提交到git中</p></li></ol><blockquote><p>场景:如果你确实要强制添加内容，可以通过<code>git add -f ‘name’</code></p><p>场景:如果想要检查文件关于忽略的信息，可以通过<code>git ceck-ignore</code>这条命令只能查询添加不上的忽略信息</p></blockquote><h1 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h1><blockquote><p>功能:将命令简化，git status 简化 git st 一系列的命令简化操作</p></blockquote><p>基本格式:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git config --global alias.st status</div><div class="line"><span class="meta">$</span> git config --global alias.co checkout</div><div class="line"><span class="meta">$</span> git config --global alias.ci commit</div><div class="line"><span class="meta">$</span> git config --global alias.br branch</div></pre></td></tr></table></figure></p><p>还有一个用发，alias设置别名也可以替换长的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</div></pre></td></tr></table></figure><p>设置了上面的命令以后回退版本，git reset unstage 就可以了</p><blockquote><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用</p></blockquote><p>配置文件目录 .git/config</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前的仓库操作跟SVN操作没甚区别，现在学习git独特的功能之一，远程仓库，配合GitHub网站托管代码块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Git仓库与GitHub仓库的SSH加密&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Git笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Git%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Git/"/>
    
      <category term="版本控制" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Git继续学习</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/26/Git%E7%BB%A7%E7%BB%AD%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/26/Git继续学习/</id>
    <published>2017-09-26T02:22:41.000Z</published>
    <updated>2017-10-26T02:32:39.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>再次学习 git 完善以前没有注意到的问题，主要学习廖雪峰的git教程，基本命令在前面已经总结，但是具体的实际开发过程中需要注意的场景将重新总结。希望学习的可以访问<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000" target="_blank" rel="external">原网站</a>，一下是自己的总结，方便以后个人查询</p></blockquote><a id="more"></a><h1 id="Git工作区，暂存区与版本库"><a href="#Git工作区，暂存区与版本库" class="headerlink" title="Git工作区，暂存区与版本库"></a>Git工作区，暂存区与版本库</h1><p> <img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjwr8x935cj30hu08pq4m.jpg" alt="理解图"></p><p> git add: 将文件从工作区添加到暂存区<br> git commit: 将暂存区存储到版本库</p><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><blockquote><p>当我们 commit 很多操作的情况系，我们想要回到之前的版本，可以通过版本回退，回退到之前的版本,如果忘了如何操作我们可以查询当前状态，根据提示操作 git status(git status 是查询工作区的状态)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD^(回退到上一个提交版本 HEAD~回退的次数)</div><div class="line">git reset --hard commit_ID(回退到固定id的版本)</div></pre></td></tr></table></figure><blockquote><p>以上可能需要 git log 查询提交ID，其中在命令后面添加 –pretty=oneline 表示只显示ID 和提交的消息</p></blockquote><p>总结：</p><ol><li><code>HEAD</code> 指向的版本问当前版本所以后面一个^表示向前跳转一个~+数字表示向前跳几个</li><li>如果在回退到之前的版本忘记了commit_ID可以通过<br><code>git reglog</code>查询记录所有的操作</li></ol><h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><blockquote><p>场景1：当我们在工作区修改了一些内容，想要回到以前的版本中</p></blockquote><ul><li>方法1: 手动删除不需要的内容</li><li>方法2: <code>git chectout –filename</code> 可以丢弃工作区的内容</li></ul><blockquote><p>场景2 :当我们不想要的修改已经提交到了暂存区内,并且又在工作区修改的一些内容，该如何恢复？</p></blockquote><ul><li>方法: <code>git reset HEAD filename</code>这个命令在<code>git status</code>后也可看到该提示。如下图:<br>将文件从回退到工作区。场景1的方法,将文件恢复到<code>add</code>前</li></ul><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjx1zzfh32j30nc06pjrs.jpg" alt=""></p><blockquote><p>场景3 :当我们不想要的修改提交到了版本库，该如何恢复？</p><ul><li>方法: 先<code>reset</code> 回退到前一个版本库。就OK啦</li></ul></blockquote><h1 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h1><blockquote><p>当我们在完成了提交版本库的操作，删除了在工作区的一个文件，第一种场景是我们确实要删除它，那就<code>add</code> ——&gt; <code>commit</code> 完成更新版本库。第二种是，我们误删了文件想要恢复它。</p></blockquote><ul><li>方法：<code>git checkout –filename</code></li></ul><p><strong>总结：<code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论是修改还是删除,都可以“一键还原”</strong></p><blockquote><p>注意：<code>git rm</code>用于删除一个文件。如果这个文件已经提交到了版本库，那就不用担心误删，但是你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;再次学习 git 完善以前没有注意到的问题，主要学习廖雪峰的git教程，基本命令在前面已经总结，但是具体的实际开发过程中需要注意的场景将重新总结。希望学习的可以访问&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013743256916071d599b3aed534aaab22a0db6c4e07fd0000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原网站&lt;/a&gt;，一下是自己的总结，方便以后个人查询&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Git笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Git%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Git/"/>
    
      <category term="版本控制" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="分布式" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SVN学习--高级应用</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/24/SVN%E5%AD%A6%E4%B9%A0-%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/24/SVN学习-高级应用/</id>
    <published>2017-09-24T04:16:48.000Z</published>
    <updated>2017-10-11T03:35:49.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SVN高级应用，主要用于svn版本库管理员级别的操作，这些操作需要暂停重启svn的操作<br><a id="more"></a></p><h1 id="hooks钩子应用"><a href="#hooks钩子应用" class="headerlink" title="hooks钩子应用"></a>hooks钩子应用</h1></blockquote><p>hooks：当执行默写<strong>特定操作</strong>时触发执行预先设定的任务</p><blockquote><p>不是很理解，所以用大白话说吧，后期继续学习的过程中，完善…</p></blockquote><p>位置:服务器版本库/hooks/hook-scripts</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjx4g5jlsyj30ln08faax.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">post-commit</div><div class="line">在提交完成，成功创建版本之后执行该钩子，提交已经完成，不可更改，因此本脚本的返回值被忽略。</div><div class="line"></div><div class="line">post-lock</div><div class="line">对文件进行加锁操作之后执行该脚本</div><div class="line"></div><div class="line">post-revprop-change</div><div class="line">在修改 revision 属性之后，执行该脚本。因为修改稿已经完成，不可更改，因此本脚本的返回值被忽略（不过实际上的实现似乎是该脚本的正确执行与否影响属性修改）</div><div class="line"></div><div class="line">post-unlock</div><div class="line">对文件进行解锁操作之后执行该脚本</div><div class="line"></div><div class="line">pre-commit</div><div class="line">在 Subversion transaction 完毕之后，在提交之前，执行该脚本</div><div class="line"></div><div class="line">pre-lock</div><div class="line">对文件进行加锁操作之前执行该脚本</div><div class="line"></div><div class="line">pre-revprop-change</div><div class="line">在修改 revision 属性之前，执行该脚本</div><div class="line"></div><div class="line">pre-unlock</div><div class="line">对文件进行解锁操作之前执行该脚本</div><div class="line"></div><div class="line">start-commit</div><div class="line">在客户端还没有向服务器提交数据之前，即还没有建立 Subversion transaction（缩写为 txn） 之前，执行执行该脚本</div></pre></td></tr></table></figure></p><p>如图所示：以上都以<code>.tmpl</code>后缀结尾的。代表模板文件，使用的时候去掉后缀名，就是可执行shell脚本。<br>比如图一，post-commit文件，当用户使用commit后出发执行脚本。</p><blockquote><p>因为在学习阶段，并不清楚实际上的应用，大概明白了hooks具体是用来干什么的，实际上怎么用，以后遇到了在总结，网上找了相关的博客，看了一些，推荐一个感觉靠谱的网站<br><a href="http://blog.csdn.net/dahuzix/article/details/49053227" target="_blank" rel="external">利用SVN的post-commit钩子实现多项目自动同步</a></p></blockquote><h1 id="版本库精简与丢弃"><a href="#版本库精简与丢弃" class="headerlink" title="版本库精简与丢弃"></a>版本库精简与丢弃</h1><blockquote><p>在后期开发中，版本库的版本号会越来越的多，通过版本库的精简，丢弃靠前的版本，来达到版本库瘦身的目的</p></blockquote><ol><li>停止版本库服务(防止有新的版本提交 killall svnserve)</li><li>把需要保留的版本库备份(<code>svnadmin dump 版本库文件系统路径 -r 2:4 &gt; 备份文件</code>)</li><li>创建新的版本库存放精简过后的版本库(<code>svnadmin create 路径/版本库名称</code>)</li><li>导入备份(<code>svnadmin load 版本库文件系统路径/ &lt; 备份文件</code>)</li><li>复制原来的版本库权限配置文件 conf/*</li><li>删除旧的版本库(rm -rvf 路径)</li><li>运行svn服务</li><li>完成</li></ol><blockquote><p>注意:精简前<code>checkout</code>的工作副本不能使用了，原因是在精简和的版本号重新编号，与之前的不匹配，所以精简后重新<code>checkout</code>版本库</p></blockquote><h1 id="版本库迁移与switch重定向"><a href="#版本库迁移与switch重定向" class="headerlink" title="版本库迁移与switch重定向"></a>版本库迁移与switch重定向</h1><blockquote><p>迁移在上个知识点就用到了版本库操作</p></blockquote><p>迁移方式2 ：</p><ol><li>killall svnserve(windows 下直接关闭)</li><li>把 版本库 压缩成 xxx.zip</li><li>复制xxx.zip 到新服务 器并解压</li><li>在新服务器上运行版本库<blockquote><p>一行方法有点简单粗暴!!</p></blockquote></li></ol><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjx88n34grj30mn0bn769.jpg" alt=""></p><blockquote><p>因为更换了服务器，所以我们需要把工作副本重新定向到新的URL上去，这个过程称为重定向，使用第二种迁移方式重定向方便简单。</p></blockquote><p><code>svn switch –relocate svn://原来版本库url svn://新版本库url</code></p><h1 id="常见坑与总结"><a href="#常见坑与总结" class="headerlink" title="常见坑与总结"></a>常见坑与总结</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjx8xmtgynj30uc098jt0.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;SVN高级应用，主要用于svn版本库管理员级别的操作，这些操作需要暂停重启svn的操作&lt;br&gt;
    
    </summary>
    
      <category term="SVN" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/SVN/"/>
    
    
      <category term="版本控制" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SVN学习--进阶</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/24/SVN%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E9%98%B6/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/24/SVN学习-进阶/</id>
    <published>2017-09-24T01:07:27.000Z</published>
    <updated>2017-10-11T03:35:52.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SVN进阶应用"><a href="#SVN进阶应用" class="headerlink" title="SVN进阶应用"></a>SVN进阶应用</h1><h2 id="ls、st、log、info"><a href="#ls、st、log、info" class="headerlink" title="ls、st、log、info"></a>ls、st、log、info</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">svn list                --列出当前目录下处于版本控制的所有文件(添加-v显示更详细信息 --recursive 强制递归文件中的信息)</div><div class="line">svn status              --列出工作副本中的文件状态</div><div class="line">svn log                 --查看提交日志</div><div class="line">svn info                --查看工作副本及文件的详细信息</div></pre></td></tr></table></figure><a id="more"></a><p>svn status中的状态说明<br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjug91yxo8j30eb07zq5o.jpg" alt=""></p><blockquote><p>遇到问题：svn log 后显示 svn: E220001: 条目不可读<br>解决：服务器的权限配置文件conf/svnserve.conf 中设置anon-access = none 即可. 然后重启Subversion 服务.</p></blockquote><h2 id="多版本库解决方案"><a href="#多版本库解决方案" class="headerlink" title="多版本库解决方案"></a>多版本库解决方案</h2><h3 id="解决方案A"><a href="#解决方案A" class="headerlink" title="解决方案A"></a>解决方案A</h3><blockquote><p>场景:当只有一台服务器当做版本库的时候，同一个服务器要开很多次服务，但是每一种服务对应只能一个端口号，所以当我们创建很多版本库的同时，再启动服务的时候也要手动分配一个端口号，svn默认端口3690</p></blockquote><p><strong>端口号知识</strong></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjugq5g58nj30ta09rtcd.jpg" alt=""></p><blockquote><p>回顾创建版本库： svnserve create 版本库名称</p></blockquote><p><strong>为其他版本库启动服务</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svnserve -d -r 路径1 --listen-port 3691</div><div class="line">svnserve -d -r 路径2 --listen-port 3692</div></pre></td></tr></table></figure></p><blockquote><p>注意：当同一个服务器有多个版本库，在使用checkout 后的url 要加上版本号，否则或链接默认端口号3690</p></blockquote><p>killallserve    –关闭所有服务</p><p><em>使用这种手动修改端口号的方法只适用于少量版本库</em></p><h3 id="解决方案B"><a href="#解决方案B" class="headerlink" title="解决方案B"></a>解决方案B</h3><blockquote><p>启动服务的路径为存放各个版本库的父级目录版本库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svnserve -d -r 父级目录</div></pre></td></tr></table></figure><p>只使用一个端口号一次性启动了所有的版本库，条件时所有版本库要建立在一个目录下  </p><blockquote><p>唯一要注意的是，当我们只用一个端口号对接多个服务器，在checkout下有点不同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（客户端）</div><div class="line">    svn co svn:0.0.0.0/需要的版本库</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjuhadsw57j30xq0dwq79.jpg" alt=""></p><h1 id="svn-copy"><a href="#svn-copy" class="headerlink" title="svn copy"></a>svn copy</h1><blockquote><p>复制：工作副本与工作副本之间的复制。。。。<br>在这之间需要理清楚复制从哪到哪<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjuhtwa8z5j30hm08kdhn.jpg" alt=""></p></blockquote><p><strong>作副本与工作副本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">（单个文件复制）</div><div class="line">    svn copy index.html copy.html</div><div class="line">    &lt;!--复制到copy.html新文件中--&gt;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">（批量文件复制）</div><div class="line">    svn copy index.html ./复制到的路径</div><div class="line">    &lt;!--只能复制到不同目录文件中，因为文件中文件名id唯一--&gt;</div><div class="line">    &lt;!-- .表示当前目录 --&gt;</div></pre></td></tr></table></figure><p><strong>工作副本到服务器版本库</strong></p><blockquote><p>这种不经过本地的代码直接复制到版本库中，成功后将版本号+1</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn copy index.htm svn:0.0.0.0/版本库名称/目标 -m &quot;copy a file&quot;</div></pre></td></tr></table></figure><blockquote><p>注意：<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjuifjfftvj30dj0233yx.jpg" alt=""></p></blockquote><p><strong>服务器版本库到工作副本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn copy svn:0.0.0.0/版本库名称/目标 复制到的文件</div><div class="line">&lt;!--这种操作支持跨库操作--&gt;</div></pre></td></tr></table></figure></p><blockquote><p>可用从其他工作副本 获取到线上版本库<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjuiitwuboj30cm022glz.jpg" alt=""></p></blockquote><p><strong>版本库到版本库</strong></p><p>继续阅读——&gt;</p><h1 id="主干版本与分支版本"><a href="#主干版本与分支版本" class="headerlink" title="主干版本与分支版本"></a>主干版本与分支版本</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjuissrg8mj30p0084q4u.jpg" alt=""></p><blockquote><p>在主干版本目录中创建一个目录区分主版本和分支版本</p></blockquote><p>创建一个主干版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn cp svn://0.0.0.0/版本库名称/ svn://0.0.0.0/版本库名称/trunk -m &quot;setup a trunk&quot;</div></pre></td></tr></table></figure></p><p>创建一个分支版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svn cp svn:0.0.0.0/版本库名称/版本库名称 svn:0.0.0.0/版本库名称/branch -m &quot;create a branch&quot;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SVN进阶应用&quot;&gt;&lt;a href=&quot;#SVN进阶应用&quot; class=&quot;headerlink&quot; title=&quot;SVN进阶应用&quot;&gt;&lt;/a&gt;SVN进阶应用&lt;/h1&gt;&lt;h2 id=&quot;ls、st、log、info&quot;&gt;&lt;a href=&quot;#ls、st、log、info&quot; class=&quot;headerlink&quot; title=&quot;ls、st、log、info&quot;&gt;&lt;/a&gt;ls、st、log、info&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;svn list                --列出当前目录下处于版本控制的所有文件(添加-v显示更详细信息 --recursive 强制递归文件中的信息)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;svn status              --列出工作副本中的文件状态&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;svn log                 --查看提交日志&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;svn info                --查看工作副本及文件的详细信息&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="SVN" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/SVN/"/>
    
    
      <category term="版本控制" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SVN学习</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/23/SVN%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/23/SVN学习/</id>
    <published>2017-09-23T13:15:57.000Z</published>
    <updated>2017-10-29T02:29:03.787Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在中小型企业中开发一般会用到SVN 进行分布式开发，通过学习，熟悉以后的开发流程</p></blockquote><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>这个百度吧，概念一般很专业，但不容易懂</p><h1 id="CVS-SVN-GIT-三者之间的区别"><a href="#CVS-SVN-GIT-三者之间的区别" class="headerlink" title="CVS SVN GIT 三者之间的区别"></a>CVS SVN GIT 三者之间的区别</h1><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjtt5wll2kj30yf0jfn3h.jpg" alt=""></p><h1 id="SVN介绍与安装"><a href="#SVN介绍与安装" class="headerlink" title="SVN介绍与安装"></a>SVN介绍与安装</h1><p>SVN 分服务器端和客户端，一般客户端在本地创建代码库，服务端是在远程服务器上搭建代码库<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjtt80avd6j30vz0gogq7.jpg" alt=""></p><blockquote><p>注意：在使用命令的时候要搞清算是服务端命令还是客户端命令</p></blockquote><h2 id="版本库的创建与删除—–服务端命令"><a href="#版本库的创建与删除—–服务端命令" class="headerlink" title="版本库的创建与删除—–服务端命令"></a>版本库的创建与删除—–服务端命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svnadmin create 路径</div><div class="line">&lt;!--创建服务器版本库 --&gt;</div></pre></td></tr></table></figure><p>可以添加参数指定版本库储存的数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svnadmin create --fs-type fsfs 版本库的名称</div><div class="line">&lt;!-- fsfs表示数据保存类型 --&gt;</div></pre></td></tr></table></figure></p><p><strong>删除版本库</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rvf 删除的文件夹</div></pre></td></tr></table></figure></p><p><strong>版本库配置</strong></p><p>位于版本库文件下的 path/repos/conf 文件夹<br>其中有三个文件<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjttcyfxm5j30wz0gy43g.jpg" alt=""></p><p><strong>1、svnserve.conf文件</strong></p><blockquote><p>在svn版本库权限上注意更新的概念：</p><ol><li>更新代码：是从服务器更新到本地的操作</li><li>提交代码：是从本地修改的代码提交到服务器上的过程</li></ol></blockquote><p>打开svnserve.conf<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjtteh3h4sj30v30plagi.jpg" alt=""></p><p>前两个表示在无用户密码的情况下只有只读的权限，<br>再有密码情况下拥有读写提交上传的权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">password-db = 路径（默认password）</div><div class="line">&lt;!-- 表示密码文件的路径 --&gt;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;!-- authz-db = 路径（默认authz）</div><div class="line">表示用户文件的路径 --&gt;</div></pre></td></tr></table></figure><p><strong>2、password文件</strong><br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjttg2ik51j30pb0b4gmp.jpg" alt=""></p><p>格式 如上<br>添加一个didiaoyuan用户 密码为123456<br>以此后面用户都可以按照这个格式添加</p><p><strong>3、authz文件</strong><br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjtthlooslj30rq0f9tao.jpg" alt=""><br>如图中注释</p><p><strong>版本库的访问</strong><br>需要先搭建svn服务启动,其他客户端才能访问<br>   运行svn服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">svnserve -d -r /路径/版本库</div></pre></td></tr></table></figure></p><h2 id="获取checkout-—–客户端命令"><a href="#获取checkout-—–客户端命令" class="headerlink" title="获取checkout —–客户端命令"></a>获取checkout —–客户端命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">svn co(checkout) svn://版本库服务器地址</div><div class="line"> (--username imocc --password 123456)[括号内可以不添加]</div><div class="line">&lt;!-- 首先进入输入服务器密码 --&gt;</div></pre></td></tr></table></figure><h2 id="获取checkout-—–客户端图形界面管理"><a href="#获取checkout-—–客户端图形界面管理" class="headerlink" title="获取checkout —–客户端图形界面管理"></a>获取checkout —–客户端图形界面管理</h2><p>下载<a href="https://tortoisesvn.net/" target="_blank" rel="external">tortoiesSVN</a></p><p>在文件夹先右键</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fjttkrxepwj30ba0jk774.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjttlhmmxgj30em0cymxl.jpg" alt=""><br>第一行填写版本库服务器地址</p><p>第二行需要导入的文件夹地址</p><h1 id="SVN自启动"><a href="#SVN自启动" class="headerlink" title="SVN自启动"></a>SVN自启动</h1><p>概念，当服务器开启自动启动svn服务<br>linux 开机根据启动级别启动<br>乌邦图下etc/rc.local文件中 exit 0 上面 写入 svn启动服务命令 svnserve -d -r /路径</p><blockquote><p>不同系统下修改的方式不同，可通过百度或者google查询修改方式</p></blockquote><h1 id="SVN常见术语与文件状态"><a href="#SVN常见术语与文件状态" class="headerlink" title="SVN常见术语与文件状态"></a>SVN常见术语与文件状态</h1><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjttmzj7ikj30ym0e5acm.jpg" alt=""></p><h1 id="常见的客户端命令"><a href="#常见的客户端命令" class="headerlink" title="常见的客户端命令"></a>常见的客户端命令</h1><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjttniegx0j30xn0iftdi.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">1.svn add                           --添加到版本控制文件中</div><div class="line">&lt;!-- 在svn客户端下从无版本控制状态添加文件到版本控制下 --&gt;</div><div class="line">svn add  文件名或文件夹              --当时用文件夹时，会自动递归添加文件夹下的所有文件</div><div class="line">svn add 文件夹 --non--recursive     --添加所有文件的时候</div><div class="line">svn add *</div><div class="line"></div><div class="line">&lt;!-- 注意：当出现前面只添加了文件夹没添加里面内容时，使用*只会把没有添加的添加上并且只扫描到文件夹不会添加文件夹中的文件</div><div class="line">解决 --&gt;</div><div class="line">svn add * --force                   --强制执行</div><div class="line"></div><div class="line">svn commit   -m &quot;&quot; 文件名            --提交修改到服务器</div><div class="line">&lt;!-- 创建一个新的版本号 缩写 ci    --&gt;</div><div class="line">类似git</div><div class="line">svn commit -m &quot;&quot;                     --可以添加备注信息 并提示版本号</div><div class="line">svn update                          --更新工作副本   </div><div class="line">&lt;!-- 当已经更新最新版本更新在使用命令将不会进行更新，默认只更新一次 --&gt;</div><div class="line">svn delete                          --从版本库中删除文件或者目录</div><div class="line"></div><div class="line">svn diff(di) -r 需要比较的版本号   </div><div class="line">                                    --版本差异比较  版本号 1:3 比较版本1和3</div><div class="line"></div><div class="line">svn mkdir                            --创建目录并添加到版本控制</div><div class="line">svn cat                             --路径文件 --脱离版本控制，查看文件</div></pre></td></tr></table></figure></p><h2 id="工作副本还原"><a href="#工作副本还原" class="headerlink" title="工作副本还原"></a>工作副本还原</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn revert   *                 --只会扫描当前目录的所有修改后还原</div><div class="line">svn revert  --recursive *      --递归扫描其他文件夹中的</div></pre></td></tr></table></figure><h2 id="二进制冲突与树冲突"><a href="#二进制冲突与树冲突" class="headerlink" title="二进制冲突与树冲突"></a>二进制冲突与树冲突</h2><p>场景：冲突常出现在工作副本长时间未更新<br>冲突：在其他程序员提交相同位置代码到代码块，而自己因为没有update，在相同的位置下进行修改，当发生提交的时候发生冲突<br>二进制冲突：文件一般是二进制，精确到代码的那一行<br>树冲突：不是二进制文件，无法精确具体一行<br><strong>处理冲突</strong><br><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fjtu2buztaj30nn0fcajn.jpg" alt=""></p><p>解读：</p><p>update 弹出输入提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">p:推迟提交</div><div class="line">df：显示不同</div><div class="line">e： 编辑文件</div><div class="line">m：合并</div><div class="line">mc：保留自己</div><div class="line">tc: 保留别人的</div></pre></td></tr></table></figure></p><p>df 对比图中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+&lt;&lt;&lt;&lt;&lt;&lt;自己的代码</div><div class="line">=======</div><div class="line">+&gt;&gt;&gt;&gt;&gt;&gt; xxx人的代码</div></pre></td></tr></table></figure></p><blockquote><p>推荐p推迟处理，推迟后回生成冲突文件，删除不需要的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!--通过文件修改后必须使用一下命令--&gt;</div><div class="line">svn resolved 文件名</div><div class="line">&lt;!--消除冲突后提交--&gt;</div></pre></td></tr></table></figure><h2 id="锁定与解锁"><a href="#锁定与解锁" class="headerlink" title="锁定与解锁"></a>锁定与解锁</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn lock -锁定文件，防止其他成员对文件进行提交</div><div class="line">svn unlock -解锁文件</div></pre></td></tr></table></figure><blockquote><p>lock 是一种conflict 处理方案，当遇到很多人对同一个文件进行修改，锁定只会影响开发效率</p><p>问题1：服务器上的版本库文件在哪里？</p><ol><li>把文件上传到SVN版本库后,上传的文件不再以文件原来的格式存储,而是被svn以它自定义的格式压缩成版本库数据,存放在版本库中。（17年9月26日）</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在中小型企业中开发一般会用到SVN 进行分布式开发，通过学习，熟悉以后的开发流程&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="SVN" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/SVN/"/>
    
    
      <category term="版本控制" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="SVN" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>Python个人笔记(2)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/03/Python%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-2/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/03/Python个人笔记-2/</id>
    <published>2017-09-03T01:44:21.000Z</published>
    <updated>2017-10-11T03:35:43.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《第六章》字典"><a href="#《第六章》字典" class="headerlink" title="《第六章》字典"></a>《第六章》字典</h1><p>  <strong>使用字典</strong><br>在 Python 中，字典是一系列键-值对。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式：name=&#123;<span class="string">'key'</span>:<span class="string">'value'</span>,<span class="string">'key2'</span>:<span class="string">'value'</span>&#125;</div></pre></td></tr></table></figure></p><p><strong>添加键-值对</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式：box[key]=value，利用这种方式，可以先创建一个空的字典，在添加键-值</div></pre></td></tr></table></figure></p><a id="more"></a><p><strong>修改字典中的值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">同添加键-值一样，当添加的键相同的时候，变为修改字典中的值</div></pre></td></tr></table></figure></p><p><strong>删除键-值对</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式：<span class="keyword">del</span>语句删除不需要的键-值</div></pre></td></tr></table></figure></p><p><strong>由类似对象组成的字典</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">favorite_languages=&#123;</div><div class="line">      <span class="string">'jen'</span>:<span class="string">'python'</span>,</div><div class="line">      <span class="string">'jack'</span>:<span class="string">'java'</span>,</div><div class="line">      <span class="string">'tom'</span>:<span class="string">'c++'</span>,</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p><h3 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> box.items():</div><div class="line">        print(key,value);</div></pre></td></tr></table></figure><p><strong>遍历字典中的所以键</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> box.keys():</div><div class="line">      print(name)</div></pre></td></tr></table></figure></p><p><strong>按顺序遍历字典中的所有键</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> sorted(box.items()):</div><div class="line">      print(name)</div></pre></td></tr></table></figure></p><p><strong>遍历字典中的所有值</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> box.values():</div><div class="line">      print(name)</div></pre></td></tr></table></figure></p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p><strong>字典列表</strong></p><ol><li>列表嵌套字典</li><li>字典嵌套字典</li><li>字典嵌套列表</li></ol><h1 id="《第七章》用户输入和while循环"><a href="#《第七章》用户输入和while循环" class="headerlink" title="《第七章》用户输入和while循环"></a>《第七章》用户输入和while循环</h1><h3 id="函数-input-的工作原理"><a href="#函数-input-的工作原理" class="headerlink" title="函数 input() 的工作原理"></a>函数 input() 的工作原理</h3><pre><code>input() 让程序暂停运行，等待用户输入</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">age=input(<span class="string">'请输入你的年龄'</span>)</div><div class="line">print(age)</div></pre></td></tr></table></figure><blockquote><p>*在支持暂停的编辑器下运行</p></blockquote><p><strong>使用int() 来获取数值输入</strong><br>在用input() 获取用户的输入值中，接受的是字符串类型，如果我们要接受数值，可以用int()函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">age=input(<span class="string">'请输入您的名字'</span>)</div><div class="line">age=int()</div><div class="line"><span class="keyword">if</span>(age&gt;<span class="number">3</span>)</div><div class="line">    print(<span class="string">'欢迎'</span>+age+<span class="string">'你'</span>)</div></pre></td></tr></table></figure></p><p><strong>求模运算符</strong><br> % 取余</p><h1 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h1><blockquote><p>for循环用于针对集合中每个元素的代码块，不进行修改内容<br>    while循环不断的运行，知道不符合条件时退出<br><strong>让用户选择何时退出</strong></p><ol><li>让循环条件不满足</li><li>使用标志<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> 的循环条件为布尔类型</div><div class="line">active=<span class="keyword">True</span></div><div class="line">age=int()</div><div class="line"><span class="keyword">while</span> active:</div><div class="line">    <span class="keyword">if</span> age==<span class="number">18</span>:</div><div class="line">        active=<span class="keyword">False</span></div></pre></td></tr></table></figure></li></ol></blockquote><ol><li>使用 break 退出循环<br> 在循环中使用break 将直接跳出讯循环</li><li>使用 continue<br> 在循环中使用 continue 将跳出循环，执行下一个循环</li></ol><blockquote><p>*在使用while循环的时候避免无限循环</p></blockquote><p><strong>使用while循环来处理列表和字典</strong><br>思路：while循环 一个列表 ,.pop()删除的内容复制给另一个列表中<br><strong>删除包含特定值得所有列表元素</strong><br>思路：while循环判断元素是否在列表中，然后remove()</p><p>#《第八章》函数<br><strong>定义函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></div><div class="line">      print(<span class="string">'hello'</span>)</div><div class="line"><span class="comment">#调用函数</span></div><div class="line">  greet_user()</div></pre></td></tr></table></figure></p><p><strong>向函数传递信息</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(username)</span>:</span></div><div class="line">    print(<span class="string">'hello,'</span>+username.title())</div><div class="line">greet-user(<span class="string">'jack'</span>)</div></pre></td></tr></table></figure></p><p><strong>实参和形参</strong></p><blockquote><p>*一个有具体值，一个没有</p></blockquote><h3 id="传递实参"><a href="#传递实参" class="headerlink" title="传递实参"></a>传递实参</h3><p><strong>位置实参的顺序</strong><br>在定义函数的同时，形参的顺序，也规定了在调用函数填入实参的顺序<br><strong>关键字实参</strong><br>关键字实参无需考虑顺序,在调用函数的时候，参数通过键-值传递<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(first_name,last_name)</span>:</span></div><div class="line">      print(<span class="string">'Hello'</span>+first_name+<span class="string">','</span>+last_name)</div><div class="line"></div><div class="line">greet_user(last_name=<span class="string">'abc'</span>,first_name=<span class="string">'python'</span>)</div></pre></td></tr></table></figure></p><p><strong>默认值</strong><br>给形参指定默认值 ，在实参默认省略的时候<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(first_name,last_name=<span class="string">'allen'</span>)</span>:</span></div><div class="line">      print(<span class="string">'Hello'</span>+first_name+<span class="string">','</span>+last_name)</div><div class="line"></div><div class="line">greet_user(first_name=<span class="string">'python'</span>)</div></pre></td></tr></table></figure></p><blockquote><p>*避免实参错误</p></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>return<br><strong>让实参变成可选的</strong><br>有时候,需要让实参变为可选的，这样使用函数的人在需要才提供额外的信息，<br>通过讲函数的形参设为=’’<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">(first_name,last_name=<span class="string">''</span>)</span>:</span></div><div class="line">      print(<span class="string">'Hello'</span>+first_name+<span class="string">','</span>+last_name)</div><div class="line">greet_user(<span class="string">'hello'</span>)</div></pre></td></tr></table></figure></p><p><strong>结合函数和while循环</strong><br>在函数中使用while循环<br><strong>传递列表</strong><br>将函数传入的参数为列表，并for循环遍历</p><p><strong>禁止函数修改列表</strong><br>当我们不需要修改原列表内容的时候可以向函数传递列表副本，通过切片的原理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">格式：</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">show_list</span><span class="params">(list_names)</span>:</span></div><div class="line">          <span class="keyword">for</span> list <span class="keyword">in</span> list_names:</div><div class="line">                print(list)</div><div class="line">list_name=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</div><div class="line">greet_user(list_name[:])</div><div class="line">print(list_name)</div></pre></td></tr></table></figure></p><p><strong>传递任意数量的实参</strong><br>*表示Python 创建一个名为 XX 的空元组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_print</span><span class="params">(*toppings)</span>:</span></div><div class="line">  <span class="string">"""打印"""</span></div><div class="line">    print(topping)</div><div class="line">make_print(<span class="string">'a'</span>)</div><div class="line">make_print(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</div></pre></td></tr></table></figure></p><p><strong>任意数量的关键字参数</strong> 表示可以接受任意数量的键-值数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_print</span><span class="params">(**toppings)</span>:</span></div><div class="line">  <span class="string">"""打印"""</span></div><div class="line">     print(topping)</div><div class="line">make_print(<span class="string">'a'</span>:<span class="string">'B'</span>)</div><div class="line">make_print(<span class="string">'a'</span>:<span class="string">'B'</span>,<span class="string">'c'</span>:<span class="string">'C'</span>)</div></pre></td></tr></table></figure></p><h3 id="将函数储存在模块中"><a href="#将函数储存在模块中" class="headerlink" title="将函数储存在模块中"></a>将函数储存在模块中</h3><p><strong>导入模块</strong><br>将写好的函数放在.py文件中<br>导入模块：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> file_name</div></pre></td></tr></table></figure></p><p><strong>导入特定的函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式：<span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</div></pre></td></tr></table></figure></p><p><strong>使用as给函数指定别名</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式：<span class="keyword">import</span> file_name <span class="keyword">as</span> fn</div></pre></td></tr></table></figure></p><p><strong>使用as给模块函数名指定别名</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">格式：<span class="keyword">from</span> module_name <span class="keyword">import</span> file_name <span class="keyword">as</span> fn</div></pre></td></tr></table></figure></p><p>–&lt;第八章&gt;END–</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《第六章》字典&quot;&gt;&lt;a href=&quot;#《第六章》字典&quot; class=&quot;headerlink&quot; title=&quot;《第六章》字典&quot;&gt;&lt;/a&gt;《第六章》字典&lt;/h1&gt;&lt;p&gt;  &lt;strong&gt;使用字典&lt;/strong&gt;&lt;br&gt;在 Python 中，字典是一系列键-值对。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;格式：name=&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;key&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;key2&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;value&#39;&lt;/span&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加键-值对&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;格式：box[key]=value，利用这种方式，可以先创建一个空的字典，在添加键-值&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python个人笔记(1)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/09/01/Python%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0-1/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/09/01/Python个人笔记-1/</id>
    <published>2017-09-01T01:44:16.000Z</published>
    <updated>2017-10-11T03:35:40.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《第一章》Python的安装"><a href="#《第一章》Python的安装" class="headerlink" title="《第一章》Python的安装"></a>《第一章》Python的安装</h1><h1 id="《第二章》变量和简单数据类型"><a href="#《第二章》变量和简单数据类型" class="headerlink" title="《第二章》变量和简单数据类型"></a>《第二章》变量和简单数据类型</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><strong>命名和使用：</strong>首字母不能为数字</p><p><strong>修改字符串的大小写：</strong></p><ul><li>.tittle()  首字母大写</li><li>.upper()  全部大写</li><li>.lower()   全部小写</li></ul><p><strong>合并字符串</strong><br>加号（+）<br><a id="more"></a><br><strong>使用制表或者换行符添加空白</strong><br>\t  \n<br><strong>删除空白</strong></p><ul><li>.rstript()  删除右边</li><li>.lstript()  删除左边</li><li>.stript()  删除两端</li></ul><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p><strong>整数</strong><br>加+减-乘<em>除/<br>其中</em> <em> </em>2乘表示平方，后面的数字表示乘多少次</p><p><strong>浮点数</strong><br>结果包含的小数位数是不确定的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0.2</span>+<span class="number">0.1</span></div><div class="line"><span class="number">0.30000000004</span></div><div class="line">&gt;&gt;&gt;<span class="number">3</span> * <span class="number">0.1</span></div><div class="line"><span class="number">0.30000000004</span></div></pre></td></tr></table></figure></p><blockquote><p><em>python2 中的整数 3/2 =1 保留整数部分</em>使用 str()避免类型错误</p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用 #</p><h1 id="《第三章》列表"><a href="#《第三章》列表" class="headerlink" title="《第三章》列表"></a>《第三章》列表</h1><p>([ ]) 表示列表并使用逗号来分隔其中的元素<br>访问任意元素通过索引<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">box=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</div><div class="line">print(box[<span class="number">1</span>])</div></pre></td></tr></table></figure></p><blockquote><p>*索引从0而不是1开始</p></blockquote><h3 id="修改，添加和删除元素"><a href="#修改，添加和删除元素" class="headerlink" title="修改，添加和删除元素**"></a>修改，添加和删除元素**</h3><p><strong>替换</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">box[<span class="number">1</span>]=<span class="string">'d'</span>;</div></pre></td></tr></table></figure></p><p><strong>添加</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">append(<span class="string">'d'</span>)</div><div class="line"><span class="comment"># 末尾添加</span></div></pre></td></tr></table></figure></p><p><strong>插入</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">insert(index,值)</div></pre></td></tr></table></figure></p><p><strong>删除</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">del</span> box[<span class="number">1</span>]</div><div class="line"><span class="comment"># del 语句直接删除</span></div><div class="line"></div><div class="line">pop()  </div><div class="line"><span class="comment"># 末尾删除 *术语弹出（pop）</span></div><div class="line"></div><div class="line">&gt;&gt;&gt;box = [<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">&gt;&gt;&gt;print(box.pop(<span class="number">1</span>))</div><div class="line">b</div><div class="line"><span class="comment"># 弹出列表任意位置元素</span></div><div class="line"></div><div class="line">remove(值)</div><div class="line"><span class="comment"># 根据值删除元素</span></div></pre></td></tr></table></figure></p><h3 id="组织列表"><a href="#组织列表" class="headerlink" title="组织列表"></a>组织列表</h3><ul><li>sort() 永久排序</li><li>sort(reverse=Ture) 排序反转</li><li>sorted() 对列表进行临时排序</li><li>reverse() 不进行倒序，只是进行列表反向输出</li></ul><p><strong>长度</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">length=box.len()</div><div class="line">print(len(box))</div></pre></td></tr></table></figure></p><blockquote><p>*避免索引引起错误</p><h1 id="《第四章》操作列表"><a href="#《第四章》操作列表" class="headerlink" title="《第四章》操作列表"></a>《第四章》操作列表</h1><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><p><strong>for循环</strong><br>格式： for 单个名称 in 列表 ：<br>                  语句</p><p>*避免缩进带来的错误<br>遗漏冒号带来的错误</p></blockquote><h3 id="创建数值列表"><a href="#创建数值列表" class="headerlink" title="创建数值列表"></a>创建数值列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">range(start,end)</div><div class="line"><span class="comment"># 创建数字列表</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(range(<span class="number">1</span>,<span class="number">5</span>)))</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"><span class="comment"># list()将range()的结果直接转换为列表</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(range(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>)))</div><div class="line">[<span class="number">2</span>,<span class="number">4</span>]</div><div class="line"><span class="comment">#range(start,end,step) 最后一个指定步长</span></div></pre></td></tr></table></figure><p><strong>对数字列表进行简单的统计计算</strong></p><ul><li>min() 取列表最小值</li><li>max() 取列表最大值</li><li>sum() 取合</li></ul><h3 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h3><p>列表解析，通过三四行代码实现的效果，通过列表解析，一行进行实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 法1</span></div><div class="line">squares=[]</div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>):</div><div class="line">    squares.append(value**<span class="number">2</span>)</div><div class="line">print(squares)</div><div class="line"></div><div class="line"><span class="comment"># 法2</span></div><div class="line">&gt;&gt;&gt;squares=[value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">5</span>)]</div><div class="line">&gt;&gt;&gt;print(squares)</div></pre></td></tr></table></figure></p><h3 id="使用列表的一部分"><a href="#使用列表的一部分" class="headerlink" title="使用列表的一部分"></a>使用列表的一部分</h3><p><strong>切片</strong><br>处理列表中的部分元素可以使用切片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">box=[<span class="string">'g'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">print(box[<span class="number">0</span>:<span class="number">1</span>])</div><div class="line">[g,a]</div><div class="line"><span class="comment"># 切取：前开始：后结束的部分</span></div><div class="line"></div><div class="line">box=[<span class="string">'g'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">print(box[:<span class="number">1</span>])</div><div class="line">[g,a]</div><div class="line"><span class="comment"># :前没有数字表示从开始到指定结束</span></div><div class="line"></div><div class="line">box=[<span class="string">'g'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">print(box[<span class="number">1</span>:])</div><div class="line">[a，b]</div><div class="line"><span class="comment"># ：后没有数字表示从指定开始到结束</span></div><div class="line"></div><div class="line">box=[<span class="string">'g'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">print(box[<span class="number">-2</span>：]</div><div class="line">[a,b]</div><div class="line"><span class="comment"># 负数索引表示从尾部切取</span></div></pre></td></tr></table></figure></p><p><strong>遍历切片</strong><br>遍历列表部分元素，可在循环中使用切片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;box=[<span class="string">'g'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> value <span class="keyword">in</span> box[<span class="number">-2</span>:]:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>   print(value)</div><div class="line">[a,b]</div></pre></td></tr></table></figure></p><p><strong>复制列表</strong><br>同时省略：前后<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;box=[<span class="string">'g'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">&gt;&gt;&gt;box2=box[:]</div></pre></td></tr></table></figure></p><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>python 将不能修改的值称之为不可变的,而不可变的列表称为元组<br>() 圆括号表示元组<br><strong>定义元组</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">abc=(<span class="number">200</span>,<span class="number">50</span>)</div><div class="line">print(abc[<span class="number">0</span>])</div></pre></td></tr></table></figure></p><blockquote><p>*尝试修改元组会报错</p></blockquote><p><strong>修改元组</strong><br>虽然不能修改元组的元素，但可以给储存元组的变量赋值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;box=(<span class="number">200</span>,<span class="number">50</span>)</div><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> value <span class="keyword">in</span> box:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>   print(value)</div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">50</span></div><div class="line">&gt;&gt;&gt;box=(<span class="number">100</span>,<span class="number">100</span>)</div><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> value <span class="keyword">in</span> box:</div><div class="line"> &gt;&gt;&gt;   print(value)</div><div class="line"><span class="number">100</span></div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure></p><p><strong>代码格式</strong></p><ul><li>每行不超过 80 字符</li><li>注释行不超过 72 字符</li></ul><h1 id="《第五章》-IF-语句"><a href="#《第五章》-IF-语句" class="headerlink" title="《第五章》 IF 语句"></a>《第五章》 IF 语句</h1><p><strong>格式：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> 条件：</div><div class="line">                 语句</div><div class="line">           <span class="keyword">else</span>:</div><div class="line">                 语句</div></pre></td></tr></table></figure></p><p><strong>检查多个条件</strong></p><ol><li>使用 and 检查多个条件（同时满足）</li><li>使用 or 检查多个条件（满足一个即可）</li><li>使用 in 检查是否包含在列表中</li></ol><p><strong>if-elif-else</strong><br>使用if-elif-else处理多分支语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">8</span>):</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">if</span> value==<span class="number">1</span>:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>           print(str(value)+<span class="string">'st'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">elif</span> value==<span class="number">2</span>:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>           print(str(value)+<span class="string">'nd'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>   elid value==<span class="number">3</span>:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>           print(str(value)+<span class="string">'rd'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">else</span>:</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>         print(str(value)+<span class="string">'th'</span>)</div><div class="line"><span class="number">1</span>st</div><div class="line"><span class="number">2</span>nd</div><div class="line"><span class="number">3</span>rd</div><div class="line"><span class="number">4</span>th</div><div class="line"><span class="number">5</span>th</div><div class="line"><span class="number">6</span>th</div><div class="line"><span class="number">7</span>th</div></pre></td></tr></table></figure></p><p>&lt;第五章–END–&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《第一章》Python的安装&quot;&gt;&lt;a href=&quot;#《第一章》Python的安装&quot; class=&quot;headerlink&quot; title=&quot;《第一章》Python的安装&quot;&gt;&lt;/a&gt;《第一章》Python的安装&lt;/h1&gt;&lt;h1 id=&quot;《第二章》变量和简单数据类型&quot;&gt;&lt;a href=&quot;#《第二章》变量和简单数据类型&quot; class=&quot;headerlink&quot; title=&quot;《第二章》变量和简单数据类型&quot;&gt;&lt;/a&gt;《第二章》变量和简单数据类型&lt;/h1&gt;&lt;h2 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;命名和使用：&lt;/strong&gt;首字母不能为数字&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改字符串的大小写：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.tittle()  首字母大写&lt;/li&gt;
&lt;li&gt;.upper()  全部大写&lt;/li&gt;
&lt;li&gt;.lower()   全部小写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;合并字符串&lt;/strong&gt;&lt;br&gt;加号（+）&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Python(5)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/08/07/%E8%8F%9C%E9%B8%9FPython(5)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/08/07/菜鸟Python(5)/</id>
    <published>2017-08-07T11:41:16.000Z</published>
    <updated>2017-10-24T10:34:52.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电影网站"><a href="#电影网站" class="headerlink" title="电影网站"></a>电影网站</h1><a id="more"></a><p>实现一个电影页面<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fieqavrreej30vo0e0qfj.jpg" alt=""></p><h2 id="实现基本要素"><a href="#实现基本要素" class="headerlink" title="实现基本要素"></a>实现基本要素</h2><ol><li>电影标题</li><li>电影描述</li><li>电影图片</li><li>电影网站</li></ol><h2 id="创建-Movie-类"><a href="#创建-Movie-类" class="headerlink" title="创建 Movie 类"></a>创建 Movie 类</h2><p>创建 media.py 的文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> webbrowser</div><div class="line"><span class="comment"># 创建 Movie 类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Movie</span><span class="params">()</span>:</span></div><div class="line"><span class="comment"># 定义 __init__方法 self 代表实例化对象</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,movie_title,movie_storyline,poster_image,trailer_youtube)</span>:</span></div><div class="line">    self.title=movie_title</div><div class="line">    self.storyline=movie_storyline</div><div class="line">    self.poster_image_url=poster_image</div><div class="line">    self.trailer_youtube_url=trailer_youtube</div></pre></td></tr></table></figure></p><h2 id="调用-Movie-类"><a href="#调用-Movie-类" class="headerlink" title="调用 Movie 类"></a>调用 Movie 类</h2><p>创建一个 show_html.py 的文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导入 media 文件</span></div><div class="line"><span class="keyword">import</span> media</div><div class="line">open_html=media.Movie(<span class="string">"玩具总动员"</span>,<span class="string">"一群玩具的大作战..."</span>,<span class="string">"http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg"</span>,<span class="string">"https://v.qq.com/x/cover/cezngt65nqkg580.html"</span>)</div><div class="line">print(open_html.title)</div></pre></td></tr></table></figure></p><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fier872y7kj30kc01vweg.jpg" alt=""></p><h2 id="用网页打开"><a href="#用网页打开" class="headerlink" title="用网页打开"></a>用网页打开</h2><p>下载 <a href="https://github.com/LowApe/ud036_StarterCode/blob/master/fresh_tomatoes.py" target="_blank" rel="external">fresh_tomatoes.py</a><br> 这个文件包含要生成的 HTML 文件 和两个方法改变标题，电影图片…<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fierdfm6c0j30m80m3gp0.jpg" alt=""></p><p>在 show_html.py 文件中修改<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导入 media 文件</span></div><div class="line"><span class="keyword">import</span> media</div><div class="line"><span class="keyword">import</span> fresh_tomatoes</div><div class="line"></div><div class="line">toy_movie = media.Movie(<span class="string">"玩具总动员"</span>,<span class="string">"一群玩具的大作战..."</span>,<span class="string">"http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg"</span>,<span class="string">"https://v.qq.com/x/cover/cezngt65nqkg580.html"</span>)</div><div class="line">toy_movie1 = media.Movie(<span class="string">"玩具总动员"</span>,<span class="string">"一群玩具的大作战..."</span>,<span class="string">"http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg"</span>,<span class="string">"https://v.qq.com/x/cover/cezngt65nqkg580.html"</span>)</div><div class="line">toy_movie2 = media.Movie(<span class="string">"玩具总动员"</span>,<span class="string">"一群玩具的大作战..."</span>,<span class="string">"http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg"</span>,<span class="string">"https://v.qq.com/x/cover/cezngt65nqkg580.html"</span>)</div><div class="line">toy_movie3 = media.Movie(<span class="string">"玩具总动员"</span>,<span class="string">"一群玩具的大作战..."</span>,<span class="string">"http://ww1.sinaimg.cn/large/006rAlqhly1fier45q4tvj30fp0mbe2e.jpg"</span>,<span class="string">"https://v.qq.com/x/cover/cezngt65nqkg580.html"</span>)</div><div class="line">movies=[toy_movie,toy_movie1,toy_movie2,toy_movie3]</div><div class="line">fresh_tomatoes.open_movies_page(movies)</div></pre></td></tr></table></figure></p><p> 效果：<br> <img src="http://ww1.sinaimg.cn/large/006rAlqhly1fierg6pbczj31ge0oewq5.jpg" alt=""></p><h1 id="解决乱码"><a href="#解决乱码" class="headerlink" title="解决乱码"></a>解决乱码</h1><p> fresh_tomatoes.py 文件中 编写的 HTML 文件将 编码方式改成 GBK</p><p> <img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1fiestqekvtj316x0n613o.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;电影网站&quot;&gt;&lt;a href=&quot;#电影网站&quot; class=&quot;headerlink&quot; title=&quot;电影网站&quot;&gt;&lt;/a&gt;电影网站&lt;/h1&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Python(4)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/08/07/%E8%8F%9C%E9%B8%9FPython(4)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/08/07/菜鸟Python(4)/</id>
    <published>2017-08-07T10:31:16.000Z</published>
    <updated>2017-10-24T10:34:47.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不敬语查询"><a href="#不敬语查询" class="headerlink" title="不敬语查询"></a>不敬语查询</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义一个读取的方法</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_text</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 调用 open 内置函数打开文件</span></div><div class="line">    quotes = open(<span class="string">"E:\ButterKnife.txt"</span>)</div><div class="line">    <span class="comment"># 读取文件</span></div><div class="line">    contents_of_file=quotes.read()</div><div class="line">    print(contents_of_file)</div><div class="line">    quotes.close()</div><div class="line">read_text()</div></pre></td></tr></table></figure><a id="more"></a><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p><a href="https://docs.python.org/2/library/functions.html" target="_blank" rel="external">Ptyhon 中的内置函数</a></p><h2 id="利用代码访问网站"><a href="#利用代码访问网站" class="headerlink" title="利用代码访问网站"></a>利用代码访问网站</h2><p><a href="http://www.wdylike.appspot.com/?q=shot" target="_blank" rel="external">不敬语查询网站</a> 可能需要进行科学上网，<br>利用这个网站后缀，进行查询是否存在不文明的字<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_text</span><span class="params">()</span>:</span></div><div class="line">    quotes = open(<span class="string">"E:\ButterKnife.txt"</span>)</div><div class="line">    contents_of_file=quotes.read()</div><div class="line">    print(contents_of_file)</div><div class="line">    quotes.close()</div><div class="line">    check_profanity(contents_of_file)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_profanity</span><span class="params">(check_text)</span>:</span></div><div class="line">    connection=urllib.urlopen(<span class="string">"http://www.wdylike.appspot.com/?q="</span>+check_text)</div><div class="line">    output=connection.read()</div><div class="line">    print(output)</div><div class="line">    connection.close()</div><div class="line">read_text()</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;不敬语查询&quot;&gt;&lt;a href=&quot;#不敬语查询&quot; class=&quot;headerlink&quot; title=&quot;不敬语查询&quot;&gt;&lt;/a&gt;不敬语查询&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义一个读取的方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read_text&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 调用 open 内置函数打开文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    quotes = open(&lt;span class=&quot;string&quot;&gt;&quot;E:\ButterKnife.txt&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 读取文件&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    contents_of_file=quotes.read()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(contents_of_file)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    quotes.close()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;read_text()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Python(3)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/28/%E8%8F%9C%E9%B8%9FPython(3)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/28/菜鸟Python(3)/</id>
    <published>2017-07-27T16:15:16.000Z</published>
    <updated>2017-10-24T10:34:41.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用类-发送消息"><a href="#使用类-发送消息" class="headerlink" title="使用类-发送消息"></a>使用类-发送消息</h1><p>实现结果：通过 twilio 实现给手机发送短信</p><h2 id="下载-twilio"><a href="#下载-twilio" class="headerlink" title="下载 twilio"></a>下载 twilio</h2><p>进入 cmd 命令窗口，选择其中一个</p><ol><li>easy_install twilio</li><li>pip install twilio<a id="more"></a><h2 id="注册-twilio"><a href="#注册-twilio" class="headerlink" title="注册 twilio"></a>注册 twilio</h2></li></ol><p><a href="https://www.twilio.com/" target="_blank" rel="external">Twilio 注册地址</a> 在注册的时候选择 SMS</p><p>获取sid和token</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhzo5apadjj30lz08lgm5.jpg" alt="获取sid和token"></p><p>获取发送号码<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhzoa05vc6j314e0g6dhg.jpg" alt="获取发送号码"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> twilio.rest <span class="keyword">import</span> Client</div><div class="line"></div><div class="line"><span class="comment"># Your Account SID from twilio.com/console</span></div><div class="line">account_sid = <span class="string">"ACdxxxxxxxxxxxxxxxxxxxxxxxx"</span></div><div class="line"><span class="comment"># Your Auth Token from twilio.com/console</span></div><div class="line">auth_token  = <span class="string">"d5xxxxxxxxxxxxxxxxxxxxxxxx"</span></div><div class="line"></div><div class="line">client = Client(account_sid, auth_token)</div><div class="line"><span class="comment"># 电话号码在注册的时候会获取，接受手机是注册的手机</span></div><div class="line">message = client.messages.create(</div><div class="line">    to=<span class="string">"+861510xxxxxxx"</span>,</div><div class="line">    from_=<span class="string">"+16195667xxxx"</span>,</div><div class="line">    body=<span class="string">"I Love You !"</span>)</div><div class="line"><span class="comment"># body 显示发送的内容</span></div><div class="line">print(message.sid)</div></pre></td></tr></table></figure><p>执行结果<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhzocxzuaej314w0ko422.jpg" alt=""></p><h2 id="如何实现发送"><a href="#如何实现发送" class="headerlink" title="如何实现发送"></a>如何实现发送</h2><p>分析代码第一行，from 关键字获取twilio文件中的rest 文件，import 导入 Client 类<br>可以通过<a href="https://github.com/LowApe/twilio-python" target="_blank" rel="external">GitHub中查看</a><br>找到 twilio ——&gt; rest——&gt;  <em>init</em>.py ——&gt; Client类</p><p>具体代码实现，可以自己查看<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhzoifpt37j31300kxmzv.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上一篇我们介绍了 Python类 的介绍，介绍类的实例化，这一章通过介绍 twilio 更加深入了解类的使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用类-发送消息&quot;&gt;&lt;a href=&quot;#使用类-发送消息&quot; class=&quot;headerlink&quot; title=&quot;使用类-发送消息&quot;&gt;&lt;/a&gt;使用类-发送消息&lt;/h1&gt;&lt;p&gt;实现结果：通过 twilio 实现给手机发送短信&lt;/p&gt;
&lt;h2 id=&quot;下载-twilio&quot;&gt;&lt;a href=&quot;#下载-twilio&quot; class=&quot;headerlink&quot; title=&quot;下载 twilio&quot;&gt;&lt;/a&gt;下载 twilio&lt;/h2&gt;&lt;p&gt;进入 cmd 命令窗口，选择其中一个&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;easy_install twilio&lt;/li&gt;
&lt;li&gt;pip install twilio
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Python(2)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/27/%E8%8F%9C%E9%B8%9FPython(2)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/27/菜鸟Python(2)/</id>
    <published>2017-07-27T07:15:16.000Z</published>
    <updated>2017-10-24T10:33:08.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的类"><a href="#Python-中的类" class="headerlink" title="Python 中的类"></a>Python 中的类</h1><p>前面使用到的函数都是直接调用函数，比如 webbrowser.open() 或 time.ctime() 这些通过调用函数来进行操作，今天我们使用 turtle 来介绍 Python 中的类<br><a id="more"></a></p><h2 id="turtle"><a href="#turtle" class="headerlink" title="turtle"></a>turtle</h2><p>先看我们需要实现的效果<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhyico8b9ug30iw0dg7ae.gif" alt=""></p><p>turtle 翻译过来是乌龟的意思，它能实现绘画的效果，要想实现以上图案，需要先会画一条直线，然后正方形，然后旋转</p><h3 id="画一个正方形"><a href="#画一个正方形" class="headerlink" title="画一个正方形"></a>画一个正方形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> turtle</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_square</span><span class="params">(some_param)</span>:</span></div><div class="line">    <span class="comment"># 定义循环变量</span></div><div class="line">    init=<span class="number">0</span></div><div class="line">    end=<span class="number">4</span></div><div class="line">    <span class="keyword">while</span>(init&lt;end):</div><div class="line">        <span class="comment"># 向前走100码</span></div><div class="line">        some_param.forward(<span class="number">100</span>)</div><div class="line">        <span class="comment"># 向右旋转90度</span></div><div class="line">        some_param.right(<span class="number">90</span>)</div><div class="line">        init+=<span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_paint</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment"># 将turtle屏幕赋值给window</span></div><div class="line">    window=turtle.Screen()</div><div class="line">    window.bgcolor(<span class="string">"red"</span>)</div><div class="line">    <span class="comment"># 执行turtle进行绘画</span></div><div class="line">    brad=turtle.Turtle()</div><div class="line">    <span class="comment"># 改变turtle的形状</span></div><div class="line">    brad.shape(<span class="string">"turtle"</span>)</div><div class="line">    <span class="comment"># 改变turtle的颜色，两个参数第一个表示划线颜色，第二个表示箭头颜色</span></div><div class="line">    brad.color(<span class="string">"yellow"</span>, <span class="string">"black"</span>)</div><div class="line">    <span class="comment"># 改变turtle的速度</span></div><div class="line">    brad.speed(<span class="number">10</span>)</div><div class="line">    draw_square(brad)</div><div class="line">    <span class="comment"># 将屏幕固定在屏幕上，点击后关闭</span></div><div class="line">    window.exitonclick()</div><div class="line">draw_paint()</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhyi92fcmyg30fc0be74n.gif" alt=""></p><p>现在画完了正方形，在把每次画完正方形后面添加移动角度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i int range(<span class="number">1</span>,<span class="number">36</span>):</div><div class="line">    draw_square(brad)</div><div class="line">    brad.right(<span class="number">10</span>)</div></pre></td></tr></table></figure></p><p>其中有三个函数，用来改变turtle的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 执行turtle进行绘画</span></div><div class="line">brad=turtle.Turtle()</div><div class="line"><span class="comment"># 改变turtle的形状</span></div><div class="line">brad.shape(<span class="string">"turtle"</span>)</div><div class="line"><span class="comment"># 改变turtle的颜色，两个参数第一个表示划线颜色，第二个表示箭头颜色</span></div><div class="line">brad.color(<span class="string">"yellow"</span>, <span class="string">"black"</span>)</div><div class="line"><span class="comment"># 改变turtle的速度</span></div><div class="line">brad.speed(<span class="number">10</span>)</div></pre></td></tr></table></figure><p>我们回顾一下 webbrowser.open() 和  turtle.Turtle()<br>这两个虽然都是调用方法，但是turtle不同的是调用的一个Turtle()类，这个类有 init 函数进行初始化，跟其他语言差不多，在使用类，可以通过不同的实例进行不同的调用。类的概念好比一张设计图，我们的实例，相当于照着设计图设计不同的大楼。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的类&quot;&gt;&lt;a href=&quot;#Python-中的类&quot; class=&quot;headerlink&quot; title=&quot;Python 中的类&quot;&gt;&lt;/a&gt;Python 中的类&lt;/h1&gt;&lt;p&gt;前面使用到的函数都是直接调用函数，比如 webbrowser.open() 或 time.ctime() 这些通过调用函数来进行操作，今天我们使用 turtle 来介绍 Python 中的类&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Android(1)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/15/%E8%8F%9C%E9%B8%9FAndroid(2)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/15/菜鸟Android(2)/</id>
    <published>2017-07-15T11:15:18.000Z</published>
    <updated>2017-10-24T10:33:09.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>在应用中记录信息，选用的日志级别</p><ol><li>ERROR 出现在程序崩溃或结束，用于记录明显的错误</li><li>WARN 不会出现崩溃，但会记录提示性警告</li><li>INFO 提示文本类消息</li><li>DEBUG</li><li>VERBOSE</li><li>WTF  what a Terrible Failure 提示永远不可能发生的错误<br>(强制设备停止，并输出调试报告)<a id="more"></a><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fhkueid7djj311q0cv42p.jpg" alt="前三个存在于发行版本中"></li></ol><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h1&gt;&lt;p&gt;在应用中记录信息，选用的日志级别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ERROR 出现在程序崩溃或结束，用于记录明显的错误&lt;/li&gt;
&lt;li&gt;WARN 不会出现崩溃，但会记录提示性警告&lt;/li&gt;
&lt;li&gt;INFO 提示文本类消息&lt;/li&gt;
&lt;li&gt;DEBUG&lt;/li&gt;
&lt;li&gt;VERBOSE&lt;/li&gt;
&lt;li&gt;WTF  what a Terrible Failure 提示永远不可能发生的错误&lt;br&gt;(强制设备停止，并输出调试报告)
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb随心笔记(3)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/09/JavaWeb%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0(3)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/09/JavaWeb随心笔记(3)/</id>
    <published>2017-07-09T11:15:16.000Z</published>
    <updated>2017-10-11T03:35:10.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的购物商城"><a href="#简单的购物商城" class="headerlink" title="简单的购物商城"></a>简单的购物商城</h1><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>创建数据库表</li><li>连接数据库</li><li>创建 bean 层</li><li>创建 dao 层</li><li>三个页面<pre><code>第一个显示商品列表（利用 ArrayList 存储每一条信息）第二个显示详情列表（利用 Item.getId() 记录点击的详情，进行数据库查询）第三个显示购物列表（利用 插入数据库操作）</code></pre></li></ol><p>游览记录 通过 Cookie 记录游览记录，</p><pre><code>创建 Cookie创建字符串，将每次点击的id记录到一个字符串中通过split 获取字符串数组在biz 层处理后5条字符串，并将后五条存储在 ArrayList 中</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的购物商城&quot;&gt;&lt;a href=&quot;#简单的购物商城&quot; class=&quot;headerlink&quot; title=&quot;简单的购物商城&quot;&gt;&lt;/a&gt;简单的购物商城&lt;/h1&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb随心笔记(2)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/08/JavaWeb%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0(2)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/08/JavaWeb随心笔记(2)/</id>
    <published>2017-07-08T12:15:16.000Z</published>
    <updated>2017-10-11T03:35:08.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP-相关技术"><a href="#JSP-相关技术" class="headerlink" title="JSP 相关技术"></a>JSP 相关技术</h1><p>JSP 是在 HTML 页面中嵌入 Java 代码。HTML 负责页面的静态部分， Java 代码负责动态部分，java 代码获取服务端的数据，并利用数据在游览器上。JSP 的实质是 Servlet，具体通过 jsp 的生命周期理解。<br><a id="more"></a></p><h2 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h2><p><strong>格式:</strong>&lt;%@ page 属性名=”Value” 属性名=”Value” &gt;<br>language=”java”<br>Content-Type=”text/html;charset=utf-8”<br>import=””</p><h2 id="JSP-注释"><a href="#JSP-注释" class="headerlink" title="JSP 注释"></a>JSP 注释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- --&gt; HTML 注释，可以再游览器中查看</div><div class="line">&lt;%-- --%&gt; 注释不能再游览器中查看</div><div class="line">&lt;% java 代码 %&gt;  jsp 脚本  </div><div class="line">&lt;!% java 代码 %&gt; jsp 的声明，定义变量和方法</div><div class="line">&lt;%= %&gt; jsp 的表达式 可以调用 jsp 中声明的 java 代码</div></pre></td></tr></table></figure><h2 id="JSP-的生命周期"><a href="#JSP-的生命周期" class="headerlink" title="JSP 的生命周期"></a>JSP 的生命周期</h2><p>详情页面:<a href="http://www.runoob.com/jsp/jsp-life-cycle.html" target="_blank" rel="external">菜鸟教程</a></p><h2 id="JSP-的内置对象"><a href="#JSP-的内置对象" class="headerlink" title="JSP 的内置对象"></a>JSP 的内置对象</h2><ol><li>request</li><li>response</li><li>out (向游览器输出内容)</li><li>page (表示当前页面)</li><li>pageContent (当前页面的上下文环境，可以获取上下文的数据)</li><li>session (一次会话)</li><li>application (开始于服务器的启动,结束与服务器的结束)</li><li>exception (异常)</li><li>config (在 Servlet 初始化的时候来获取相关参数和传递信息)</li></ol><h3 id="利用-application-实现网站计数器"><a href="#利用-application-实现网站计数器" class="headerlink" title="利用 application 实现网站计数器"></a>利用 application 实现网站计数器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;%</div><div class="line"><span class="comment">//获取应用中的Counter 值</span></div><div class="line">    <span class="keyword">if</span>(application.getAttribute(<span class="string">"counter"</span>)==<span class="keyword">null</span>)&#123;</div><div class="line">        application.setAttribute(<span class="string">"counter"</span>,<span class="keyword">new</span> Integer(<span class="number">1</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果存在就 +1</span></div><div class="line">    <span class="keyword">int</span> value=(Integer)application.getAttribute(<span class="string">"counter"</span>);</div><div class="line">    application.setAttribute(<span class="string">"counter"</span>,<span class="keyword">new</span> Integer(value+<span class="number">1</span>));</div><div class="line">%&gt;</div><div class="line">欢迎第&lt;%application.getAttribute(<span class="string">"conter"</span>) %&gt;名顾客访问！</div></pre></td></tr></table></figure><h2 id="javaBean-的简介"><a href="#javaBean-的简介" class="headerlink" title="javaBean 的简介"></a>javaBean 的简介</h2><ol><li>该类是一个公共类</li><li>必须有一个无参的构造方法</li><li>必须有所有的属性私有</li><li>通过 getter 和 setter 进行私有属性的存取</li></ol><h3 id="在-JSP-中使用-JavaBean"><a href="#在-JSP-中使用-JavaBean" class="headerlink" title="在 JSP 中使用 JavaBean"></a>在 JSP 中使用 JavaBean</h3><h4 id="普通方式"><a href="#普通方式" class="headerlink" title="普通方式"></a>普通方式</h4><ol><li>导包(&lt;%@page import=”bean.User”&gt;)</li><li>使用(&lt;% User user=new User()%&gt;)</li></ol><h4 id="使用-JSP-标签"><a href="#使用-JSP-标签" class="headerlink" title="使用 JSP 标签"></a>使用 JSP 标签</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;jsp:useBean id=<span class="string">"myUser"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"bean.User"</span> scope=<span class="string">"page"</span>/&gt;</div><div class="line">用户名称&lt;%myUser.getName()%&gt;</div></pre></td></tr></table></figure><h4 id="SetProperty-标签"><a href="#SetProperty-标签" class="headerlink" title="SetProperty 标签"></a>SetProperty 标签</h4><p>配合 useBean 标签使用，给你usebean 赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//匹配信息到User 中的名字</span></div><div class="line">&lt;jsp:setProperty property=<span class="string">"username"</span> name=<span class="string">"myUser"</span> /&gt;</div><div class="line"><span class="comment">//将密码匹配到User</span></div><div class="line">&lt;jsp:setProperty property=<span class="string">"password"</span> name=<span class="string">"myUser"</span> value=<span class="string">"123456"</span>/&gt;</div></pre></td></tr></table></figure></p><h2 id="JavaBean-中作用域"><a href="#JavaBean-中作用域" class="headerlink" title="JavaBean 中作用域"></a>JavaBean 中作用域</h2><ol><li>page 当前页面有效</li><li>request 一次请求有效</li><li>session 一次会话有效</li><li>application 从服务器开启到服务器关闭有效</li></ol><h2 id="JSP-的动作和指令"><a href="#JSP-的动作和指令" class="headerlink" title="JSP 的动作和指令"></a>JSP 的动作和指令</h2><p>详情页面:</p><p><a href="https://www.tianmaying.com/tutorial/jsp-directive-and-action" target="_blank" rel="external">JSP 的动作和指令</a></p><p><a href="http://www.runoob.com/jsp/jsp-actions.html" target="_blank" rel="external">菜鸟教程 JSP 指令</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JSP-相关技术&quot;&gt;&lt;a href=&quot;#JSP-相关技术&quot; class=&quot;headerlink&quot; title=&quot;JSP 相关技术&quot;&gt;&lt;/a&gt;JSP 相关技术&lt;/h1&gt;&lt;p&gt;JSP 是在 HTML 页面中嵌入 Java 代码。HTML 负责页面的静态部分， Java 代码负责动态部分，java 代码获取服务端的数据，并利用数据在游览器上。JSP 的实质是 Servlet，具体通过 jsp 的生命周期理解。&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb随心笔记(1)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/07/JavaWeb%E9%9A%8F%E5%BF%83%E7%AC%94%E8%AE%B0(1)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/07/JavaWeb随心笔记(1)/</id>
    <published>2017-07-07T10:49:25.000Z</published>
    <updated>2017-10-11T03:35:28.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读目录"><a href="#阅读目录" class="headerlink" title="阅读目录"></a>阅读目录</h1><ul><li><a href="#1">Q1: JavaSE JavaEE JavaME 的区别?</a></li><li><a href="#2">Q2: Servlet 的作用？</a></li><li><a href="#3">Q3: WEB中 Servlet &lt; load-on-startup &gt;1&lt;/ load-on-startup &gt;标签代表什么意思</a></li><li><a href="#5">Q5: 如何获取访问的设备类型</a></li><li><a href="#6">Q6: 如何固定时间自动跳转页面</a></li><li><a href="#7">Q7: 如何设置一个下载页面</a></li><li><a href="#8">Q8:如何设置防盗链</a></li><li><a href="#9">Q9:如何利用 Cookie 判断首次登陆</a></li><li><a href="#10">Q10: Session</a><a id="more"></a><h2 id="Q1-JavaSE-JavaEE-JavaME-的区别"><a href="#Q1-JavaSE-JavaEE-JavaME-的区别" class="headerlink" title="Q1: JavaSE JavaEE JavaME 的区别?"></a><a id="1">Q1: JavaSE JavaEE JavaME 的区别?</a></h2></li></ul><ol><li>JavaSE 标准版本</li><li>JavaEE 企业版本</li><li>JavaME 移动版本</li></ol><h2 id="Q2-Servlet-的作用？"><a href="#Q2-Servlet-的作用？" class="headerlink" title="Q2: Servlet 的作用？"></a><a id="2">Q2: Servlet 的作用？</a></h2><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fh9yi912u7j308j05jaag.jpg" alt=""></p><h2 id="Q3-WEB中-Servlet-lt-load-on-startup-gt-1-lt-load-on-startup-gt-标签代表什么意思"><a href="#Q3-WEB中-Servlet-lt-load-on-startup-gt-1-lt-load-on-startup-gt-标签代表什么意思" class="headerlink" title="Q3: WEB中 Servlet &lt; load-on-startup &gt;1&lt;/ load-on-startup &gt;标签代表什么意思"></a><a id="3">Q3: WEB中 Servlet &lt; load-on-startup &gt;1&lt;/ load-on-startup &gt;标签代表什么意思</a></h2><ol><li>伴随服务器的启动，启动Servlet</li><li>标签值中大于0或等于0的表示伴随服务器的启动，自动启动Servlet</li><li>标签值小于0或者没有标签的表示，选择时再启用</li><li>其中数值表示优先级，在很多需要启动的 Servlet 中数值越小优先级越大</li></ol><h2 id="Q4-获取文件的真实路径"><a href="#Q4-获取文件的真实路径" class="headerlink" title="Q4: 获取文件的真实路径"></a><a id="4">Q4: 获取文件的真实路径</a></h2><p>在做文件处理的情况下，不能把路径写成绝地路径，因为我们最后需要搭建到服务器上，所以把路径写到相对路径上就会省去不必要的麻烦</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String realPath=request.getServletContent.getRealPath(<span class="string">""</span>);</div></pre></td></tr></table></figure><h2 id="Q5-如何获取访问的设备类型"><a href="#Q5-如何获取访问的设备类型" class="headerlink" title="Q5: 如何获取访问的设备类型"></a><a id="5">Q5: 如何获取访问的设备类型</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String from=request.getHeader(<span class="string">"User-Agent"</span>);</div><div class="line"><span class="keyword">if</span>(from.indexOf(<span class="string">"Windows"</span>)&gt;<span class="number">0</span>)&#123;</div><div class="line">    userFrom =<span class="string">"来自Windows的用户！"</span>;</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(from.indexOf(<span class="string">"Macintosh"</span>)&gt;<span class="number">0</span>)&#123;</div><div class="line">    userFrom =<span class="string">"来自 Mac 的用户！"</span>;</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(from.indexOf(<span class="string">"Android"</span>)&gt;<span class="number">0</span>)&#123;</div><div class="line">    userFrom =<span class="string">"来自 Android 的用户！"</span>;</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(from.indexOf(<span class="string">"IPhone"</span>)&gt;<span class="number">0</span>)&#123;</div><div class="line">    userFrom =<span class="string">"来自 IPhone 的用户！"</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>indexOf(str) 获取第一次出现的字符串索引</p><h4 id="Q6-如何固定时间自动跳转页面"><a href="#Q6-如何固定时间自动跳转页面" class="headerlink" title="Q6: 如何固定时间自动跳转页面"></a><a id="6">Q6: 如何固定时间自动跳转页面</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response.setHeader(<span class="string">"Refresh"</span>,<span class="string">"2,URL=路径"</span>);</div></pre></td></tr></table></figure><h2 id="Q7-如何设置一个下载页面"><a href="#Q7-如何设置一个下载页面" class="headerlink" title="Q7: 如何设置一个下载页面"></a><a id="7">Q7: 如何设置一个下载页面</a></h2><ol><li>获取文件名称</li><li>获取文件路径</li><li>创建文件对象，并判断是否存在</li><li>设置游览器的的类型为应用下载(application/x-msDownload)</li><li>设置游览器的下载方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取下载名称</span></div><div class="line">String filename=request.getParameter(<span class="string">"filename"</span>);</div><div class="line"><span class="comment">//获取路径名称</span></div><div class="line">String downloadPath=<span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/"</span>)+<span class="string">"WEB-INF\\Logs\\"</span>;</div><div class="line"><span class="keyword">if</span>(file.exists())&#123;</div><div class="line"><span class="comment">//对游览器进行下载设置</span></div><div class="line">response.setContentType(<span class="string">"application/x-msDownload"</span>);</div><div class="line"><span class="comment">//对游览器进行设置，将下载的内容作为附件，并指定文件名</span></div><div class="line">response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename=\""</span>+filename+<span class="string">"\""</span>);</div><div class="line"><span class="comment">//打开输入输出流</span></div><div class="line">InputStream inputStream=<span class="keyword">new</span> FileInputStream(file);</div><div class="line">ServletOutputStream servletOutputStream=response.getOutputStream();</div><div class="line"><span class="comment">//开始进行文件读写</span></div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">while</span>((n=inputStream.read(b))!=-<span class="number">1</span>)&#123;</div><div class="line">servletOutputStream.write(b, <span class="number">0</span>, n);</div><div class="line">&#125;</div><div class="line">inputStream.close();</div><div class="line">servletOutputStream.close();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">//下载不存在</span></div><div class="line">PrintWriter out=response.getWriter();</div><div class="line">out.print(<span class="string">"下载文件不存在...."</span>);</div><div class="line">out.flush();</div><div class="line">out.close();</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Q8-如何设置防盗链"><a href="#Q8-如何设置防盗链" class="headerlink" title="Q8:如何设置防盗链"></a><a id="8">Q8:如何设置防盗链</a></h2><p>referer：当访客访问网页时，HTTP来源地址是前一个网页的URL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">String referer=request.getHeader(<span class="string">"referer"</span>);</div><div class="line">String sitePart=<span class="string">"http://"</span>+request.getServerName();</div><div class="line">System.out.println(referer+<span class="string">"\n"</span>+sitePart);</div><div class="line"><span class="keyword">if</span>(referer!=<span class="keyword">null</span>&amp;&amp; referer.startsWith(sitePart))&#123;</div><div class="line"><span class="keyword">if</span>(file.exists())&#123;</div><div class="line"><span class="comment">//对游览器进行下载设置</span></div><div class="line">response.setContentType(<span class="string">"application/x-msDownload"</span>);</div><div class="line"><span class="comment">//对游览器进行设置，将下载的内容作为附件，并指定文件名</span></div><div class="line">response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename=\""</span>+filename+<span class="string">"\""</span>);</div><div class="line"><span class="comment">//打开输入输出流</span></div><div class="line">InputStream inputStream=<span class="keyword">new</span> FileInputStream(file);</div><div class="line">ServletOutputStream servletOutputStream=response.getOutputStream();</div><div class="line"><span class="comment">//开始进行文件读写</span></div><div class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> n;</div><div class="line"><span class="keyword">while</span>((n=inputStream.read(b))!=-<span class="number">1</span>)&#123;</div><div class="line">servletOutputStream.write(b, <span class="number">0</span>, n);</div><div class="line">&#125;</div><div class="line">inputStream.close();</div><div class="line">servletOutputStream.close();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">//下载不存在</span></div><div class="line">PrintWriter out=response.getWriter();</div><div class="line">out.print(<span class="string">"下载文件不存在...."</span>);</div><div class="line">out.flush();</div><div class="line">out.close();</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">//跳转到自己的页面</span></div><div class="line">      request.getRequestDispatcher(<span class="string">"自己的现在地址"</span>).format(request,response);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h2 id="Q9-如何利用-Cookie-判断首次登陆"><a href="#Q9-如何利用-Cookie-判断首次登陆" class="headerlink" title="Q9:如何利用 Cookie 判断首次登陆"></a><a id="9">Q9:如何利用 Cookie 判断首次登陆</a></h2><p>添加 Cookies</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">"key"</span>,value);</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">//创建 Cookie 对象，获取出现的 Cookie 的值</span></div><div class="line">  Cookie lastCookie=<span class="keyword">null</span>;</div><div class="line">  <span class="comment">//创建 Cookie 数组用来获取游览器中的所有 Cookie</span></div><div class="line">  Cookie[] cookies=request.getCookies();</div><div class="line">  <span class="comment">//遍历所有 cookies</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;cookies!=<span class="keyword">null</span> &amp;&amp; i&lt;cookies.length;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="string">"以前添加键"</span>.equals(cookies[i].getName()))&#123;</div><div class="line">        lastCookie=cookies[i].getValue();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="keyword">if</span>(lastCookie==<span class="keyword">null</span>)&#123;</div><div class="line">    response.getWriter.print(<span class="string">"欢迎新用户"</span>);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    response.getWriter.print(<span class="string">"欢迎老用户"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Q10-Session"><a href="#Q10-Session" class="headerlink" title="Q10: Session"></a>Q10: <a id="10">Session</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 Session</span></div><div class="line">HttpSession session=request。getSession();</div><div class="line"><span class="comment">//存放对象</span></div><div class="line">session.setAttribute(<span class="string">"key"</span>,value);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阅读目录&quot;&gt;&lt;a href=&quot;#阅读目录&quot; class=&quot;headerlink&quot; title=&quot;阅读目录&quot;&gt;&lt;/a&gt;阅读目录&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Q1: JavaSE JavaEE JavaME 的区别?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2&quot;&gt;Q2: Servlet 的作用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3&quot;&gt;Q3: WEB中 Servlet &amp;lt; load-on-startup &amp;gt;1&amp;lt;/ load-on-startup &amp;gt;标签代表什么意思&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5&quot;&gt;Q5: 如何获取访问的设备类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6&quot;&gt;Q6: 如何固定时间自动跳转页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7&quot;&gt;Q7: 如何设置一个下载页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8&quot;&gt;Q8:如何设置防盗链&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9&quot;&gt;Q9:如何利用 Cookie 判断首次登陆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10&quot;&gt;Q10: Session&lt;/a&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Git基础命令</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/03/Git%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/03/Git基础命令/</id>
    <published>2017-07-03T14:48:58.000Z</published>
    <updated>2017-10-11T03:34:27.320Z</updated>
    
    <content type="html"><![CDATA[<p>git init git                     初始化</p><p>git status                     查询状态<br><a id="more"></a><br>git log                         查看日志</p><p>git add                        添加文件到暂存区</p><p>git commit                  提交在暂存区的文件</p><p>git diff xxx xxx             比较文件</p><p>git branch                   查看分支</p><p>git branch xxx             创建新的分支</p><p>git checkout xx           切换分支</p><p>git checkout -b xxx     创建新的分支并切换</p><p>git merge master test 合并两个分支（当分支同一级都做了修改，合并的时候会出现冲突，具体参考下面的冲突）</p><p>git show id                   显示父级跟系版本的改动</p><p>git branch -d test         删除分支</p><p>merge conflict</p><p>HEAD标记表示我的代码<br>中间部分是已修改的原始版本<br>底部标记的分支是表示该分支的代码</p><p>方法：删除原始数据和不需要的留下来的代码，保留需要的代码</p><p>git remote                 查看远程库和创建远程数据库</p><p>git remote add 名称   远程数据库地址</p><p>git remote -v             显示详细的信息</p><p>git push 名称 分支      推送到github</p><p>git pull   名称 分支      github上拉取</p><p>GitHub 上fork 是获取其他人的库，并不需要先clone本地然后在上传 fork显示其他人获取的数量<br>git fetch                      更新远程分支的本地副本而实际的本地版本保持不变</p><p>情景：在获取远程库副本到本地，进行操作的时候 git pull 相当等于git fetch 更新然后 git merge 进行合并<br>自己画图梳理了一下。<br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fh7385al6qj31gn0ra0u2.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fh739tocyej30ox02lt8k.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fh739btltyj30wb0a5aau.jpg" alt=""><br>git merge master origin/master 合并本地数据库和远程数据库副本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</div><div class="line">这一层表示本地自己修改的信息</div><div class="line">| | | | | | | | | 表示原版本</div><div class="line">这一层表示原版本的信息</div><div class="line">========</div><div class="line">这一层表示origin/master 分支的信息</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master</div></pre></td></tr></table></figure><p>解读完上述信息，合并保留需要的删除其他两个-&gt;git add 文件-&gt;git commit；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git init git                     初始化&lt;/p&gt;
&lt;p&gt;git status                     查询状态&lt;br&gt;
    
    </summary>
    
      <category term="Git笔记" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Git%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Git" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Git/"/>
    
      <category term="GitHub" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Python(1)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/03/%E8%8F%9C%E9%B8%9FPython(1)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/03/菜鸟Python(1)/</id>
    <published>2017-07-03T11:15:16.000Z</published>
    <updated>2017-10-24T10:33:02.891Z</updated>
    
    <content type="html"><![CDATA[<p>Python 是<strong>解释型</strong>语言 java 是<strong>编译型</strong>语言</p><ul><li>解释型语言，发布相当等于公布源码.</li><li>解释型语言，运行时间长</li></ul><ul><li>编译型语言，通过编译器编译成机器可以读的语言，源代码不公开.</li><li>编译型语言运行时间短，因为它编译成机器可读的<a id="more"></a></li></ul><p>可以看看<a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431608990315a01b575e2ab041168ff0df194698afac000" target="_blank" rel="external">廖雪峰 Python介绍</a></p><h5 id="1-练习1（Take-a-break）"><a href="#1-练习1（Take-a-break）" class="headerlink" title="1.练习1（Take a break）"></a>1.练习1（Take a break）</h5><p><strong>打开游览器</strong></p><ol><li>import webbrowser 导入webbrowser包</li><li>webbrowser.open(“网址”);</li><li>运行</li></ol><p><strong>添加等待时间</strong></p><ol><li>import time</li><li>time.sleep(10)</li></ol><p><strong>添加循环</strong></p><ol><li>total_times=3  init_times=0</li><li>添加循环</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> webbrowser</div><div class="line"><span class="keyword">import</span> time</div><div class="line">total_times=<span class="number">3</span>  </div><div class="line">init_times=<span class="number">0</span></div><div class="line"></div><div class="line">print(<span class="string">"开始执行..."</span>+time.ctime())</div><div class="line"><span class="keyword">while</span>(total_times&gt;init_times):</div><div class="line">  time.sleep(<span class="number">10</span>)</div><div class="line">  webbrowser.open(<span class="string">"111.13.100.91"</span>);</div><div class="line">  init_times+=<span class="number">1</span></div></pre></td></tr></table></figure><p><strong>注意Python中的 while 循环格式</strong></p><h4 id="2-Python-标准库"><a href="#2-Python-标准库" class="headerlink" title="2.Python 标准库"></a>2.Python 标准库</h4><p>上述的小练习，有两个模块，一个 webbrowser ，一个 time ，每个模块拥有各自的函数，webbrowser 拥有 open 函数，time 模块拥有 sleep 函数和 ctime 函数，而这些东西都在 <a href="http://usyiyi.cn/translate/python_278/library/index.html" target="_blank" rel="external">Python 标准库</a>,可以通过查询标准库，来实现对 Python 的理解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python 是&lt;strong&gt;解释型&lt;/strong&gt;语言 java 是&lt;strong&gt;编译型&lt;/strong&gt;语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解释型语言，发布相当等于公布源码.&lt;/li&gt;
&lt;li&gt;解释型语言，运行时间长&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;编译型语言，通过编译器编译成机器可以读的语言，源代码不公开.&lt;/li&gt;
&lt;li&gt;编译型语言运行时间短，因为它编译成机器可读的
    
    </summary>
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>菜鸟Android(1)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/07/01/%E8%8F%9C%E9%B8%9FAndroid(1)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/07/01/菜鸟Android(1)/</id>
    <published>2017-07-01T11:15:18.000Z</published>
    <updated>2017-10-24T10:33:10.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-四大组件"><a href="#Android-四大组件" class="headerlink" title="Android 四大组件"></a>Android 四大组件</h1><ol><li>Activity</li><li>Service</li><li>Content Provider</li><li>Broadcast Receiver<a id="more"></a><strong>这四个组件在 AndroidMainifest 上注册才能被 Android 识别</strong></li></ol><h2 id="1-Activity"><a href="#1-Activity" class="headerlink" title="1. Activity"></a>1. Activity</h2><p>Activity 是一个交互软件，每一个 Activity 都对应一个 XML 布局，布局内包含其他视图组件，用于显示视图。 Android FrameWork 包含大量的工具包用来帮助构建用户界面。<br>在 res 目录下的 layout 文件夹中包含布局文件，当在主 Activity.java 的 onCreate 方法下使用 SetContentView(R.layout.name); 方法可填充布局，用来显示页面</p><p>在打开一个 Activity 实现交互的时候，当点击后退按钮，系统显示堆栈的上一个 Activity 如果堆栈为空则返回启动器</p><p><img src="http://ww1.sinaimg.cn/large/006rAlqhly1fh7qtxl874j30wd0gy13e.jpg" alt="Activity注册标签"></p><p>  从图中可以看到，应用标签内是 Activity 组件，组件内部是一个 Intent 过滤器标签，其中一个标签提到 <strong><a href="http://baike.baidu.com/link?url=jsD_5gv1EyOmXfwIfPeqHN9qDvkVgL5weCIYYzWzJIoDZgv1mPLGBzw0V7EAp09THCurTd0KvjIf38eB_OyhN0BfSoVcDl-LVro8p3yg_Sm" target="_blank" rel="external">Launcher 启动器</a></strong></p><h3 id="布局-XML"><a href="#布局-XML" class="headerlink" title="布局 XML"></a>布局 XML</h3><p>  <strong>视图类型</strong></p><ol><li>UI组件</li></ol><table><thead><tr><th style="text-align:left">UI 组件</th></tr></thead><tbody><tr><td style="text-align:left">TextView</td></tr><tr><td style="text-align:left">EditView</td></tr><tr><td style="text-align:left">button</td></tr><tr><td style="text-align:left">…</td></tr></tbody></table><p>Android studio 自带视图编辑器，可直接拖动视图，来实现布局,还可以在约束布局（ConstraintLayout）下通过视图推理功能，进行自适应布局。</p><ol><li>容器视图</li></ol><table><thead><tr><th style="text-align:left">类名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">LinearLayout</td><td style="text-align:left">在一行或一列里显示视图</td></tr><tr><td style="text-align:left">RelativeLayout</td><td style="text-align:left">相对某个视图放置其他视图</td></tr><tr><td style="text-align:left">FrameLayout</td><td style="text-align:left">ViewGroup 包含一个子视图</td></tr><tr><td style="text-align:left">ScrollView</td><td style="text-align:left">一种 FrameLayout，旨在让用户能够在视图中滚动查看内</td></tr><tr><td style="text-align:left">ConstraintLayout</td><td style="text-align:left">（约束布局）这是更新的 viewgroup；可以灵活地放置视图</td></tr></tbody></table><h3 id="XML-的属性"><a href="#XML-的属性" class="headerlink" title="XML 的属性"></a>XML 的属性</h3><p>每个视图都具有大量的属性，可以在相关的文档页面查看这些属性。这些属性可以设为不同的值。属性确定了视图的外观细节和互动方式。</p><h3 id="R类"><a href="#R类" class="headerlink" title="R类"></a>R类</h3><p>当你的应用被编译时，系统会生成 R 类。它会创建常量，使你能够动态地确定 res 文件夹的各种内容，包括布局。要了解详情，请参阅关于<a href="http://developer.android.youdaxue.com/guide/topics/resources/accessing-resources.html" target="_blank" rel="external">资源</a>的文档。</p><h3 id="ID"><a href="#ID" class="headerlink" title="ID"></a>ID</h3><p>ID 是 Android 用于识别和定位各种控件的 <strong>数字标志</strong> Android 工具实际上会帮助我们生成这个数字,我们只需要给它标志名称即可。如：<br> @+id/标识名称</p><ul><li>@ 告诉工具不要将括号里的内容视为字符串文本</li><li><ul><li>告诉工具如果 ID 不存在 则创建一个</li></ul></li><li>/ 斜线前的 ID 告诉工具我们这是创建 ID</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-四大组件&quot;&gt;&lt;a href=&quot;#Android-四大组件&quot; class=&quot;headerlink&quot; title=&quot;Android 四大组件&quot;&gt;&lt;/a&gt;Android 四大组件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Activity&lt;/li&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;Content Provider&lt;/li&gt;
&lt;li&gt;Broadcast Receiver
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title> AsyncTask 和 AsyncTaskLoader 的使用</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/05/07/AsyncTask-%E5%92%8C-AsyncTaskLoader-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/05/07/AsyncTask-和-AsyncTaskLoader-的使用/</id>
    <published>2017-05-07T09:17:15.000Z</published>
    <updated>2017-10-30T02:45:25.887Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇 <a href="">JSON学习</a> 中介绍了 JSON 对象的结构，如何解析 JSON 数据，但是我们的 JSON 数据是本地已经转换的 String 类型，现在我们处理网上的 JSON 数据,用到了网上的操作，必然要进行网络的连接，讲到网络部分，有必然使用到多线程，所以本篇侧重于介绍多线程部分。</p></blockquote><a id="more"></a><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><p>我们最初的 Android 学习中，默认都是在主线程( MainThread )进行操作的,主线程也叫做 UI 线程，一般的添加控件之类的操作都是主线程运行的，下面的图可以很好的说明，我们一般的绘图操作，点击按钮的操作，网络请求…都是在主线程上运行，但是这些操作的会被放到队列中，顺序执行，每次执行一个事件。</p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-a9c2c78edc82d60f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="主线程 "></p><p>然而我们为什么要使用多线程，我们可能遇到过这样的情况，当我们访问一些 APP 的时候，在做一些网络请求的时候，界面会不动，当你点击界面上的按钮时，会出现是否停止响应的按钮。</p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-b57e3a20b2b4fc93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="结束未响应程序|center"></p><p>为什么会出现这种情况？那是因为我们的网络请求很可能写到主线程上，当你进行网络请求时，应用可以需要一段时间去连接，获取，解析数据，但是同时你又多次按下了按钮，这些操作会出现到你的主线程队列上，但是应用并没有执行你的操作，以至于导致线程阻塞，一段时间后 Android 系统会显示上图的提示。</p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-ed038291380333b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="主线程"></p><blockquote><p>所以 Android 有个重要原则：<strong>不能把网络请求放到主线程</strong>  ，也就是<strong>不能阻塞 UI 线程</strong>，所以这个问题的解决方案就是使用<strong>多线程</strong>，让各自的操作到各自的线程中进行，网络访问一个线程，数据处理一个线程….这里我们只需要一个后台线程，用来处理网络请求。关于<strong>进程和线程</strong>可以访问<a href="http://developer.android.youdaxue.com/guide/components/processes-and-threads.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics" target="_blank" rel="external">官方链接</a></p></blockquote><h2 id="AsyncTask-处理多线程"><a href="#AsyncTask-处理多线程" class="headerlink" title="AsyncTask 处理多线程"></a>AsyncTask 处理多线程</h2><p>Android为了降低开发难度，提供了AsyncTask。AsyncTask就是一个封装过的后台任务类，就是异步任务。它是在 Android  上线程之间进行线程和消息传递的抽象类，并不适用与任何情况，在使用的情况下，考虑当前的使用背景。<br>先来介绍一下 AyncTask 的基本用法。AyncTask 是一个抽象类，要使用这个抽象类需要建立一个子类去继承它，在继承这个类的同时需要规定三个泛型参数，我们为了便于理解，我们把着三个泛型参数放到方法之后讲解，先来讲解 AyncTask 的四个方法：</p><ol><li><p><strong>onPreExcute()：</strong><br><strong>UI 线程中调用</strong> 该方法在后台任务执行之前调用，一般用于界面的初始化操作，如：显示一个进度条。</p></li><li><p><strong>doInBackground(Params…)：</strong><br><strong>后台线程中调用</strong> ，该方法用于处理耗时操作，操作一旦完成既可以通过 return 来返回执行结果。用过要在该方法中更新 UI 可以手动调用 publishProgres(Progress…) 方法来完成。</p></li><li><p><strong>onProgressUpdate(Progress…)：</strong><br><strong>UI 线程中调用</strong> 利用该方法可以对 UI 进行相应的更新。该方法的使用必须在 doInBackground() 方法使用 publishProgres() 方法</p></li><li><p><strong>onPostExcute(Result)：</strong><br><strong>UI 线程中调用</strong>  在doInBackground(Params…)中返回的数据会作为参数传递到该方法中。 可以利用后台线程返回的参数进行 UI 操作。</p></li></ol><p>现在我们在讲一讲 AyncTask 中的三个泛型参数，配合上述的方法，你会很快找到对应的规律和使用方法。</p><ul><li>Params：在执行 AyncTask 需要传入的参数，用于后台任务使用。对应 doInBackground()</li><li>Progress：后台任务执行时,如果需要在界面上显示当前的进度。对应onProgressUpdate()</li><li>Result：当任务完毕的情况下，如果需要对结果进行返回，则使用该返回值类型,对应方法onPostExcute()</li></ul><p>##　练习操作<br>＞这个项目是获取网上地震数据并进行显示的应用。效果图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-1554d2827be13e59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="效果图"></p><p>先顶一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryUtils</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">QueryUtils</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"><span class="comment">//该方法进行网络连接，获取数据，解析数据</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Info&gt; <span class="title">fetchEarthquakeDatas</span><span class="params">(String requestUrl)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*调用方法处理正确的url*/</span></div><div class="line">        URL url = createUrl(requestUrl);</div><div class="line">         <span class="comment">/*定义一个json响应的变量*/</span></div><div class="line">        String jsonResponse = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">/*调用一个方法获取jsonResponse*/</span></div><div class="line">            jsonResponse = makeHttpRequest(url);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*extractFeatureFromJson一个提取json数据的方法*/</span></div><div class="line">        List&lt;Info&gt; listItem = extractFeatureFromJson(jsonResponse);</div><div class="line">        <span class="keyword">return</span> listItem;</div><div class="line">    &#125;</div><div class="line"><span class="comment">/*创建一个方法，处理传入的Url*/</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> URL <span class="title">createUrl</span><span class="params">(String stringUrl)</span> </span>&#123;</div><div class="line">        URL url = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            url = <span class="keyword">new</span> URL(stringUrl);</div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> url;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*创建一个方法，连接网络获取jsonResponse*/</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">makeHttpRequest</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        String jsonResponse = <span class="string">""</span>;</div><div class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">return</span> jsonResponse;</div><div class="line">        <span class="comment">/*初始化网络连接*/</span></div><div class="line">        HttpURLConnection urlConnection = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">/*初始化输入流,因为返回的是一个字符串类型，所以要读取数据*/</span></div><div class="line">        InputStream inputStream = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            urlConnection = (HttpURLConnection) url.openConnection();</div><div class="line">            urlConnection.setReadTimeout(<span class="number">10000</span>);</div><div class="line">            urlConnection.setConnectTimeout(<span class="number">15000</span>);</div><div class="line">            urlConnection.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">            urlConnection.connect();</div><div class="line">            <span class="keyword">if</span> (urlConnection.getResponseCode() == <span class="number">200</span>) &#123;</div><div class="line">                Log.i(TAG_LOG, <span class="string">"启动网络服务成功"</span>);</div><div class="line">                Log.v(<span class="string">"MainActivity"</span>, String.valueOf(urlConnection.getResponseCode()));</div><div class="line">                 <span class="comment">/*得到他的输入流，也就是读取*/</span></div><div class="line">                inputStream = urlConnection.getInputStream();</div><div class="line">                <span class="comment">/*调用一个方法，读取数据*/</span></div><div class="line">                jsonResponse = readFromStream(inputStream);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                Log.i(TAG_LOG, <span class="string">"启动网络服务失败"</span>);</div><div class="line">                Log.v(<span class="string">"MainActivity"</span>, String.valueOf(urlConnection.getResponseCode()));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) urlConnection.disconnect();</div><div class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">                inputStream.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> jsonResponse;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/*创建一个方法读取输入流的数据*/</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFromStream</span><span class="params">(InputStream inputStream)</span> </span>&#123;</div><div class="line">    <span class="comment">/*字符串的拼接*/</span></div><div class="line">        StringBuilder output = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</div><div class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, Charset.forName(<span class="string">"UTF-8"</span>));</div><div class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                String line = reader.readLine();</div><div class="line">                <span class="keyword">while</span> (line != <span class="keyword">null</span>) &#123;</div><div class="line">                    output.append(line);</div><div class="line">                    line = reader.readLine();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*如果输入流不为空，进行数据读取转换为字符串类型*/</span></div><div class="line">        <span class="keyword">return</span> output.toString(); <span class="comment">/*返回字符串*/</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">/*创建一个提取json数据的方法*/</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Info&gt; <span class="title">extractFeatureFromJson</span><span class="params">(String earthquakeJSON)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(earthquakeJSON)) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         <span class="comment">/*因为返回类型是List&lt;Info&gt;,所以新建一个对象*/</span></div><div class="line">        List&lt;Info&gt; listItem = <span class="keyword">new</span> ArrayList&lt;Info&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            JSONObject root = <span class="keyword">new</span> JSONObject(earthquakeJSON);</div><div class="line">            JSONArray featureArray = root.getJSONArray(<span class="string">"features"</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; featureArray.length(); i++) &#123;</div><div class="line">                JSONObject feature = featureArray.getJSONObject(i);</div><div class="line">                JSONObject properties = feature.getJSONObject(<span class="string">"properties"</span>);</div><div class="line">                Double mag = properties.getDouble(<span class="string">"mag"</span>);</div><div class="line">                String place = properties.getString(<span class="string">"place"</span>);</div><div class="line">                Long time = properties.getLong(<span class="string">"time"</span>);</div><div class="line">                String urlString = properties.getString(<span class="string">"url"</span>);</div><div class="line">                URL url = <span class="keyword">new</span> URL(urlString);</div><div class="line">                listItem.add(<span class="keyword">new</span> Info(mag, place, time, url));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> listItem;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面 QueryUtils 类 一个网络请求的类，我们需要使用 AsyncTask 内部类，调用我们这个网络访问类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*创建一个AsyncTask的内部类*/</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EarthAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">List</span>&lt;<span class="title">Info</span>&gt;&gt; </span>&#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">protected</span> List&lt;Info&gt; <span class="title">doInBackground</span><span class="params">(String... urls)</span> </span>&#123;</div><div class="line">           Log.i(TAG_LOG, <span class="string">"doInBackground()"</span>);</div><div class="line">           <span class="keyword">if</span> (urls.length &lt; <span class="number">1</span> || urls[<span class="number">0</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">           List&lt;Info&gt; result = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">try</span> &#123;     </div><div class="line">               result = QueryUtils.fetchEarthquakeDatas(urls[<span class="number">0</span>]);</div><div class="line">           &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">               e.printStackTrace();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(List&lt;Info&gt; result)</span> </span>&#123;</div><div class="line">       <span class="comment">/* 清除之前地震数据的适配器*/</span></div><div class="line"></div><div class="line">           adapter.clear();</div><div class="line">           <span class="comment">/*  add与addALL的区别在于add方法即便加入一个list也只是保存其中一条，addAll 保存全部*/</span></div><div class="line">           <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; !result.isEmpty()) adapter.addAll(result);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h2 id="为什么要使用-AsyncTaskLoader-？"><a href="#为什么要使用-AsyncTaskLoader-？" class="headerlink" title="为什么要使用 AsyncTaskLoader ？"></a>为什么要使用 AsyncTaskLoader ？</h2><p>当我们旋转屏幕的时候，会改变设备配置。<strong>设备配置</strong>是用来描述设备当前状态的一系列特征。当我们旋转屏幕时，我们重新创建了一个新的活动，相当于创建了两个 AsyncTask ，可能这个问题看起来没什么问题，我们都知道我们手机有内存限制，当我们频繁的旋转设备，就会造成大量的 AsyncTask 的资源占用，还有就是每次设备更改时，都会访问一次 Internet ，这不仅仅是造成不必要的流量丢失，还造成数据利用率极低。需要注意的，当 AsyncTask 数量增加时，Android 系统并不会自动释放不用的资源，因为 AsyncTask 是原始<strong>活动的</strong>的内部类，所以只有 AsyncTask 结束才会统一释放资源，如何处理上述所说的问题，这里就用到 <strong>Loader</strong></p><p>关于 Loader 介绍，我们可以查看<a href="http://developer.android.youdaxue.com/guide/components/loaders.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics" target="_blank" rel="external">官方文档</a></p><p>在上述的项目中，我们如何加入 AsyncTaskLoader 来处理设备配置的问题？<br>首先，我们先创建一个子类继承 AsyncTaskLoader 并实现一个最重要的方法<strong>loadInBackground()</strong>，该方法和<strong>doInBackground()</strong>原理相同</p><p>其次，创建完这个 AsyncTaskLoader 的子类，我们需要用到一个 <strong>LoaderManager</strong> 顾名思义，它是管理我们 Loader 的类，要想让我们的类使用 Loader 就必须使用 LoaderManager.LoaderCallbacks<e> 接口，这样 LoaderManager 就可以通知我们创建 加载器 Loader 。<br>并且实现三个方法</e></p><ol><li><strong>onCreateLoader（）</strong><br>当loadermanager调用initLoader()时, 首先检查指定的id是否存在，如果不存在才会触发该方法，通过该方法才能创建一个loader</li><li><strong>onLoadFinished（）</strong><br>当一个加载器 完成了它的装载过程后被调用</li><li><strong>onLoaderReset（）</strong><br>当一个加载器 被重置而什其数据无效时被调用</li></ol><p>不多说直接贴代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EarthquakeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">LoaderManager</span>.<span class="title">LoaderCallbacks</span>&lt;<span class="title">List</span>&lt;<span class="title">Info</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> TextView emptyTextView;</div><div class="line">    <span class="keyword">private</span> InfoAdapter adapter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REQUEST_URL = <span class="string">"https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&amp;orderby=time&amp;minmag=5&amp;limit=10"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        Log.i(TAG_LOG, <span class="string">"onCreate()"</span>);</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.earthquake_activity);</div><div class="line">        emptyTextView = (TextView) findViewById(R.id.empty_tv);</div><div class="line">      <span class="comment">/*获取listView*/</span></div><div class="line">        ListView earthquakeListView = (ListView) findViewById(R.id.list);</div><div class="line">     <span class="comment">/*将空视图和list进行挂接，实现当加载不出来时，显示提示文本*/</span></div><div class="line">        earthquakeListView.setEmptyView(emptyTextView);</div><div class="line">        adapter = <span class="keyword">new</span> InfoAdapter(<span class="keyword">this</span>, <span class="keyword">new</span> ArrayList&lt;Info&gt;());</div><div class="line"><span class="comment">/*绑定适配器*/</span></div><div class="line">        earthquakeListView.setAdapter(adapter);</div><div class="line"><span class="comment">/*判断是否联网*/</span></div><div class="line">        ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</div><div class="line">        NetworkInfo activeNetWork = cm.getActiveNetworkInfo();</div><div class="line">        <span class="keyword">if</span> (activeNetWork != <span class="keyword">null</span> &amp;&amp; activeNetWork.isConnectedOrConnecting()) &#123; <span class="comment">/*初始化loader*/</span></div><div class="line">            getLoaderManager().initLoader(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">this</span>); <span class="comment">/*添加项目点击监听器*/</span></div><div class="line">            Log.i(TAG_LOG, <span class="string">"initLoader()"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            View loading_progress_Bar = findViewById(R.id.loading_progressbar);</div><div class="line">            loading_progress_Bar.setVisibility(View.GONE);</div><div class="line">            emptyTextView.setText(<span class="string">"no Internet"</span>);</div><div class="line">        &#125;</div><div class="line">        earthquakeListView.setOnItemClickListener(<span class="keyword">new</span> AdapterView.OnItemClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; adapterView, View view, <span class="keyword">int</span> i, <span class="keyword">long</span> l)</span> </span>&#123; <span class="comment">/*查找单机的当前地震*/</span></div><div class="line">                Info currentInfo = (Info) adapter.getItem(i); <span class="comment">/*获取uri对象???*/</span></div><div class="line">                Uri infoUri = Uri.parse(currentInfo.getURL().toString()); <span class="comment">/*创建一个新的Intent*/</span></div><div class="line">                Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, infoUri);</div><div class="line">                startActivity(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;); <span class="comment">/* 实例化AsyncTask 并执行*/</span></div><div class="line">        EarthAsyncTask task = <span class="keyword">new</span> EarthAsyncTask();</div><div class="line">        task.execute(REQUEST_URL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> android.content.Loader&lt;List&lt;Info&gt;&gt; onCreateLoader(<span class="keyword">int</span> i, Bundle bundle) &#123;</div><div class="line">        Log.i(TAG_LOG, <span class="string">"onCreateLoader()"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EarthquakeLoader(<span class="keyword">this</span>, REQUEST_URL);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadFinished</span><span class="params">(android.content.Loader&lt;List&lt;Info&gt;&gt; loader, List&lt;Info&gt; infos)</span> </span>&#123;</div><div class="line">        Log.i(TAG_LOG, <span class="string">"onLoadFinished()"</span>);</div><div class="line">        adapter.clear(); <span class="comment">/* 如果存在 &#123;@link Earthquake&#125; 的有效列表，则将其添加到适配器的 数据集。这将触发 ListView 执行更新。 add与addALL的区别在于add方法即便加入一个list也只是保存其中一条，addAll 保存全部*/</span></div><div class="line">        <span class="keyword">if</span> (infos != <span class="keyword">null</span> &amp;&amp; !infos.isEmpty()) adapter.addAll(infos);</div><div class="line">        View loading_progress_Bar = findViewById(R.id.loading_progressbar);</div><div class="line">        loading_progress_Bar.setVisibility(View.GONE);</div><div class="line">        emptyTextView.setText(<span class="string">"no Text"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoaderReset</span><span class="params">(android.content.Loader&lt;List&lt;Info&gt;&gt; loader)</span> </span>&#123;</div><div class="line">        Log.i(TAG_LOG, <span class="string">"onLoaderReset()"</span>);</div><div class="line">        adapter.clear();</div><div class="line">    &#125; <span class="comment">/*创建一个AsyncTask的内部类*/</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EarthAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Void</span>, <span class="title">List</span>&lt;<span class="title">Info</span>&gt;&gt; </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> List&lt;Info&gt; <span class="title">doInBackground</span><span class="params">(String... urls)</span> </span>&#123;</div><div class="line">            Log.i(TAG_LOG, <span class="string">"doInBackground()"</span>);</div><div class="line">            <span class="keyword">if</span> (urls.length &lt; <span class="number">1</span> || urls[<span class="number">0</span>] == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            List&lt;Info&gt; result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Log.i(TAG_LOG, <span class="string">"调用doInBackground+fetchEarthquakeDatas"</span>);</div><div class="line">                result = QueryUtils.fetchEarthquakeDatas(urls[<span class="number">0</span>]);</div><div class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(List&lt;Info&gt; result)</span> </span>&#123; <span class="comment">/* 清除之前地震数据的适配器*/</span></div><div class="line">            Log.i(TAG_LOG, <span class="string">"onPostExecute()"</span>);</div><div class="line">            adapter.clear(); <span class="comment">/* 如果存在 &#123;@link Earthquake&#125; 的有效列表，则将其添加到适配器的 数据集。这将触发 ListView 执行更新。 add与addALL的区别在于add方法即便加入一个list也只是保存其中一条，addAll 保存全部*/</span></div><div class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span> &amp;&amp; !result.isEmpty()) adapter.addAll(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>总结：花了一下午时间去整理，后面的内容可能不是很详细，但是这种概念的东西，大家都可以的百度的到，还有有些代码都做了相关的注释，一些 UI 上的东西，跟本篇讲的可能关系不大，主要是处理应用的交互性，比如：判断是否联网，当没有联网的情况下提示文本，还有在进行网络访问的时候，添加一个进度条提示，应用正在处理。希望能给大家带来帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上一篇 &lt;a href=&quot;&quot;&gt;JSON学习&lt;/a&gt; 中介绍了 JSON 对象的结构，如何解析 JSON 数据，但是我们的 JSON 数据是本地已经转换的 String 类型，现在我们处理网上的 JSON 数据,用到了网上的操作，必然要进行网络的连接，讲到网络部分，有必然使用到多线程，所以本篇侧重于介绍多线程部分。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
      <category term="多线程" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JSON学习</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/05/01/JSON%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/05/01/JSON学习/</id>
    <published>2017-05-01T12:49:25.000Z</published>
    <updated>2017-10-11T03:35:27.133Z</updated>
    
    <content type="html"><![CDATA[<p>&gt;<br>有关的知识点可能过于简单，但是又不得不去写，想要养成写博客的习惯，不仅仅是对自己知识的总结，也是对耐力的磨练，虽然目前学的东西很浅，但是随着以后的深入不断去补充相关的知识，使自己的文章更加精炼。</p><a id="more"></a><p> 最近在做一个网络请求的demo，用到了JSON，做一次总结。</p><h4 id="一、JSON基础知识点？"><a href="#一、JSON基础知识点？" class="headerlink" title="一、JSON基础知识点？"></a>一、JSON基础知识点？</h4><p>JSON是一种取代XML的数据结构,和xml相比,它更小巧但描述能力却不差,由于它的小巧所以网络传输数据将减少更多流量从而加快速度。</p><p>JSON就是一串字符串 只不过元素会使用特定的符号标注。</p><p>{} 双括号表示对象</p><p>[] 中括号表示数组</p><p>“ “ 双引号内是属性或值</p><p>: 冒号表示后者是前者的值(这个值可以是字符串、数字、也可以是另一个数组或对象)</p><h4 id="二、Json解析"><a href="#二、Json解析" class="headerlink" title="二、Json解析"></a>二、Json解析</h4><p><img src="http://upload-images.jianshu.io/upload_images/2556431-674bd3a57c73d160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如图"></p><p>第一个 “size” 键的值为 9.5，由此可以判断出 该值属于数值类型，因为值周围没有引号。<br>第二个 “wide” 键的值为 true，不带引号。这 表示该值属于布尔值。如果数字周围有引号，则表示其为字符串。也就是我们在第三个键值对中找到的字符串。<br>第三个 “country-of-origin”键的值为 “usa”。<br>第四个键是 “style”，其值表示为对象，因为两侧有大括号。</p><p>在 style 对象内部，我们可以找到两个嵌套键/值对：一个为 catergories，一个为color。其实 catergories 的值是一个数组，“boot” 和 “winklepicker”被包含在中括号内组成一个数组。 按照这种方式，通过使用对象和数组，可以嵌套几组值， 随后便可在这些容器中放入不同的数据类型。</p><p>如果我们请求的数据很多比如这个<a href="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson" target="_blank" rel="external">URL</a>;<br>我们就需要JSON整理格式化，推荐一个格式<a href="https://jsonformatter.curiousconcept.com/" target="_blank" rel="external">网站</a></p><h4 id="三、如何获取JSON中的数据"><a href="#三、如何获取JSON中的数据" class="headerlink" title="三、如何获取JSON中的数据"></a>三、如何获取JSON中的数据</h4><p>通过这个demo，先说明一下这个demo是在给定的 JSON ,下面的String中就是我们<br>需要解析的<a href="https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_week.geojson" target="_blank" rel="external">JSON</a><br>通过上面给的JSON格式工具，我们做一些操作取出 “features”对象中的一些值。<br>便于理解贴一张图吧</p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-2866cd457882f5e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="需要的数据"></p><blockquote><p> 下面的代码只是贴出必要的数据，方便需要运行看效果的同学直接拿来用</p></blockquote><h5 id="demo："><a href="#demo：" class="headerlink" title="demo："></a>demo：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SAMPLE_JSON_RESPONSE = <span class="string">"&#123;\"type\":\"FeatureCollection\",\"metadata\":&#123;\"generated\":1462295443000,\"url\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&amp;starttime=2016-01-01&amp;endtime=2016-01-31&amp;minmag=6&amp;limit=10\",\"title\":\"USGS Earthquakes\",\"status\":200,\"api\":\"1.5.2\",\"limit\":10,\"offset\":1,\"count\":10&#125;,\"features\":[&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":7.2,\"place\":\"88km N of Yelizovo, Russia\",\"time\":1454124312220,\"updated\":1460674294040,\"tz\":720,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us20004vvx\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us20004vvx&amp;format=geojson\",\"felt\":2,\"cdi\":3.4,\"mmi\":5.82,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":798,\"net\":\"us\",\"code\":\"20004vvx\",\"ids\":\",at00o1qxho,pt16030050,us20004vvx,gcmt20160130032510,\",\"sources\":\",at,pt,us,gcmt,\",\"types\":\",cap,dyfi,finite-fault,general-link,general-text,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":0.958,\"rms\":1.19,\"gap\":17,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 7.2 - 88km N of Yelizovo, Russia\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[158.5463,53.9776,177]&#125;,\"id\":\"us20004vvx\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.19,\"place\":\"84km SSE of Taron, Papua New Guinea\",\"time\":1453777820750,\"updated\":1460156775040,\"tz\":600,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us20004uks\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us20004uks&amp;format=geojson\",\"felt\":null,\"cdi\":null,\"mmi\":4.1,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":572,\"net\":\"us\",\"code\":\"20004uks\",\"ids\":\",us20004uks,gcmt20160126031023,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,geoserve,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":1.537,\"rms\":0.74,\"gap\":25,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.1 - 94km SSE of Taron, Papua New Guinea\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[153.2454,-5.2952,26]&#125;,\"id\":\"us20004uks\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.3,\"place\":\"50km NNE of Al Hoceima, Morocco\",\"time\":1453695722730,\"updated\":1460156773040,\"tz\":0,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004gy9\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004gy9&amp;format=geojson\",\"felt\":117,\"cdi\":7.2,\"mmi\":5.28,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":695,\"net\":\"us\",\"code\":\"10004gy9\",\"ids\":\",us10004gy9,gcmt20160125042203,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":2.201,\"rms\":0.92,\"gap\":20,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.3 - 50km NNE of Al Hoceima, Morocco\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-3.6818,35.6493,12]&#125;,\"id\":\"us10004gy9\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":7.1,\"place\":\"86km E of Old Iliamna, Alaska\",\"time\":1453631430230,\"updated\":1460156770040,\"tz\":-540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004gqp\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004gqp&amp;format=geojson\",\"felt\":1816,\"cdi\":7.2,\"mmi\":6.6,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":1496,\"net\":\"us\",\"code\":\"10004gqp\",\"ids\":\",at00o1gd6r,us10004gqp,ak12496371,gcmt20160124103030,\",\"sources\":\",at,us,ak,gcmt,\",\"types\":\",cap,dyfi,finite-fault,general-link,general-text,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,trump-origin,\",\"nst\":null,\"dmin\":0.72,\"rms\":2.11,\"gap\":19,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 7.1 - 86km E of Old Iliamna, Alaska\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-153.4051,59.6363,129]&#125;,\"id\":\"us10004gqp\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.6,\"place\":\"215km SW of Tomatlan, Mexico\",\"time\":1453399617650,\"updated\":1459963829040,\"tz\":-420,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004g4l\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004g4l&amp;format=geojson\",\"felt\":11,\"cdi\":2.7,\"mmi\":3.92,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":673,\"net\":\"us\",\"code\":\"10004g4l\",\"ids\":\",at00o1bebo,pt16021050,us10004g4l,gcmt20160121180659,\",\"sources\":\",at,pt,us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":2.413,\"rms\":0.98,\"gap\":74,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.6 - 215km SW of Tomatlan, Mexico\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-106.9337,18.8239,10]&#125;,\"id\":\"us10004g4l\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.74,\"place\":\"52km SE of Shizunai, Japan\",\"time\":1452741933640,\"updated\":1459304879040,\"tz\":540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004ebx\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004ebx&amp;format=geojson\",\"felt\":51,\"cdi\":5.8,\"mmi\":6.45,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":720,\"net\":\"us\",\"code\":\"10004ebx\",\"ids\":\",us10004ebx,pt16014050,at00o0xauk,gcmt20160114032534,\",\"sources\":\",us,pt,at,gcmt,\",\"types\":\",associate,cap,dyfi,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,\",\"nst\":null,\"dmin\":0.281,\"rms\":0.98,\"gap\":22,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.7 - 52km SE of Shizunai, Japan\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[142.781,41.9723,46]&#125;,\"id\":\"us10004ebx\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.1,\"place\":\"12km WNW of Charagua, Bolivia\",\"time\":1452741928270,\"updated\":1459304879040,\"tz\":-240,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004ebw\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004ebw&amp;format=geojson\",\"felt\":3,\"cdi\":2.2,\"mmi\":2.21,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":573,\"net\":\"us\",\"code\":\"10004ebw\",\"ids\":\",us10004ebw,gcmt20160114032528,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":5.492,\"rms\":1.04,\"gap\":16,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.1 - 12km WNW of Charagua, Bolivia\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-63.3288,-19.7597,582.56]&#125;,\"id\":\"us10004ebw\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.23,\"place\":\"74km NW of Rumoi, Japan\",\"time\":1452532083920,\"updated\":1459304875040,\"tz\":540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004djn\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004djn&amp;format=geojson\",\"felt\":8,\"cdi\":3.4,\"mmi\":3.74,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":594,\"net\":\"us\",\"code\":\"10004djn\",\"ids\":\",us10004djn,gcmt20160111170803,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":1.139,\"rms\":0.96,\"gap\":33,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.2 - 74km NW of Rumoi, Japan\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[141.0867,44.4761,238.81]&#125;,\"id\":\"us10004djn\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.5,\"place\":\"227km SE of Sarangani, Philippines\",\"time\":1452530285900,\"updated\":1459304874040,\"tz\":480,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004dj5\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004dj5&amp;format=geojson\",\"felt\":1,\"cdi\":2.7,\"mmi\":7.5,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":1,\"sig\":650,\"net\":\"us\",\"code\":\"10004dj5\",\"ids\":\",at00o0srjp,pt16011050,us10004dj5,gcmt20160111163807,\",\"sources\":\",at,pt,us,gcmt,\",\"types\":\",cap,dyfi,geoserve,impact-link,impact-text,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,tectonic-summary,\",\"nst\":null,\"dmin\":3.144,\"rms\":0.72,\"gap\":22,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.5 - 227km SE of Sarangani, Philippines\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[126.8621,3.8965,13]&#125;,\"id\":\"us10004dj5\"&#125;,\n"</span> +</div><div class="line">            <span class="string">"&#123;\"type\":\"Feature\",\"properties\":&#123;\"mag\":6.55,\"place\":\"Pacific-Antarctic Ridge\",\"time\":1451986454620,\"updated\":1459202978040,\"tz\":-540,\"url\":\"http://earthquake.usgs.gov/earthquakes/eventpage/us10004bgk\",\"detail\":\"http://earthquake.usgs.gov/fdsnws/event/1/query?eventid=us10004bgk&amp;format=geojson\",\"felt\":0,\"cdi\":1,\"mmi\":0,\"alert\":\"green\",\"status\":\"reviewed\",\"tsunami\":0,\"sig\":554,\"net\":\"us\",\"code\":\"10004bgk\",\"ids\":\",us10004bgk,gcmt20160105093415,\",\"sources\":\",us,gcmt,\",\"types\":\",cap,dyfi,geoserve,losspager,moment-tensor,nearby-cities,origin,phase-data,shakemap,\",\"nst\":null,\"dmin\":30.75,\"rms\":0.67,\"gap\":71,\"magType\":\"mww\",\"type\":\"earthquake\",\"title\":\"M 6.0 - Pacific-Antarctic Ridge\"&#125;,\"geometry\":&#123;\"type\":\"Point\",\"coordinates\":[-136.2603,-54.2906,10]&#125;,\"id\":\"us10004bgk\"&#125;],\"bbox\":[-153.4051,-54.2906,10,158.5463,59.6363,582.56]&#125;"</span>;</div><div class="line"></div><div class="line">           <span class="comment">//创建一个JSON对象，并传入JSON格式的数据</span></div><div class="line">            JSONObject  root = <span class="keyword">new</span> JSONObject(SAMPLE_JSON_RESPONSE);</div><div class="line">            <span class="comment">//获取数组对象“features” 从图中可以看出“features”后面是中括号</span></div><div class="line">            JSONArray featureArray=root.getJSONArray(<span class="string">"features"</span>);</div><div class="line">            <span class="comment">//这个循环只是获取每个数组中相同的对象</span></div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;featureArray.length();i++)&#123;</div><div class="line">                    <span class="comment">//获取第 i 个数组中的数据</span></div><div class="line">                    JSONObject earthquake= featureArray.getJSONObject(i);</div><div class="line">                    <span class="comment">//获取该对象中的“properties”JSON对象</span></div><div class="line">                    JSONObject properties=earthquake.getJSONObject(<span class="string">"properties"</span>);</div><div class="line">                    <span class="comment">//获取键为“mag”的值</span></div><div class="line">                    Double mag= properties.getDouble(<span class="string">"mag"</span>);</div><div class="line">                    <span class="comment">//获取键为“place”的值</span></div><div class="line">                     String place= properties.getString(<span class="string">"place"</span>);</div><div class="line">                    <span class="comment">//获取键为“time”的值</span></div><div class="line">                    Long time= Long.valueOf(properties.getString(<span class="string">"time"</span>));</div></pre></td></tr></table></figure><p>上面获取出来的值可有用 log 或者 Toast 显示出来</p><h4 id="四、JSON-数据中时间格式的转换"><a href="#四、JSON-数据中时间格式的转换" class="headerlink" title="四、JSON 数据中时间格式的转换"></a>四、JSON 数据中时间格式的转换</h4><p>可以看出来 JSON 中 “time” 键值为毫秒数，我们便于观看需要转换为我们熟悉的格式,所以我们用到了 <strong>SimpleDateFormat</strong>类，基本格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//引号中的格式参照下图</div><div class="line">SimpleDateFormat dateFormat=new SimpleDateFormat (&quot;yyyy-MM-dd&quot;);</div><div class="line">Date date=new Date(time);  //time为获取到的毫秒数</div><div class="line">String showDate=dateFormat.format(date);</div><div class="line">//用 log 或者 Toast 显示出来</div></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/mw690/006rAlqhly1ff64pmr2d6j30mf0lkabi.jpg" alt=""></p><p>如果要处理数值的格式我们用<strong>DecimalFormat</strong>类，用法很简单，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//“0”表示站位，下面的意思表示只保留一位小数</span></div><div class="line"><span class="comment">//当然我们可以使用Math类也能达到保留一位小数</span></div><div class="line"> DecimalFormat decimalFormat=<span class="keyword">new</span> DecimalFormat(<span class="string">"0.0"</span>);</div></pre></td></tr></table></figure></p><p>更详细的可以查看 <a href="http://developer.android.youdaxue.com/reference/java/text/DecimalFormat.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition" target="_blank" rel="external">DecimalFormat 格式方法</a>)，里面也有格式图，方便理解；</p><h4 id="五、字符串的操控"><a href="#五、字符串的操控" class="headerlink" title="五、字符串的操控"></a>五、字符串的操控</h4><p>你也可以参阅文档中的<a href="http://developer.android.youdaxue.com/reference/java/lang/CharSequence.html" target="_blank" rel="external">CharSequence</a>。CharSequence 是一组字符，字符串是一种更具体的 CharSequence （String 类是 CharSequence 类的 扩展类）。如果某个方法要求使用 CharSequence 作为输入，你可以 传递一个字符串。 以下是一些可以在 String 对象上调用的其他方法：<br><a href="http://developer.android.youdaxue.com/reference/java/lang/String.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#length(" target="_blank" rel="external">length()</a>) - 返回字符串中的 字符数<br><a href="http://developer.android.youdaxue.com/reference/java/lang/String.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#contains(java.lang.CharSequence" target="_blank" rel="external">contains(CharSequence cs)</a>) - 根据 原始字符串中是否包含输入 CharSequence （或输入 String）返回 true 或 false<br><a href="http://developer.android.youdaxue.com/reference/java/lang/String.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#indexOf(java.lang.String" target="_blank" rel="external">indexOf(String string)</a>) - 返回输入 String 首次在原始 String 中出现的位置的索引，如果 原始 String 中不存在输入 String，则返回 -1<br><a href="http://developer.android.youdaxue.com/reference/java/lang/String.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#split(java.lang.String" target="_blank" rel="external">split(String string)</a>) - 根据输入 String 中 指定的位置对原始 String 进行拆分， 并返回包含拆分后 String 部分的数组。<br><a href="http://developer.android.youdaxue.com/reference/java/lang/String.html?utm_source=udacity&amp;utm_medium=course&amp;utm_campaign=android_basics#substring(int,%20int" target="_blank" rel="external">substring(int start, int end)</a>) - 返回 一个新的 String，该 String 为从开始索引到结束索引 之间的内容（包括开始索引但不包括结束索引）。</p><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><p>demo 中，我们需要拆分“place” 中的数据，其中以“of”为划分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">TextView mLocation= (TextView) listItem.findViewById(R.id.location_tv);</div><div class="line"><span class="comment">//说明一下mData.getLocation()是adpater中获取的具体的“place”数据</span></div><div class="line">  String show=<span class="keyword">null</span>;</div><div class="line">        <span class="comment">//获取出现“of”的索引值</span></div><div class="line">        <span class="keyword">int</span> indexOf=mData.getLocation().indexOf(<span class="string">"of"</span>);</div><div class="line">      <span class="comment">//如果数据包含“of”</span></div><div class="line">        <span class="keyword">if</span>(mData.getLocation().contains(<span class="string">"of"</span>))&#123;</div><div class="line">             <span class="comment">//从0索引开始到of之后得到索引结束取出之间的值</span></div><div class="line">             show=mData.getLocation().substring(<span class="number">0</span>,indexOf+<span class="number">2</span>);</div><div class="line"></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            show=<span class="string">"near the"</span>;</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//设置显示的文本</span></div><div class="line">        mLocation.setText(show);</div></pre></td></tr></table></figure><blockquote><p>更多的操作需要具体要求修改，答案不唯一，有兴趣可以把其他的几个方法的尝试一下</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;gt;&lt;br&gt;有关的知识点可能过于简单，但是又不得不去写，想要养成写博客的习惯，不仅仅是对自己知识的总结，也是对耐力的磨练，虽然目前学的东西很浅，但是随着以后的深入不断去补充相关的知识，使自己的文章更加精炼。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>总有你要的编程书单(GitHub)</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/04/18/%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95(GitHub)/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/04/18/总有你要的编程书单(GitHub)/</id>
    <published>2017-04-18T13:12:08.000Z</published>
    <updated>2017-09-29T08:14:15.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><a id="more"></a><ul><li><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="external">IntelliJ IDEA 简体中文专题教程</a></li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><a href="http://www.cnblogs.com/mr-wid/archive/2013/05/09/3068229.html" target="_blank" rel="external">21分钟MySQL入门教程</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></li></ul><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ul><li><a href="http://disquebook.com" target="_blank" rel="external">Disque 使用教程</a></li><li><a href="http://neo4j.tw" target="_blank" rel="external">Neo4j .rb 中文資源</a></li><li><a href="http://redisdoc.com" target="_blank" rel="external">Redis 命令参考</a></li><li><a href="http://redisbook.com" target="_blank" rel="external">Redis 设计与实现</a></li><li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md" target="_blank" rel="external">The Little MongoDB Book</a></li><li><a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md" target="_blank" rel="external">The Little Redis Book</a></li><li><a href="https://github.com/huangz1990/annotated_redis_source" target="_blank" rel="external">带有详细注释的 Redis 2.6 代码</a></li><li><a href="https://github.com/huangz1990/redis-3.0-annotated" target="_blank" rel="external">带有详细注释的 Redis 3.0 代码</a></li></ul><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><ul><li><a href="http://works.jinbuguo.com/postgresql/menu823/index.html" target="_blank" rel="external">PostgreSQL 8.2.3 中文文档</a></li><li><a href="http://www.postgres.cn/docs/9.3/index.html" target="_blank" rel="external">PostgreSQL 9.3.1 中文文档</a></li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><ul><li><a href="https://www.gitbook.com/book/juntao/3-web-designs-in-3-weeks/details" target="_blank" rel="external">3 Web Designs in 3 Weeks</a></li><li><a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools" target="_blank" rel="external">Chrome 开发者工具中文手册</a></li><li><a href="http://open.chrome.360.cn/extension_dev/overview.html" target="_blank" rel="external">Chrome扩展开发文档</a></li><li><a href="https://github.com/phodal/growth-ebook" target="_blank" rel="external">Growth: 全栈增长工程师指南</a></li><li><a href="http://www.gruntjs.net" target="_blank" rel="external">Grunt中文文档</a></li><li><a href="https://github.com/nimojs/gulp-book" target="_blank" rel="external">Gulp 入门指南</a></li><li><a href="http://www.gulpjs.com.cn/docs/" target="_blank" rel="external">gulp中文文档</a></li><li><a href="https://github.com/bolasblack/http-api-guide" target="_blank" rel="external">HTTP 接口设计指北</a></li><li><a href="http://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1" target="_blank" rel="external">HTTP/2.0 中文翻译</a></li><li><a href="https://www.gitbook.com/book/ye11ow/http2-explained/details" target="_blank" rel="external">http2讲解</a></li><li><a href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md" target="_blank" rel="external">JSON风格指南</a></li><li><a href="http://man.lupaworld.com/content/network/wireshark/index.html" target="_blank" rel="external">Wireshark用户手册</a></li><li><a href="https://community.emc.com/thread/194901" target="_blank" rel="external">一站式学习Wireshark</a></li><li><a href="http://www.20thingsilearned.com/zh-CN/home" target="_blank" rel="external">关于浏览器和网络的 20 项须知</a></li><li><a href="http://coderlmn.github.io/code-standards/" target="_blank" rel="external">前端代码规范 及 最佳实践</a></li><li><a href="https://github.com/fouber/blog/issues/2" target="_blank" rel="external">前端开发体系建设日记</a></li><li><a href="https://github.com/hacke2/hacke2.github.io/issues/1" target="_blank" rel="external">前端资源分享（一）</a></li><li><a href="https://github.com/hacke2/hacke2.github.io/issues/3" target="_blank" rel="external">前端资源分享（二）</a></li><li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></li><li><a href="http://jinlong.github.io/2013/08/29/devtoolsecrets/" target="_blank" rel="external">浏览器开发工具的秘密</a></li><li><a href="https://github.com/AlloyTeam/Mars" target="_blank" rel="external">移动Web前端知识库</a></li><li><a href="https://github.com/hoosin/mobile-web-favorites" target="_blank" rel="external">移动前端开发收藏夹</a></li></ul><h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><ul><li><a href="http://works.jinbuguo.com/apache/menu22/index.html" target="_blank" rel="external">Apache 中文手册</a></li><li><a href="http://tengine.taobao.org/book/index.html" target="_blank" rel="external">Nginx开发从入门到精通</a> (淘宝团队出品)</li><li><a href="http://www.ttlsa.com/nginx/nginx-stu-pdf/" target="_blank" rel="external">Nginx教程从入门到精通</a> (PDF版本，运维生存时间出品)</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><a href="https://softwaredownload.gitbooks.io/openwrt-fanqiang/content/" target="_blank" rel="external">OpenWrt智能、自动、透明翻墙路由器教程</a></li><li><a href="https://community.emc.com/docs/DOC-16067" target="_blank" rel="external">SAN 管理入门系列</a></li><li><a href="http://sketchcn.com/sketch-chinese-user-manual.html#introduce" target="_blank" rel="external">Sketch 中文手册</a></li><li><a href="http://ifeve.com/perfbook/" target="_blank" rel="external">深入理解并行编程</a></li></ul><h3 id="函数式概念"><a href="#函数式概念" class="headerlink" title="函数式概念"></a>函数式概念</h3><ul><li><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="external">傻瓜函数编程</a></li></ul><h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><ul><li><a href="http://dcaoyuan.github.io/papers/pdfs/Scalability.pdf" target="_blank" rel="external">走向分布式</a> (PDF)</li></ul><h3 id="在线教育"><a href="#在线教育" class="headerlink" title="在线教育"></a>在线教育</h3><ul><li><a href="http://edu.51cto.com" target="_blank" rel="external">51CTO学院</a></li><li><a href="https://www.codecademy.com/?locale_code=zh" target="_blank" rel="external">Codecademy</a></li><li><a href="https://www.codeschool.com" target="_blank" rel="external">CodeSchool</a></li><li><a href="https://www.coursera.org/courses?orderby=upcoming&amp;lngs=zh" target="_blank" rel="external">Coursera</a></li><li><a href="https://learnxinyminutes.com" target="_blank" rel="external">Learn X in Y minutes</a> (数十种语言快速入门教程)</li><li><a href="https://www.shiyanlou.com" target="_blank" rel="external">shiyanlou</a></li><li><a href="https://teamtreehouse.com" target="_blank" rel="external">TeamTreeHouse</a></li><li><a href="https://www.udacity.com" target="_blank" rel="external">Udacity</a></li><li><a href="https://www.xuetangx.com" target="_blank" rel="external">xuetangX</a></li><li><a href="http://www.imooc.com/course/list" target="_blank" rel="external">慕课网</a> (丰富的移动端开发、php开发、web前端、html5教程以及css3视频教程等课程资源)</li><li><a href="http://www.jikexueyuan.com" target="_blank" rel="external">极客学院</a></li><li><a href="http://www.hubwiz.com" target="_blank" rel="external">汇智网</a></li><li><a href="http://www.jisuanke.com" target="_blank" rel="external">计蒜客</a></li></ul><h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul><li><a href="https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/" target="_blank" rel="external">Spark 编程指南简体中文版</a></li><li><a href="https://code.csdn.net/CODE_Translation/spark_matei_phd" target="_blank" rel="external">大型集群上的快速和通用数据处理架构</a></li><li><a href="https://github.com/Flowerowl/Big-Data-Resources" target="_blank" rel="external">大数据/数据挖掘/推荐系统/机器学习相关资源</a></li><li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="external">数据挖掘中经典的算法实现和详细的注释</a></li><li><a href="http://dataminingguide.books.yourtion.com" target="_blank" rel="external">面向程序员的数据挖掘指南</a></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li><a href="http://man.chinaunix.net/linux/debian/reference/reference.zh-cn.html" target="_blank" rel="external">Debian 参考手册 </a></li><li><a href="https://github.com/yeasy/docker_practice" target="_blank" rel="external">Docker —— 从入门到实践</a></li><li><a href="https://github.com/widuu/chinese_docker" target="_blank" rel="external">Docker中文指南</a></li><li><a href="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1" target="_blank" rel="external">Docker入门实战</a></li><li><a href="http://www.freebsd.org/doc/zh_CN.UTF-8/books/handbook/" target="_blank" rel="external">FreeBSD 使用手册</a></li><li><a href="http://freeradius.akagi201.org" target="_blank" rel="external">FreeRADIUS新手入门</a></li><li><a href="https://tinylab.gitbooks.io/linux-doc/content/zh-cn/" target="_blank" rel="external">Linux Documentation (中文版)</a></li><li><a href="http://happypeter.github.io/LGCB/book/" target="_blank" rel="external">Linux Guide for Complete Beginners</a></li><li><a href="http://works.jinbuguo.com/lfs/lfs62/index.html" target="_blank" rel="external">Linux 构建指南</a></li><li><a href="http://sourceforge.net/projects/elpi/" target="_blank" rel="external">Linux 系统高级编程</a></li><li><a href="https://github.com/me115/linuxtools_rst" target="_blank" rel="external">Linux工具快速教程</a></li><li><a href="https://aaaaaashu.gitbooks.io/mac-dev-setup/content/" target="_blank" rel="external">Mac 开发配置手册</a></li><li><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="external">Operating Systems: Three Easy Pieces</a></li><li><a href="http://billie66.github.io/TLCL/index.html" target="_blank" rel="external">The Linux Command Line</a> (中英文版)</li><li><a href="http://wiki.ubuntu.org.cn/UbuntuManual" target="_blank" rel="external">Ubuntu 参考手册 </a></li><li><a href="https://www.gitbook.com/book/objectkuan/ucore-docs/details" target="_blank" rel="external">uCore Lab: Operating System Course in Tsinghua University</a></li><li><a href="http://cb.vu/unixtoolbox_zh_CN.xhtml" target="_blank" rel="external">UNIX TOOLBOX</a></li><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="external">命令行的艺术</a></li><li><a href="https://tinylab.gitbooks.io/elinux/content/zh/" target="_blank" rel="external">嵌入式 Linux 知识库 (eLinux.org 中文版)</a></li><li><a href="http://i.linuxtoy.org/docs/guide/index.html" target="_blank" rel="external">开源世界旅行手册</a></li><li><a href="https://github.com/tobegit3hub/understand_linux_process" target="_blank" rel="external">理解Linux进程</a></li><li><a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" target="_blank" rel="external">鸟哥的 Linux 私房菜 基础学习篇</a></li><li><a href="http://cn.linux.vbird.org/linux_server/" target="_blank" rel="external">鸟哥的 Linux 私房菜 服务器架设篇</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="http://redisbook.com" target="_blank" rel="external">Redis 设计与实现</a></li><li><a href="https://github.com/justinyhuang/the-little-mongodb-book-cn" target="_blank" rel="external">The Little MongoDB Book 中文版</a></li></ul><h3 id="智能系统"><a href="#智能系统" class="headerlink" title="智能系统"></a>智能系统</h3><ul><li><a href="https://github.com/phodal/designiot" target="_blank" rel="external">一步步搭建物联网系统</a></li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式30分钟入门教程</a></li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li><a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">Git - 简易指南</a></li><li><a href="https://github.com/flyhigher139/Git-Cheat-Sheet" target="_blank" rel="external">Git-Cheat-Sheet</a> （感谢 @flyhigher139 翻译了中文版）</li><li><a href="http://gitbook.liuhui998.com" target="_blank" rel="external">Git Community Book 中文版</a></li><li><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">git-flow 备忘清单</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git magic</a></li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/" target="_blank" rel="external">Git Magic</a></li><li><a href="http://gitref.justjavac.com" target="_blank" rel="external">Git 参考手册</a></li><li><a href="https://github.com/waylau/github-help" target="_blank" rel="external">Github帮助文档</a></li><li><a href="https://snowdream86.gitbooks.io/github-cheat-sheet/content/zh/" target="_blank" rel="external">GitHub秘籍</a></li><li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a> （本文由 <a href="http://weibo.com/liaoxuefeng" target="_blank" rel="external">@廖雪峰</a> 创作，如果觉得本教程对您有帮助，可以去 <a href="https://itunes.apple.com/cn/app/git-jiao-cheng/id876420437" target="_blank" rel="external">iTunes</a> 购买）</li><li><a href="https://github.com/gotgit/gotgithub" target="_blank" rel="external">Got GitHub</a></li><li><a href="http://www.worldhello.net/gotgithub/index.html" target="_blank" rel="external">GotGitHub</a></li><li><a href="https://zh-hginit.readthedocs.io/en/latest/" target="_blank" rel="external">HgInit (中文版)</a></li><li><a href="https://www.mercurial-scm.org/wiki/ChineseTutorial" target="_blank" rel="external">Mercurial 使用教程</a></li><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">Pro Git</a></li><li><a href="https://www.gitbook.com/book/0532/progit/details" target="_blank" rel="external">Pro Git 中文版</a> (整理在gitbook上)</li><li><a href="http://svnbook.red-bean.com/nightly/zh/index.html" target="_blank" rel="external">svn 手册</a></li><li><a href="http://pcottle.github.io/learnGitBranching/" target="_blank" rel="external">学习 Git 分支</a> (点击右下角按钮可切换至简体及正体中文)</li><li><a href="http://igit.linuxtoy.org/index.html" target="_blank" rel="external">沉浸式学 Git</a></li><li><a href="http://backlogtool.com/git-guide/cn/" target="_blank" rel="external">猴子都能懂的GIT入门</a></li></ul><h3 id="程序员杂谈"><a href="#程序员杂谈" class="headerlink" title="程序员杂谈"></a>程序员杂谈</h3><ul><li><a href="http://www.kancloud.cn/kancloud/a-programmer-prepares" target="_blank" rel="external">程序员的自我修养</a></li></ul><h3 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h3><ul><li><a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" target="_blank" rel="external">ElasticSearch 权威指南</a></li><li><a href="http://es.xiaoleilu.com" target="_blank" rel="external">Elasticsearch 权威指南（中文版）</a></li><li><a href="http://kibana.logstash.es" target="_blank" rel="external">ELKstack 中文指南</a></li><li><a href="https://github.com/chenryn/logstash-best-practice-cn" target="_blank" rel="external">Logstash 最佳实践</a></li><li><a href="http://udn.yyuap.com/doc/mastering-elasticsearch/" target="_blank" rel="external">Mastering Elasticsearch(中文版)</a></li><li><a href="https://www.gitbook.com/book/wizardforcel/puppet-27-cookbook/details" target="_blank" rel="external">Puppet 2.7 Cookbook 中文版</a></li></ul><h3 id="编程艺术"><a href="#编程艺术" class="headerlink" title="编程艺术"></a>编程艺术</h3><ul><li><a href="http://read.douban.com/ebook/4972883/" target="_blank" rel="external">取悦的工序：如何理解游戏</a> (豆瓣阅读，免费书籍)</li><li><a href="http://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1?print" target="_blank" rel="external">每个程序员都应该了解的内存知识(译)</a>【第一部分】</li><li><a href="https://github.com/julycoding/The-Art-Of-Programming-by-July" target="_blank" rel="external">程序员编程艺术</a></li><li><a href="http://www.kancloud.cn/kancloud/intro-to-prog/52592" target="_blank" rel="external">编程入门指南</a></li></ul><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><ul><li><a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="external">《计算机程序的结构和解释》公开课 翻译项目</a></li></ul><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><a href="http://exvim.github.io/docs-zh/intro/" target="_blank" rel="external">exvim–vim 改良成IDE项目</a></li><li><a href="https://github.com/vimcn/vimcdoc" target="_blank" rel="external">Vim中文文档</a></li><li><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="external">所需即所获：像 IDE 一样使用 vim</a></li><li><a href="http://learnvimscriptthehardway.onefloweroneworld.com" target="_blank" rel="external">笨方法学Vimscript 中译本</a></li></ul><h3 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h3><ul><li><a href="https://github.com/zilongshanren/opengl-tutorials" target="_blank" rel="external">OpenGL 教程</a></li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><a href="http://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="external">史上最全设计模式导学目录</a></li><li><a href="https://github.com/me115/design_patterns" target="_blank" rel="external">图说设计模式</a></li></ul><h3 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h3><ul><li><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="external">傻瓜函数编程</a> (《Functional Programming For The Rest of Us》中文版)</li><li><a href="http://www.infoq.com/cn/minibooks/scrum-xp-from-the-trenches" target="_blank" rel="external">硝烟中的 Scrum 和 XP</a></li></ul><h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3><ul><li><a href="http://docs.huihoo.com/gnu/linux/gmake.html" target="_blank" rel="external">GNU make 指南</a></li><li><a href="https://github.com/waylau/Gradle-2-User-Guide" target="_blank" rel="external">Gradle 2 用户指南</a></li><li><a href="http://yuedu.baidu.com/ebook/f23af265998fcc22bcd10da2" target="_blank" rel="external">Gradle 中文使用文档</a></li><li><a href="http://local.joelonsoftware.com/wiki/Chinese_(Simplified" target="_blank" rel="external">Joel谈软件</a>)</li><li><a href="https://github.com/fool2fish/selenium-doc" target="_blank" rel="external">selenium 中文文档</a></li><li><a href="http://www.ituring.com.cn/book/1143" target="_blank" rel="external">开源软件架构</a></li><li><a href="http://article.yeeyan.org/view/2251/94882" target="_blank" rel="external">持续集成（第二版）</a> (译言网)</li><li><a href="http://local.joelonsoftware.com/wiki/%E9%A6%96%E9%A0%81" target="_blank" rel="external">約耳談軟體(Joel on Software)</a></li><li><a href="https://github.com/ecomfe/spec" target="_blank" rel="external">编码规范</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-ap/" target="_blank" rel="external">让开发自动化系列专栏</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-cq/" target="_blank" rel="external">追求代码质量</a></li></ul><h2 id="语言相关"><a href="#语言相关" class="headerlink" title="语言相关"></a>语言相关</h2><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><a href="http://www.apkbus.com/design/index.html" target="_blank" rel="external">Android Design(中文版)</a></li><li><a href="https://github.com/CharonChui/AndroidNote" target="_blank" rel="external">Android Note(开发过程中积累的知识点)</a></li><li><a href="http://leanote.com/blog/post/561658f938f41126b2000298" target="_blank" rel="external">Android6.0新特性详解</a></li><li><a href="http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external">Android学习之路</a></li><li><a href="https://github.com/bboyfeiyu/android-tech-frontier" target="_blank" rel="external">Android开发技术前线(android-tech-frontier)</a></li><li><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="external">Google Android官方培训课程中文版</a></li><li>Google Material Design 正體中文版 (<a href="https://wcc723.gitbooks.io/google_design_translate/content/style-icons.html" target="_blank" rel="external">译本一</a> <a href="https://github.com/1sters/material_design_zh" target="_blank" rel="external">译本二</a>)</li><li><a href="http://wiki.jikexueyuan.com/project/material-design/" target="_blank" rel="external">Material Design 中文版</a></li><li><a href="https://github.com/FX-Max/Point-of-Android" target="_blank" rel="external">Point-of-Android</a> Android 一些重要知识点解析整理</li></ul><h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3><ul><li><a href="http://awk.readthedocs.org/en/latest/index.html" target="_blank" rel="external">awk中文指南</a></li><li><a href="https://github.com/wuzhouhui/awk" target="_blank" rel="external">awk程序设计语言</a></li></ul><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><ul><li><a href="http://c-faq-chn.sourceforge.net/ccfaq/ccfaq.html" target="_blank" rel="external">C 语言常见问题集</a></li><li><a href="http://doc.lellansin.com" target="_blank" rel="external">C/C++ 学习教程</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/" target="_blank" rel="external">Linux C 编程一站式学习</a></li><li><a href="https://github.com/limingth/NCCL" target="_blank" rel="external">新概念 C 语言教程</a></li></ul><h3 id="C-Sharp"><a href="#C-Sharp" class="headerlink" title="C Sharp"></a>C Sharp</h3><ul><li><a href="http://book.douban.com/subject/24827879/" target="_blank" rel="external">精通C#(第6版) </a></li></ul><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><ul><li><a href="https://github.com/hellogcc/100-gcc-tips/blob/master/src/index.md" target="_blank" rel="external">100个gcc小技巧</a></li><li><a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md" target="_blank" rel="external">100个gdb小技巧</a></li><li><a href="https://tinylab.gitbooks.io/cbook/content/" target="_blank" rel="external">C 语言编程透视</a></li><li><a href="https://github.com/andycai/cprimer" target="_blank" rel="external">C/C++ Primer</a> - @andycai</li><li><a href="http://www.sunistudio.com/cppfaq/" target="_blank" rel="external">C++ FAQ LITE(中文版)</a></li><li><a href="https://github.com/Mooophy/Cpp-Primer" target="_blank" rel="external">C++ Primer 5th Answers</a></li><li><a href="https://github.com/wuye9036/CppTemplateTutorial" target="_blank" rel="external">C++ Template 进阶指南</a></li><li><a href="http://www.prglab.com/cms/" target="_blank" rel="external">C++ 基础教程</a></li><li><a href="https://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/" target="_blank" rel="external">C++ 并发编程(基于C++11)</a></li><li><a href="https://github.com/forhappy/Cplusplus-Concurrency-In-Practice" target="_blank" rel="external">C++ 并发编程指南</a></li><li><a href="https://github.com/leeyiw/cgdb-manual-in-chinese" target="_blank" rel="external">CGDB中文手册</a></li><li><a href="http://sewm.pku.edu.cn/src/paradise/reference/CMake%20Practice.pdf" target="_blank" rel="external">Cmake 实践</a> (PDF)</li><li><a href="http://docs.huihoo.com/gnu/linux/gmake.html" target="_blank" rel="external">GNU make 指南</a></li><li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="external">Google C++ 风格指南</a></li><li><a href="http://www.kuqin.com/qtdocument/tutorial.html" target="_blank" rel="external">QT 教程</a></li><li><a href="https://github.com/anjuke/zguide-cn" target="_blank" rel="external">ZMQ 指南</a></li><li><a href="http://www.ituring.com.cn/book/1203" target="_blank" rel="external">像计算机科学家一样思考（C++版)</a> (《How To Think Like a Computer Scientist: C++ Version》中文版)</li><li><a href="http://www.nowamagic.net/librarys/books/contents/c" target="_blank" rel="external">简单易懂的C魔法</a></li><li><a href="http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf" target="_blank" rel="external">跟我一起写Makefile(PDF)</a> (PDF)</li></ul><h3 id="CoffeeScript"><a href="#CoffeeScript" class="headerlink" title="CoffeeScript"></a>CoffeeScript</h3><ul><li><a href="http://coffee-script.org" target="_blank" rel="external">CoffeeScript 中文</a></li><li><a href="https://github.com/elrrrrrrr/coffeescript-style-guide/blob/master/README-ZH.md" target="_blank" rel="external">CoffeeScript 编程风格指南</a></li></ul><h3 id="Dart"><a href="#Dart" class="headerlink" title="Dart"></a>Dart</h3><ul><li><a href="http://dart.lidian.info/wiki/Language_Tour" target="_blank" rel="external">Dart 语言导览</a></li></ul><h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><ul><li><a href="https://github.com/looly/elasticsearch-definitive-guide-cn" target="_blank" rel="external">Elasticsearch 权威指南</a> （《Elasticsearch the definitive guide》中文版）</li><li><a href="http://kibana.logstash.es" target="_blank" rel="external">ELKstack 中文指南</a></li><li><a href="http://udn.yyuap.com/doc/mastering-elasticsearch/" target="_blank" rel="external">Mastering Elasticsearch(中文版)</a></li></ul><h3 id="Elixir"><a href="#Elixir" class="headerlink" title="Elixir"></a>Elixir</h3><ul><li><a href="https://github.com/Ljzn/ElixrGettingStartedChinese" target="_blank" rel="external">Elixir Getting Started 中文翻译</a></li><li><a href="https://elixirschool.com/cn/" target="_blank" rel="external">Elixir 编程语言教程</a> (Elixir School)</li><li><a href="https://github.com/Ljzn/MetaProgrammingInElixirChinese" target="_blank" rel="external">Elixir元编程与DSL 中文翻译</a></li><li><a href="https://mydearxym.gitbooks.io/phoenix-doc-in-chinese/content/" target="_blank" rel="external">Phoenix 框架中文文档</a></li></ul><h3 id="Erlang"><a href="#Erlang" class="headerlink" title="Erlang"></a>Erlang</h3><ul><li><a href="https://github.com/liancheng/cpie-cn" target="_blank" rel="external">Erlang 并发编程</a> (《Concurrent Programming in Erlang (Part I)》中文版)</li></ul><h3 id="Fortran"><a href="#Fortran" class="headerlink" title="Fortran"></a>Fortran</h3><ul><li><a href="http://micro.ustc.edu.cn/Fortran/ZJDing/" target="_blank" rel="external">Fortran77和90/95编程入门</a></li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><ul><li><a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="external">Go Web 编程</a></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN" target="_blank" rel="external">Go 入门指南</a> (《The Way to Go》中文版)</li><li><a href="https://github.com/golang-china/golangdoc.translations" target="_blank" rel="external">Go 官方文档翻译</a></li><li><a href="https://tour.go-zh.org/list" target="_blank" rel="external">Go 指南</a> (《A Tour of Go》中文版)</li><li><a href="https://github.com/songleo/the-little-go-book_ZH_CN" target="_blank" rel="external">Go 简易教程</a> (《 <a href="https://github.com/karlseguin/the-little-go-book" target="_blank" rel="external">The Little Go Book</a> 》中文版)</li><li><a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="external">Go 编程基础</a></li><li><a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example" target="_blank" rel="external">Go 语言标准库</a></li><li><a href="https://github.com/hyper-carrot/go_command_tutorial" target="_blank" rel="external">Go命令教程</a></li><li><a href="https://github.com/astaxie/Go-in-Action" target="_blank" rel="external">Go实战开发</a></li><li><a href="https://github.com/achun/Go-Blog-In-Action" target="_blank" rel="external">Go语言博客实践</a></li><li><a href="http://blog.csdn.net/dc_726/article/details/46565241" target="_blank" rel="external">Java程序员的Golang入门指南</a></li><li><a href="https://github.com/astaxie/NPWG_zh" target="_blank" rel="external">Network programming with Go 中文翻译版本</a></li><li><a href="http://gorevel.cn/docs/manual/index.html" target="_blank" rel="external">Revel 框架手册</a></li><li><a href="http://mikespook.com/learning-go/" target="_blank" rel="external">学习Go语言</a></li><li><a href="http://go.ctolib.com/docs/read/magical-go-c-index.html" target="_blank" rel="external">神奇的 Go 语言</a></li></ul><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><ul><li><a href="http://www.ibm.com/developerworks/cn/java/j-pg/" target="_blank" rel="external">实战 Groovy 系列</a></li></ul><h3 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h3><ul><li><a href="http://learnyoua.haskell.sg" target="_blank" rel="external">Haskell 趣学指南</a></li><li><a href="http://cnhaskell.com" target="_blank" rel="external">Real World Haskell 中文版</a></li></ul><h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML / CSS"></a>HTML / CSS</h3><ul><li><a href="https://github.com/waylau/css3-tutorial" target="_blank" rel="external">CSS3 Tutorial 《CSS3 教程》</a></li><li><a href="http://css.doyoe.com" target="_blank" rel="external">CSS参考手册</a></li><li><a href="http://yanxyz.github.io/emmet-docs/" target="_blank" rel="external">Emmet 文档</a></li><li><a href="http://www.w3school.com.cn/html5/" target="_blank" rel="external">HTML5 教程</a></li><li><a href="http://codeguide.bootcss.com" target="_blank" rel="external">HTML和CSS编码规范</a></li><li><a href="http://sass-guidelin.es/zh/" target="_blank" rel="external">Sass Guidelines 中文</a></li><li><a href="http://alloyteam.github.io/CodeGuide/" target="_blank" rel="external">前端代码规范</a> (腾讯 AlloyTeam 团队)</li><li><a href="http://zh.learnlayout.com" target="_blank" rel="external">学习CSS布局</a></li><li><a href="https://github.com/chadluo/CSS-Guidelines/blob/master/README.md" target="_blank" rel="external">通用 CSS 笔记、建议与指导</a></li></ul><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul><li><a href="http://nilsun.github.io/apple-watch/" target="_blank" rel="external">Apple Watch开发初探</a></li><li><a href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/" target="_blank" rel="external">Google Objective-C Style Guide 中文版</a></li><li><a href="http://isux.tencent.com/ios-human-interface-guidelines-ui-design-basics-ios7.html" target="_blank" rel="external">iOS7人机界面指南</a></li><li><a href="https://github.com/qinjx/30min_guides/blob/master/ios.md" target="_blank" rel="external">iOS开发60分钟入门</a></li><li><a href="http://wileam.com/iphone-6-screen-cn/" target="_blank" rel="external">iPhone 6 屏幕揭秘</a></li><li><a href="https://github.com/jkyin/Subtitle" target="_blank" rel="external">网易斯坦福大学公开课：iOS 7应用开发字幕文件</a></li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li><a href="https://github.com/waylau/activiti-5.x-user-guide" target="_blank" rel="external">Activiti 5.x 用户指南</a></li><li><a href="https://github.com/waylau/apache-mina-2.x-user-guide" target="_blank" rel="external">Apache MINA 2 用户指南</a></li><li><a href="https://github.com/waylau/apache-shiro-1.2.x-reference" target="_blank" rel="external">Apache Shiro 用户指南</a></li><li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="external">Google Java编程风格指南</a></li><li><a href="https://github.com/waylau/h2-database-doc" target="_blank" rel="external">H2 Database 教程</a></li><li><a href="https://github.com/waylau/servlet-3.1-specification" target="_blank" rel="external">Java Servlet 3.1 规范</a></li><li><a href="https://github.com/waylau/java-code-conventions" target="_blank" rel="external">Java 编码规范</a></li><li><a href="https://github.com/waylau/Jersey-2.x-User-Guide" target="_blank" rel="external">Jersey 2.x 用户指南</a></li><li><a href="https://github.com/waylau/jsse-reference-guide" target="_blank" rel="external">JSSE 参考指南</a></li><li><a href="http://mybatis.github.io/mybatis-3/zh/index.html" target="_blank" rel="external">MyBatis中文文档</a></li><li><a href="https://github.com/waylau/netty-4-user-guide" target="_blank" rel="external">Netty 4.x 用户指南</a></li><li><a href="https://github.com/waylau/essential-netty-in-action" target="_blank" rel="external">Netty 实战(精髓)</a></li><li><a href="https://github.com/waylau/rest-in-action" target="_blank" rel="external">REST 实战</a></li><li><a href="https://github.com/qibaoguang/Spring-Boot-Reference-Guide" target="_blank" rel="external">Spring Boot参考指南</a> (翻译中)</li><li><a href="https://github.com/waylau/spring-framework-4-reference" target="_blank" rel="external">Spring Framework 4.x参考文档</a></li><li><a href="https://github.com/waylau/RestDemo" target="_blank" rel="external">用jersey构建REST服务</a></li></ul><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><ul><li><a href="https://github.com/adamlu/javascript-style-guide" target="_blank" rel="external">Airbnb JavaScript 规范</a></li><li>AngularJS<ul><li><a href="https://github.com/peiransun/angularjs-cn" target="_blank" rel="external">AngularJS中译本</a></li><li><a href="https://github.com/zensh/AngularjsTutorial_cn" target="_blank" rel="external">AngularJS入门教程</a></li><li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md" target="_blank" rel="external">AngularJS最佳实践和风格指南</a></li><li><a href="http://www.waylau.com/build-angularjs-app-with-yeoman-in-windows/" target="_blank" rel="external">在Windows环境下用Yeoman构建AngularJS项目</a></li><li><a href="https://github.com/xufei/Make-Your-Own-AngularJS/blob/master/01.md" target="_blank" rel="external">构建自己的AngularJS</a></li></ul></li><li>backbone.js<ul><li><a href="http://www.css88.com/doc/backbone/" target="_blank" rel="external">backbone.js中文文档</a></li><li><a href="http://www.the5fire.com/backbone-js-tutorials-pdf-download.html" target="_blank" rel="external">backbone.js入门教程</a> (PDF)</li><li><a href="https://github.com/the5fire/backbonejs-learning-note" target="_blank" rel="external">Backbone.js入门教程第二版</a></li><li><a href="http://feliving.github.io/developing-backbone-applications" target="_blank" rel="external">Developing Backbone.js Applications(中文版)</a></li></ul></li><li><a href="http://www.ituring.com.cn/minibook/950" target="_blank" rel="external">Chrome扩展及应用开发</a></li><li>CoffeeScript<ul><li><a href="https://github.com/geekplux/coffeescript-style-guide" target="_blank" rel="external">CoffeeScript 编码风格指南</a></li></ul></li><li>D3.js<ul><li><a href="http://www.ourd3js.com/wordpress/?cat=2" target="_blank" rel="external">D3.js 入门系列</a> (还有进阶、高级等系列)</li><li><a href="https://github.com/mbostock/d3/wiki/API--%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C" target="_blank" rel="external">官方API文档</a></li><li><a href="http://blog.csdn.net/zhang__tianxu/article/category/1623437" target="_blank" rel="external">张天旭的D3教程</a></li><li><a href="http://www.cnblogs.com/winleisure/tag/D3.js/" target="_blank" rel="external">楚狂人的D3教程</a></li></ul></li><li><a href="http://es6.ruanyifeng.com" target="_blank" rel="external">ECMAScript 6 入门</a> (作者：阮一峰)</li><li>ExtJS<ul><li><a href="http://extjs-doc-cn.github.io/ext4api/" target="_blank" rel="external">Ext4.1.0 中文文档</a></li></ul></li><li><a href="http://bq69.com/blog/articles/script/868/google-javascript-style-guide.html" target="_blank" rel="external">Google JavaScript 代码风格指南</a></li><li><a href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md" target="_blank" rel="external">Google JSON 风格指南</a></li><li>impress.js<ul><li><a href="https://github.com/kokdemo/impress.js-tutorial-in-Chinese" target="_blank" rel="external">impress.js的中文教程</a></li></ul></li><li><a href="http://liubin.github.io/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书</a></li><li><a href="http://typeof.net/s/jsmech/" target="_blank" rel="external">Javascript 原理</a></li><li><a href="http://javascript.ruanyifeng.com" target="_blank" rel="external">JavaScript 标准参考教程（alpha）</a></li><li><a href="https://github.com/jayli/javascript-patterns" target="_blank" rel="external">《JavaScript 模式》</a> “JavaScript patterns”中译本</li><li><a href="https://github.com/justjavac/12-javascript-quirks" target="_blank" rel="external">javascript 的 12 个怪癖</a></li><li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="external">JavaScript 秘密花园</a></li><li><a href="http://icodeit.org/jsccp/" target="_blank" rel="external">JavaScript核心概念及实践</a> (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)</li><li><a href="http://pij.robinqu.me" target="_blank" rel="external">Javascript编程指南</a> (<a href="https://github.com/RobinQu/Programing-In-Javascript" target="_blank" rel="external">源码</a>)</li><li>jQuery<ul><li><a href="http://i5ting.github.io/How-to-write-jQuery-plugin/build/jquery.plugin.html" target="_blank" rel="external">How to write jQuery plugin</a></li><li><a href="http://www.nowamagic.net/librarys/books/contents/jquery" target="_blank" rel="external">简单易懂的JQuery魔法</a></li></ul></li><li>Meteor<ul><li><a href="http://zh.discovermeteor.com" target="_blank" rel="external">Discover Meteor</a></li></ul></li><li>Node.js<ul><li><a href="http://expressjs.jser.us" target="_blank" rel="external">express.js 中文文档</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" rel="external">Express框架</a></li><li><a href="https://github.com/guo-yu/koa-guide" target="_blank" rel="external">koa 中文文档</a></li><li><a href="https://www.npmjs.com/package/learnyounode-zh-cn" target="_blank" rel="external">Learn You The Node.js For Much Win! (中文版)</a></li><li><a href="http://i5ting.github.io/node-debug-tutorial/" target="_blank" rel="external">Node debug 三法三例</a></li><li><a href="https://github.com/jollen/nodejs-fullstack-lessons" target="_blank" rel="external">Node.js Fullstack《從零到一的進撃》</a></li><li><a href="https://github.com/alsotang/node-lessons" target="_blank" rel="external">Node.js 包教不包会</a></li><li><a href="https://github.com/nodejs-tw/nodejs-wiki-book" target="_blank" rel="external">Nodejs Wiki Book</a> (繁体中文)</li><li><a href="https://www.gitbook.com/book/0532/nodejs/details" target="_blank" rel="external">nodejs中文文档</a></li><li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">Node入门</a></li><li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a></li><li><a href="https://github.com/nswbmw/N-blog" target="_blank" rel="external">使用 Express + MongoDB 搭建多人博客</a></li><li><a href="http://nodejs.ctolib.com/docs/sfile/jstraining/engineering.html" target="_blank" rel="external">JavaScript全栈工程师培训材料</a></li></ul></li><li>React.js<ul><li><a href="https://github.com/theJian/build-a-hn-front-page" target="_blank" rel="external">Learn React &amp; Webpack by building the Hacker News front page</a></li><li><a href="http://wiki.jikexueyuan.com/project/react-native/" target="_blank" rel="external">React Native 中文文档(含最新Android内容)</a></li><li><a href="https://github.com/fakefish/react-webpack-cookbook" target="_blank" rel="external">React webpack-cookbook</a></li><li><a href="http://fraserxu.me/intro-to-react/" target="_blank" rel="external">React 入门教程</a></li><li><a href="http://reactjs.cn" target="_blank" rel="external">React.js 中文文档</a></li></ul></li><li>underscore.js<ul><li><a href="http://learningcn.com/underscore/" target="_blank" rel="external">Underscore.js中文文档</a></li></ul></li><li><a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="external">You-Dont-Know-JS</a> (深入JavaScript语言核心机制的系列图书)</li><li>Zepto.js<ul><li><a href="http://css88.com/doc/zeptojs_api" target="_blank" rel="external">Zepto.js 中文文档</a></li></ul></li><li><a href="http://justjavac.com/named-function-expressions-demystified.html" target="_blank" rel="external">命名函数表达式探秘</a>  (注:原文由<a href="http://www.cn-cuckoo.com" target="_blank" rel="external">为之漫笔</a> 翻译，原始地址无法打开，所以此处地址为我博客上的备份)</li><li><a href="http://www.oschina.net/translate/learning-javascript-design-patterns" target="_blank" rel="external">学用 JavaScript 设计模式</a> (开源中国)</li><li><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">深入理解JavaScript系列</a></li></ul><h3 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h3><ul><li><a href="http://www.dralpha.com/zh/tech/tech.htm" target="_blank" rel="external">LaTeX 笔记</a></li><li><a href="http://ctan.org/pkg/lshort-zh-cn" target="_blank" rel="external">一份不太简短的 LaTeX2ε 介绍</a></li><li><a href="https://github.com/49951331/graduate-project-102pj/blob/master/docs/latex123.pdf" target="_blank" rel="external">大家來學 LaTeX</a> (PDF)</li></ul><h3 id="LISP"><a href="#LISP" class="headerlink" title="LISP"></a>LISP</h3><ul><li><a href="http://acl.readthedocs.org/en/latest/" target="_blank" rel="external">ANSI Common Lisp 中文翻译版</a></li><li><a href="http://www.ituring.com.cn/minibook/862" target="_blank" rel="external">Common Lisp 高级编程技术</a> (《On Lisp》中文版)</li></ul><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><ul><li><a href="http://www.w3cschool.cc/manual/lua53doc/contents.html" target="_blank" rel="external">Lua 5.3 参考手册</a></li></ul><h3 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h3><ul><li><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="external">Markdown 快速入门</a></li><li><a href="http://www.jianshu.com/p/7bd23251da0a" target="_blank" rel="external">Markdown 简明教程</a></li><li><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown 语法说明</a></li><li><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="external">献给写作者的 Markdown 新手指南</a></li></ul><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><ul><li><a href="http://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="external">Node 入门</a></li><li><a href="https://www.gitbook.com/book/0532/nodejs/details" target="_blank" rel="external">The NodeJS 中文文档</a> （社区翻译）</li><li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="external">七天学会NodeJS</a> 阿里出品，很好的入门资料</li></ul><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><ul><li><a href="https://github.com/fayland/chinese-perl-book" target="_blank" rel="external">Master Perl Today</a></li><li><a href="https://github.com/horus/modern_perl_book" target="_blank" rel="external">《Modern Perl》中文版</a></li><li><a href="http://net.pku.edu.cn/~yhf/tutorial/perl/perl.html" target="_blank" rel="external">Perl 5 教程</a></li><li><a href="http://www.yiibai.com/perl" target="_blank" rel="external">Perl 教程</a></li></ul><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><ul><li><a href="http://wulijun.github.io/php-the-right-way/" target="_blank" rel="external">PHP 之道</a></li><li><a href="http://php.net/manual/zh/" target="_blank" rel="external">PHP5中文手册</a></li><li><a href="http://www.walu.cc/phpbook/preface.md" target="_blank" rel="external">PHP扩展开发及内核应用</a></li><li><a href="https://wusuopu.gitbooks.io/symfony2_tutorial/content" target="_blank" rel="external">Symfony2 实例教程</a></li><li><a href="http://www.php-internals.com/book/" target="_blank" rel="external">深入理解 PHP 内核</a></li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul><li><a href="http://djangobook.py3k.cn/2.0/" target="_blank" rel="external">Django book 2.0</a></li><li><a href="http://docspy3zh.readthedocs.org/en/latest/" target="_blank" rel="external">Python 3 文档(简体中文) 3.2.2 documentation</a></li><li><a href="http://www.pythondoc.com" target="_blank" rel="external">Python 中文学习大本营</a></li><li><a href="https://github.com/jiechic/diveintopython3" target="_blank" rel="external">深入 Python 3</a></li><li><a href="http://old.sebug.net/paper/books/LearnPythonTheHardWay/" target="_blank" rel="external">笨办法学 Python</a></li></ul><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><ul><li><a href="http://cran.r-project.org/doc/contrib/Liu-FAQ.pdf" target="_blank" rel="external">153分钟学会 R</a> (PDF)</li><li><a href="http://cran.r-project.org/doc/contrib/Ding-R-intro_cn.pdf" target="_blank" rel="external">R 导论</a> (《An Introduction to R》中文版) (PDF)</li><li><a href="http://yanping.me/shiny-tutorial/" target="_blank" rel="external">用 R 构建 Shiny 应用程序</a> (《Building ‘Shiny’ Applications with R》中文版)</li><li><a href="http://cran.r-project.org/doc/contrib/Xu-Statistics_and_R.pdf" target="_blank" rel="external">统计学与 R 读书笔记</a> (PDF)</li></ul><h3 id="reStructuredText"><a href="#reStructuredText" class="headerlink" title="reStructuredText"></a>reStructuredText</h3><ul><li><a href="http://www.pythondoc.com/sphinx/rest.html" target="_blank" rel="external">reStructuredText 入门</a></li><li><a href="http://jwch.sdut.edu.cn/book/rst.html" target="_blank" rel="external">reStructuredText 简明教程</a></li></ul><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><ul><li><a href="https://github.com/JuanitoFatas/rails-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Rails 风格指南</a></li><li><a href="http://railstutorial-china.org" target="_blank" rel="external">Ruby on Rails Tutorial 原书第 2 版</a></li><li><a href="https://ihower.tw/rails4/" target="_blank" rel="external">Ruby on Rails 实战圣经</a></li><li><a href="https://github.com/JuanitoFatas/ruby-style-guide/blob/master/README-zhCN.md" target="_blank" rel="external">Ruby 风格指南</a></li><li><a href="http://lrthw.github.io" target="_blank" rel="external">笨方法学 Ruby</a></li></ul><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><ul><li><a href="https://github.com/KaiserY/rust-book-chinese" target="_blank" rel="external">Rust 官方教程</a></li><li><a href="https://github.com/photino/rust-notes" target="_blank" rel="external">Rust 语言学习笔记</a></li><li><a href="https://github.com/rustcc/RustPrimer" target="_blank" rel="external">RustPrimer</a></li><li><a href="https://github.com/rustcc/rust-by-example/" target="_blank" rel="external">通过例子学习 Rust</a></li></ul><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><ul><li><a href="http://twitter.github.io/effectivescala/index-cn.html" target="_blank" rel="external">Effective Scala</a></li><li><a href="https://www.gitbook.com/book/windor/beginners-guide-to-scala/details" target="_blank" rel="external">Scala 初学者指南</a> (The Neophyte’s Guide to Scala)</li><li><a href="http://twitter.github.io/scala_school/zh_cn/index.html" target="_blank" rel="external">Scala 课堂</a> (Twitter的Scala中文教程)</li></ul><h3 id="Scheme"><a href="#Scheme" class="headerlink" title="Scheme"></a>Scheme</h3><ul><li><a href="http://deathking.github.io/yast-cn/" target="_blank" rel="external">Scheme 入门教程</a> (《Yet Another Scheme Tutorial》中文版)</li></ul><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><ul><li><a href="http://wiki.ubuntu.org.cn/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80" target="_blank" rel="external">Shell 编程基础</a></li><li><a href="https://github.com/qinjx/30min_guides/blob/master/shell.md" target="_blank" rel="external">Shell 脚本编程30分钟入门</a></li><li><a href="http://billie66.github.io/TLCL/book/zh" target="_blank" rel="external">The Linux Command Line 中文版</a></li></ul><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul><li><a href="https://www.gitbook.com/book/numbbbbb/-the-swift-programming-language-/details" target="_blank" rel="external">《The Swift Programming Language》中文版</a></li></ul><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul><li><a href="http://man.chinaunix.net/newsoft/vi/doc/help.html" target="_blank" rel="external">Vim Manual(中文版)</a></li><li><a href="http://www.study-area.org/tips/vim/index.html" target="_blank" rel="external">大家來學 VIM</a></li></ul><h3 id="Visual-Prolog"><a href="#Visual-Prolog" class="headerlink" title="Visual Prolog"></a>Visual Prolog</h3><ul><li><a href="http://wiki.visual-prolog.com/index.php?title=A_Beginners_Guide_to_Visual_Prolog_in_Chinese" target="_blank" rel="external">Visual Prolog 7初学指南</a></li><li><a href="http://wiki.visual-prolog.com/index.php?title=Visual_Prolog_for_Tyros_in_Chinese" target="_blank" rel="external">Visual Prolog 7边练边学</a></li></ul><h3 id="本文转自-free-programming-books-master"><a href="#本文转自-free-programming-books-master" class="headerlink" title="本文转自 free-programming-books-master"></a>本文转自 free-programming-books-master</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;h3 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h3&gt;
    
    </summary>
    
      <category term="资源归档" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E8%B5%84%E6%BA%90%E5%BD%92%E6%A1%A3/"/>
    
    
      <category term="资源归档" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E8%B5%84%E6%BA%90%E5%BD%92%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Fragment</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/04/03/%E6%B5%85%E8%B0%88-Fragment/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/04/03/浅谈-Fragment/</id>
    <published>2017-04-03T08:34:34.000Z</published>
    <updated>2017-10-24T10:37:28.144Z</updated>
    
    <content type="html"><![CDATA[<p>fragment 用户界面管理上用到的地方非常多，fragment 相比 activity ，不同的activity之间有很强的过多效果，fragment 更加轻量级的转变，更加灵活，Fragment 也称作UI Fragment。一下我们通过几个问题来介绍 Fragment。<br><a id="more"></a></p><h4 id="为什么要使用Fragment，能实现什么？"><a href="#为什么要使用Fragment，能实现什么？" class="headerlink" title="为什么要使用Fragment，能实现什么？"></a>为什么要使用Fragment，能实现什么？</h4><p>在实际的开发中，虽然 Activity 可以帮助我们实现不同的页面承载，但是要遵循 Activity 的生命周期，当我们要实现更友好的用户界面，Activity  已经不能满足我们。Fragment 提供更灵活的 UI设计需求，fragment 是一种控制器对象，activity可以委派它完成一些任务，通常是管理用户界面，受管理的用户界面通常是一整屏或是屏幕的一部分。在一些需要在一个activity 进行不同操作的情况下，fragment 就能提供很好的交互。</p><h4 id="Fragment-与-Activity-的什么关系？"><a href="#Fragment-与-Activity-的什么关系？" class="headerlink" title="Fragment 与 Activity 的什么关系？"></a>Fragment 与 Activity 的什么关系？</h4><p>Fragment 必须是依存与Activity而存在的，因此Activity的生命周期会直接影响到Fragment的生命周期，通过两者的生命周期图来理解，fragment<br><img src="http://upload-images.jianshu.io/upload_images/2556431-58edd4d2a70bf9a9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>onAttach()</strong><br>当Fragment与Activity发生关联时调用。<br><strong>onCreateView()</strong><br>创建该Fragment的视图<br><strong>onActivityCreated(Bundle)</strong><br>当Activity的onCreate方法返回时调用<br><strong>onDestoryView()</strong><br>与onCreateView想对应，当该Fragment的视图被移除时调用<br><strong>onDetach()</strong><br>与onAttach相对应，当Fragment与Activity关联被取消时调用</p><blockquote><p>注意：没说的代表跟 activity 相同</p></blockquote><h4 id="如何使用-Fragment？"><a href="#如何使用-Fragment？" class="headerlink" title="如何使用 Fragment？"></a>如何使用 Fragment？</h4><p>两种方式</p><ul><li>布局的方式</li><li>代码的方式</li></ul><h5 id="一-布局的方式"><a href="#一-布局的方式" class="headerlink" title="(一) 布局的方式"></a>(一) 布局的方式</h5><p><fragment android:name="在布局中实例化的Fragment 的包名"></fragment></p><p>当系统构建 Activity 布局时，会实例化在布局指定的 fragment ，并调用 onCreateView（）方法。系统会直接插入onCreateView（）中返回的 view 来代替<fragment> 标签</fragment></p><blockquote><p>注：每个fragment都需要一个唯一的标识符，重启 Activity 时，系统可以使用该标识符来恢复fragment（您也可以使用该标识符来捕获fragment以执行某些事务，如将其移除）。 可以通过三种方式为片段提供 ID：<br>为 android:id 属性提供唯一 ID。<br>为 android:tag 属性提供唯一字符串。<br>如果您未给以上两个属性提供值，系统会使用容器视图的 ID。<br>对于 Fragment 的理解———————————————————————-官方文档</p></blockquote><h5 id="一-代码的方式"><a href="#一-代码的方式" class="headerlink" title="(一) 代码的方式"></a>(一) 代码的方式</h5><p>在Activity 运行的过程中，再添加Fragment到指定的ViewGroup<br>需要通过<strong> FragmentManager </strong>来管理（添加，删除，替换）事务的管理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getSupportFragmentManager().beginTrasaction()</div><div class="line">.add(R.id.fragment,fragment)</div><div class="line">// 参数1. 指定位置添加，通过资源ID定位</div><div class="line">// 参数2.需要添加的 fragment</div><div class="line">如果需要 addToBackStack() 将此事务添加到事务返回栈，允许用户按返回键返回上一个 Fragment 状态</div><div class="line">.commit</div><div class="line">一旦通过FragmentTransaction做出修改必须 commit() 进行提交 才能生效</div></pre></td></tr></table></figure></p><blockquote><p><strong>提示</strong>：对于每个片段事务，您都可以通过在提交前调用 <a href="http://developer.android.youdaxue.com/reference/android/app/FragmentTransaction.html#setTransition(int" target="_blank" rel="external">setTransition()</a>)<br> 来应用过渡动画。</p><p>添加没有 UI 的片段<br>上例展示了如何向您的 Activity 添加片段以提供 UI。不过，您还可以使用片段为 Activity 提供后台行为，而不显示额外 UI。<br>要想添加没有 UI 的片段，请使用 <a href="http://developer.android.youdaxue.com/reference/android/app/FragmentTransaction.html#add(android.app.Fragment, java.lang.String" target="_blank" rel="external">add(Fragment, String)</a>)<br> 从 Activity 添加片段（为片段提供一个唯一的字符串“标记”，而不是视图 ID）。 这会添加片段，但由于它并不与 Activity 布局中的视图关联，因此不会收到对 <a href="http://developer.android.youdaxue.com/reference/android/app/Fragment.html#onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle" target="_blank" rel="external">onCreateView()</a>)<br> 的调用。因此，您不需要实现该方法。<br>并非只能为非 UI 片段提供字符串标记 — 您也可以为具有 UI 的片段提供字符串标记 — 但如果片段没有 UI，则字符串标记将是标识它的唯一方式。如果您想稍后从 Activity 中获取片段，则需要使用 <a href="http://developer.android.youdaxue.com/reference/android/app/FragmentManager.html#findFragmentByTag(java.lang.String" target="_blank" rel="external">findFragmentByTag()</a>)。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">onCreateView</div><div class="line">  inflater,inflate(R.layout.id,container,false);</div><div class="line">参数 1.需要填充的布局，</div><div class="line">参数 2.填充的布局显示到父ViewGroup</div><div class="line">参数 3.指示是否应该在扩展期间将扩展布局附加至（第二个参数）的布尔值。</div><div class="line">在本例中，其值为 false，因为系统已经将扩展布局插入 </div><div class="line">container传递 true 值会在最终布局中创建一个多余的视图组。</div></pre></td></tr></table></figure><h4 id="Fragment-事务该如何理解？"><a href="#Fragment-事务该如何理解？" class="headerlink" title="Fragment 事务该如何理解？"></a>Fragment 事务该如何理解？</h4><p><strong> 理解 </strong>：每一个继承 Fragment 的类都有与之对应的 XML 视图，这是跟 Activity 相同的地方 ，这个 XML 视图 可以看成一个动态的视图，这个视图跟主视图绑定，当我们进行交互性操作的时候，FragmentManager 管理 fragment 事务 进行添加，移除，替换 ，这个过程中遵循的是 fragment 的生命周期，只要 Activity 处于运行状态，就可以使用一个或者多个fragment 进行 事务的处理。例如：清单列表和详细内容是两个不同的 fragment 构成，先加载的是清单列表 fragment 当用户选中其中一个，触发FragmentManager  进行 替换操作，替换成详细内容fragment。</p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>fragment 的用法还有许多，包括与ViewPager 和 FragmentPagerAdapter 的使用这里我们先介绍基础性的知识，也没有给大家介绍具体的代码，因为我认为对于这个东西，先要去理解它，当你再去看代码就能很好的使用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;fragment 用户界面管理上用到的地方非常多，fragment 相比 activity ，不同的activity之间有很强的过多效果，fragment 更加轻量级的转变，更加灵活，Fragment 也称作UI Fragment。一下我们通过几个问题来介绍 Fragment。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
      <category term="UI" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/UI/"/>
    
      <category term="用户界面" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Android-音频播放（一）</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/03/30/Android-%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/03/30/Android-音频播放（一）/</id>
    <published>2017-03-30T13:12:23.000Z</published>
    <updated>2017-09-19T06:39:40.381Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了关于Android 的音频播放，以及系统中各应用之间对于音频播放的<strong>资源竞争</strong>处理。如何处理应用处于播放的状态下，其他的音频如何影响当前的状态。<br>例如：当手机播放一个音乐，同时来了一个电话，这时音乐停止，当通话结束时再继续播放。<br><a id="more"></a></p><h2 id="如何创建一个播放音频"><a href="#如何创建一个播放音频" class="headerlink" title="如何创建一个播放音频"></a>如何创建一个播放音频</h2><blockquote><p>注意：Media Player 只介绍最基础的，其他的方法后期遇到在进行详解。</p></blockquote><p>Media Player 类：媒体播放器类可用于控制播放的音频/视频文件和流。<br><img src="http://upload-images.jianshu.io/upload_images/2556431-e04989851ff4c5f7.gif?imageMogr2/auto-orient/strip" alt="Media Player的生命周期图"></p><p>创建一个音频的语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MediaPlayer mMediaPlayer = MediaPlayer.create(Context context, int resid);</div></pre></td></tr></table></figure></p><p>第一个参数：播放的位置<br>第二个参数：音频的资源ID(一般方法哦 raw 文件夹中)</p><blockquote><p>其中的方法我们只介绍常用的，以后遇到在进行总结归纳</p></blockquote><p>//播放开始后暂停，再播放从上次停止的位置继续<br>start()进行播放<br>pause()暂停</p><p>//如果括号为0,音频回到最初的位置<br>seekTo() 指定的时间位置<br>reset()重置</p><p>//停止后 只有先prepare()才能 start()<br>stop()停止<br>prepare()准备</p><p>//当播放完后需要释放资源<br>release()释放资源</p><p>上述其他方法可以查看生命周期图</p><h5 id="应用播放机制"><a href="#应用播放机制" class="headerlink" title="应用播放机制"></a>应用播放机制</h5><p>要想播放音频，先要获取 Audio Focus，可以理解为只有获取到音频焦点的才可以播放，虽然 Android 2.2 之后添加了 Audio Focus，来处理系统之间音频的混乱。如果有程序在它失去AudioFocus的时候仍然在使用Audio，AudioFocus拿它也没办法，用户可能安装没遵守这种机制的程序，或者版本太老还没引入这种机制的程序，这最终会导致很差的用户体验。</p><ol><li><strong>如何获取 Audio Focus？</strong></li></ol><p>利用 AudioManager 来管理AudioFocus，先要实例化AudioManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AudioManager mAudioManager=(AudioManager)getSystemService(this.AUDIO_SERVICE);</div></pre></td></tr></table></figure><p> mAudioManager提供两个方法 :</p><p><strong>requestAudioFocus 获取焦点 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int requestAudioFocus (AudioManager.OnAudioFocusChangeListener, int streamType, int durationHint);</div></pre></td></tr></table></figure><p>参数：</p><ol><li>焦点状态改变监听器</li><li>输入流类型<ul><li>STREAM_MUSIC 一般的音频其他的可以查看<a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#requestAudioFocus(android.media.AudioManager.OnAudioFocusChangeListener, int, int" target="_blank" rel="external">官方文档</a>)</li></ul></li><li>持续时间<ul><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_GAIN_TRANSIENT" target="_blank" rel="external">AUDIOFOCUS_GAIN_TRANSIENT</a> 临时获取焦点，短时间释放</li><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK" target="_blank" rel="external">AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</a> 临时获取焦点，前焦点保持播放，其他降低音量</li><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE" target="_blank" rel="external">AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE</a> 介于上两个参数之间，不能破坏像通知，语音备忘，语言识别；</li><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_GAIN" target="_blank" rel="external">AUDIOFOCUS_GAIN</a>未知的时间播放歌曲或视频</li></ul></li></ol><p>请求焦点会有两个结果<br>1 AUDIOFOCUS_REQUEST_GRANTED 请求焦点成功<br>2 AUDIOFICUS_REQUEST_FAILED 请求焦点失败</p><hr><p> <strong>abandonAudioFocus 释放焦点 </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int abandonAudioFocus (AudioManager.OnAudioFocusChangeListener)</div></pre></td></tr></table></figure><h5 id="焦点状态改变监听器"><a href="#焦点状态改变监听器" class="headerlink" title="焦点状态改变监听器"></a>焦点状态改变监听器</h5><p>通过一个 onAudioFocusChangeLiestener  方法回调来获得  Audiofocus 发生更改 后 的通知<br>监听设备更改 以便做出响应  onAudioFocusChangeLiestener 是一种接口     包含一个必须实施的onAudioFocusChange 抽象类（如果获得焦点 应该做什么，失去后应该做什么</p><p>onAudioFocusChange：<br>四个参数:</p><ol><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_GAIN" target="_blank" rel="external">AUDIOFOCUS_GAIN</a></li><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_LOSS" target="_blank" rel="external">AUDIOFOCUS_LOSS</a></li><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_LOSS_TRANSIENT" target="_blank" rel="external">AUDIOFOCUS_LOSS_TRANSIENT</a></li><li><a href="http://developer.android.youdaxue.com/reference/android/media/AudioManager.html#AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK" target="_blank" rel="external">AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK</a></li></ol><blockquote><p>不懂的可以点看连接详细理解。</p></blockquote><h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>实现当失去焦点时，暂停，等恢复获得焦点后，继续播放</p><blockquote><p>下面是通过 ArrayList 一个数组列表（List+ArrayAdapter实现），看不懂没关系，主要理解当点击时，先获取 AudioFocus 状态，根据焦点状态进行判断</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">public class NumbersActivity extends AppCompatActivity &#123;</div><div class="line">    //定义一个音频管理的对象</div><div class="line">    private AudioManager mAudioManager;</div><div class="line">    //创建一个监听音频聚焦的监听器</div><div class="line">    AudioManager.OnAudioFocusChangeListener mAudioFocusChangeListener =</div><div class="line">            new AudioManager.OnAudioFocusChangeListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onAudioFocusChange(int i) &#123;</div><div class="line">            //判断当状态  暂时失去音频焦点  暂停并并重置</div><div class="line">            if(i==AudioManager.AUDIOFOCUS_LOSS_TRANSIENT||</div><div class="line">               i==AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK)&#123;</div><div class="line">                mediaPlayer.pause();</div><div class="line">                mediaPlayer.seekTo(0);</div><div class="line">            &#125;else</div><div class="line">            //判断当状态获取音频焦点时应该播放</div><div class="line">            if(i==AudioManager.AUDIOFOCUS_GAIN)&#123;</div><div class="line">                mediaPlayer.start();</div><div class="line">            &#125;else</div><div class="line">            //当前状态  永远失去焦点的时候  释放资源</div><div class="line">            if(i==AudioManager.AUDIOFOCUS_LOSS)&#123;</div><div class="line">                releaseMediaPlayer();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    private MediaPlayer mediaPlayer;</div><div class="line">    //？？？有必要吗？</div><div class="line">    private MediaPlayer.OnCompletionListener mCompletionListener = new</div><div class="line">        MediaPlayer.OnCompletionListener() &#123;</div><div class="line">        @Override</div><div class="line">        public void onCompletion(MediaPlayer mediaPlayer) &#123;</div><div class="line">            releaseMediaPlayer();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.word_list);</div><div class="line">        //获取AudioManager</div><div class="line">        mAudioManager = (AudioManager) getSystemService(this.AUDIO_SERVICE);</div><div class="line">        //自定义的数组列表  类型是Word类的数据</div><div class="line">        final ArrayList&lt;Word&gt; words = new ArrayList&lt;Word&gt;();</div><div class="line">        words.add(new Word(&quot;one&quot;, &quot;lutti&quot;, R.drawable.number_one,</div><div class="line"></div><div class="line">        //自定义的一个适配器，继承以前的数组适配器</div><div class="line">        WordAdapter itemsAdapter = new WordAdapter(this, words, R.color.category_numbers);</div><div class="line">        ListView listView = (ListView) findViewById(R.id.list);</div><div class="line">        listView.setAdapter(itemsAdapter);</div><div class="line">        listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123;</div><div class="line">                Word word = words.get(i);</div><div class="line">                //request 获取Audio Focus</div><div class="line">               int result=mAudioManager.requestAudioFocus(mAudioFocusChangeListener</div><div class="line">                       , AudioManager.STREAM_MUSIC</div><div class="line">                       , AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK);</div><div class="line">                //成功的焦点更改请求</div><div class="line">                if(result==AudioManager.AUDIOFOCUS_REQUEST_GRANTED)&#123;</div><div class="line">                    //创建一个MediaPlayer</div><div class="line">                    mediaPlayer = MediaPlayer.</div><div class="line">                            create(NumbersActivity.this, word.getMusicResource());</div><div class="line"></div><div class="line">                //开始播放</div><div class="line">                mediaPlayer.start();</div><div class="line">                //</div><div class="line">                mediaPlayer.setOnCompletionListener(mCompletionListener);</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   @Override</div><div class="line">    protected void onStop() &#123;</div><div class="line">        super.onStop();</div><div class="line">        releaseMediaPlayer();</div><div class="line">    &#125;</div><div class="line">// 自定义的一个释放资源的类</div><div class="line">    private void releaseMediaPlayer() &#123;</div><div class="line"></div><div class="line">        if (mediaPlayer != null) &#123;</div><div class="line"></div><div class="line">            mediaPlayer.release();</div><div class="line"></div><div class="line">            mediaPlayer = null;</div><div class="line">            //失去焦点</div><div class="line">            mAudioManager.abandonAudioFocus(mAudioFocusChangeListener);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了关于Android 的音频播放，以及系统中各应用之间对于音频播放的&lt;strong&gt;资源竞争&lt;/strong&gt;处理。如何处理应用处于播放的状态下，其他的音频如何影响当前的状态。&lt;br&gt;例如：当手机播放一个音乐，同时来了一个电话，这时音乐停止，当通话结束时再继续播放。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 主题美化</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/03/28/Hexo-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/03/28/Hexo-主题美化/</id>
    <published>2017-03-28T12:47:33.000Z</published>
    <updated>2017-09-19T06:39:53.731Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇主要介绍了 Hexo nexT 主题的美化，添加了如何修改标题栏上面的进度条，进度条根据阅读得多少显示长度，还增加了头像旋转特效和如何添加畅言评论系统，主要先介绍三个样式修改，希望大家更多的时间放在原创文章上面，把博客当成自己总结经验和知识的地方，相信你的经验也会带给别人更多的收获！<br><a id="more"></a></p><h2 id="头像旋转"><a href="#头像旋转" class="headerlink" title="头像旋转"></a>头像旋转</h2><p>先找到位于<br> source/css/_common/components/sidebar/sidebar-author.syl<br>模板文件里侧边栏头像的样式<br>.site-author-image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.site-author-image &#123;</div><div class="line">    display: block;</div><div class="line">    margin: 0 auto;</div><div class="line">    padding: $site-author-image-padding;</div><div class="line">    max-width: $site-author-image-width;</div><div class="line">    height: $site-author-image-height;</div><div class="line">    border: $site-author-image-border-width solid $site-author-image-border-color;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过修改 border-radius 属性就可以改图片四个角的圆角,再加上属性变化的动画效果.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.site-author-image &#123;</div><div class="line">    border-radius: 50%;</div><div class="line">    -webkit-border-radius: 50%;</div><div class="line">    -moz-border-radius: 50%;</div><div class="line">    transition: 1.4s all;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>添加 .site-author-image:hover 样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.site-author-image:hover &#123;</div><div class="line">    -webkit-transform: rotate(360deg);</div><div class="line">    -moz-transform: rotate(360deg);</div><div class="line">    -ms-transform: rotate(360deg);</div><div class="line">    -transform: rotate(360deg);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>完成！</p><hr><h2 id="页面加载进度条"><a href="#页面加载进度条" class="headerlink" title="页面加载进度条"></a>页面加载进度条</h2><p>获取提供了 nprogress.css 和 nprogress.js 两个文件<a href="https://github.com/rstacruz/nprogress" target="_blank" rel="external">获取代码</a><br>这两个文件加进  source\lib\nprogress\  目录下<br>在  layout/_partials/head.swig  模板中加入  nprogress.css:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;% set nprogress_uri = url_for(theme.vendors._internal + &apos;/nprogress/nprogress.css&apos;) %&#125;</div><div class="line">&lt;link href=&quot;&#123;&#123; nprogress_uri &#125;&#125;&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</div></pre></td></tr></table></figure></p><p>在 layout/_scripts/vendors.swig 模板中加入 nprogress.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% set js_vendors.nprogress   = &apos;nprogress/nprogress.js&apos; %&#125;</div></pre></td></tr></table></figure></p><p>在 source\js\custom.js 里添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(document).ready(function () &#123;</div><div class="line">    NProgress.start();</div><div class="line">    window.onload = function () &#123;</div><div class="line">        NProgress.done();</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>完成！</p><hr><h2 id="添加畅言评论系统"><a href="#添加畅言评论系统" class="headerlink" title="添加畅言评论系统"></a>添加畅言评论系统</h2><p><strong>在这之前，我们得说一下，如果网站没有ICP申报的只有15天的试用期，但是由于多说服务关闭，在国内的评论系统，也就<a href="http://changyan.kuaizhan.com/" target="_blank" rel="external">畅言</a>(畅言欠我一个广告费)看起来不错，具体的需要你们自己斟酌。</strong></p><p>在这里我们要说一个畅言网站的一个<strong>坑</strong>，这个坑就是你注册的其实是<a href="https://www.kuaizhan.com/" target="_blank" rel="external">快站</a>的账号,当你保存畅言的网站下次登陆的时候，其实你是登不上去的，只有从快站登陆并且登陆后才能切换。<br>（说了一堆废话，只是不想让你们入我的坑，傻傻的再敲账号和密码/(ㄒoㄒ)/~~）</p><p>###主题配置文件<br>next主题的配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#changyan</div><div class="line">//畅言在后台管理提供的 需要复制粘贴到下面</div><div class="line">changyan_appid:</div><div class="line">changyan_appkey:</div></pre></td></tr></table></figure></p><h4 id="添加畅言评论框"><a href="#添加畅言评论框" class="headerlink" title="添加畅言评论框"></a>添加畅言评论框</h4><p>  添加文件layout/_scripts/third-party/comments/changyan.swig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.changyan_appid and theme.changyan_appkey %&#125;</div><div class="line">&#123;% if is_home() %&#125;</div><div class="line">&lt;script id=&quot;cy_cmt_num&quot; src=&quot;https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=&#123;&#123;theme.changyan_appid&#125;&#125;&quot;&gt;&lt;/script&gt;</div><div class="line">&#123;% else %&#125;</div><div class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">(function()&#123;</div><div class="line">var appid = &apos;&#123;&#123;theme.changyan_appid&#125;&#125;&apos;;</div><div class="line">var conf = &apos;&#123;&#123;theme.changyan_appkey&#125;&#125;&apos;;</div><div class="line">var width = window.innerWidth || document.documentElement.clientWidth;</div><div class="line">if (width &lt; 960) &#123;</div><div class="line">window.document.write(&apos;&lt;script id=&quot;changyan_mobile_js&quot; charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=&apos; + appid + &apos;&amp;conf=&apos; + conf + &apos;&quot;&gt;&lt;\/script&gt;&apos;); &#125; else &#123; var loadJs=function(d,a)&#123;var c=document.getElementsByTagName(&quot;head&quot;)[0]||document.head||document.documentElement;var b=document.createElement(&quot;script&quot;);b.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);b.setAttribute(&quot;charset&quot;,&quot;UTF-8&quot;);b.setAttribute(&quot;src&quot;,d);if(typeof a===&quot;function&quot;)&#123;if(window.attachEvent)&#123;b.onreadystatechange=function()&#123;var e=b.readyState;if(e===&quot;loaded&quot;||e===&quot;complete&quot;)&#123;b.onreadystatechange=null;a()&#125;&#125;&#125;else&#123;b.onload=a&#125;&#125;c.appendChild(b)&#125;;loadJs(&quot;https://changyan.sohu.com/upload/changyan.js&quot;,function()&#123;window.changyan.api.config(&#123;appid:appid,conf:conf&#125;)&#125;); &#125; &#125;)(); &lt;/script&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;https://assets.changyan.sohu.com/upload/plugins/plugins.count.js&quot;&gt;&lt;/script&gt;</div><div class="line">&#123;% endif %&#125;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p><h6 id="注意：前面忘记说了，新建的文件定要保证是UTF-8格式，全英文可能没事，但是如果文件中有中文就需要注意了"><a href="#注意：前面忘记说了，新建的文件定要保证是UTF-8格式，全英文可能没事，但是如果文件中有中文就需要注意了" class="headerlink" title="注意：前面忘记说了，新建的文件定要保证是UTF-8格式，全英文可能没事，但是如果文件中有中文就需要注意了."></a>注意：前面忘记说了，新建的文件定要保证是UTF-8格式，全英文可能没事，但是如果文件中有中文就需要注意了.</h6><p>修改文件 layout/_partials/comments.swig,在id为 comments 的div中最后增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;% elseif theme.changyan_appid and theme.changyan_appkey %&#125;</div><div class="line">        &lt;div id=&quot;SOHUCS&quot; &gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-1ebf050498bebb30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666" alt=""></p><p>注意放的位置</p><h5 id="增加畅言评论调用"><a href="#增加畅言评论调用" class="headerlink" title="增加畅言评论调用"></a>增加畅言评论调用</h5><p>修改  layout/_scripts/third-party/comments.swig  ，最底下增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% include &apos;./comments/changyan.swig&apos; %&#125;</div></pre></td></tr></table></figure></p><h5 id="增加评论统计数"><a href="#增加评论统计数" class="headerlink" title="增加评论统计数"></a>增加评论统计数</h5><p>修改layout/_macro/post.swig,增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;% elseif theme.changyan_appid and theme.changyan_appkey %&#125;</div><div class="line">&lt;!--noindex--&gt;</div><div class="line">&lt;span class=&quot;post-comments-count&quot;&gt;</div><div class="line">&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</div><div class="line">&lt;span class=&quot;post-meta-item-icon&quot;&gt;</div><div class="line">  &lt;i class=&quot;fa fa-comment-o&quot;&gt;&lt;/i&gt;</div><div class="line">&lt;/span&gt;</div><div class="line">&#123;% if is_post() %&#125;</div><div class="line">    &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#SOHUCS&quot; itemprop=&quot;discussionUrl&quot;&gt;</div><div class="line">      &lt;span id=&quot;changyan_count_unit&quot; class=&quot;post-comments-count hc-comment-count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot;&gt;&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&#123;% else %&#125;</div><div class="line">    &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#SOHUCS&quot; itemprop=&quot;discussionUrl&quot;&gt;</div><div class="line">    &lt;span id = &quot;url::&#123;&#123; post.permalink &#125;&#125;&quot; class = &quot;cy_cmt_count&quot; data-xid=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot; &gt;&lt;/span&gt;</div><div class="line">    &lt;/a&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p><p>放入到div 中间 即可  如果有添加 <a href="https://leancloud.cn/" target="_blank" rel="external">leanCould</a>用户统计的，可以定位ctrl+F ‘leanCould’ 放到上面即可如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2556431-fbea453108ac845d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/666" alt=""></p><p>一切ok！</p><h4 id="文章配图"><a href="#文章配图" class="headerlink" title="文章配图"></a>文章配图</h4><p>主要实现的就是在标题和摘要中间，插进一张Logo图片，而当点击进入后，就不会再显示这个logo图片了。原文地址：Hexo主题的数据封装，样式渲染和扩展实例。</p><h5 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h5><p>hexo/themes/next/source/css/: 是next主题的样式文件，决定主题的外观。<br>hexo/themes/next/source/css/main.styl：汇总css文件夹中所有的样式。<br>hexo/themes/next/source/css/ _custom/custom.styl：是空的，专门让开发者扩展。<br>需要在custom.styl里为图片设计一个专用容器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//图片外部的容器方框</span></div><div class="line">.out-img-topic &#123;</div><div class="line">  display: block;</div><div class="line">  max-height:<span class="number">300</span>px;</div><div class="line">  margin-bottom: <span class="number">24</span>px;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line"><span class="comment">//图片</span></div><div class="line">img.img-topic &#123;</div><div class="line">  display: block ;</div><div class="line">  margin-left: <span class="number">.7</span>em;</div><div class="line">  margin-right: <span class="number">.7</span>em;</div><div class="line">  padding: <span class="number">0</span>;</div><div class="line">  float: right;</div><div class="line">  clear: right;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里图片外部的容器用来限制图片显示的大小，最大的高度为300px，overflow: hidden;让多余部分隐藏。margin-bottom: 24px;确保图片和文章摘要部分空出一定空间。</p><h5 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h5><p>修改 /themes/next/layout/ _macro/post.swig ，在 if is_index 与 if post.description and theme.excerpt_description 之间添加以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> post.images %&#125;</div><div class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"out-img-topic"</span>&gt;</div><div class="line">        &lt;img src=&#123;&#123; post.images &#125;&#125; <span class="class"><span class="keyword">class</span></span>=<span class="string">"img-topic"</span>&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">&#123;% endif %&#125;</span></div></pre></td></tr></table></figure><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>在 /scaffolds/post.md ，加一个images字段，那么在创建新的文章时，填的图片地址就会一直作为文章的一个属性被传递。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">title: &#123;&#123; title &#125;&#125;</div><div class="line">date: &#123;&#123; date &#125;&#125;</div><div class="line">categories:</div><div class="line">tags:</div><div class="line">images: <span class="string">"/images/摘要配图/"</span></div></pre></td></tr></table></figure></p><p>推荐几个其他主题美化的链接：<br><a href="http://www.dingxuewen.com/2017/03/01/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%E4%B8%80/" target="_blank" rel="external">Hexo搭建博客的个性化设置一</a><br><a href="http://www.dingxuewen.com/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%E4%BA%8C/" target="_blank" rel="external">Hexo搭建博客的个性化设置二</a><br><a href="http://www.dingxuewen.com/2017/03/11/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AE%E4%B8%89/" target="_blank" rel="external">Hexo搭建博客的个性化设置三</a></p><p>如果在搭建有问题的童鞋，可以给我留言，我理解你们那种出现问题想要快点解决的心，我自己之所以开始坚持写文章，是希望能给别人，更多的借鉴！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇主要介绍了 Hexo nexT 主题的美化，添加了如何修改标题栏上面的进度条，进度条根据阅读得多少显示长度，还增加了头像旋转特效和如何添加畅言评论系统，主要先介绍三个样式修改，希望大家更多的时间放在原创文章上面，把博客当成自己总结经验和知识的地方，相信你的经验也会带给别人更多的收获！&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写博客？</title>
    <link href="https://lowape.github.io/didiaoyuan.github.io/2017/03/28/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
    <id>https://lowape.github.io/didiaoyuan.github.io/2017/03/28/为什么要写博客？/</id>
    <published>2017-03-28T11:15:16.000Z</published>
    <updated>2017-09-27T13:23:05.766Z</updated>
    
    <content type="html"><![CDATA[<p>作者：陈素封<br>链接：<a href="https://zhuanlan.zhihu.com/p/19743861" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/19743861</a><br>来源：知乎</p><p>为什么你要写博客？<br><a id="more"></a></p><h4 id="一个选择"><a href="#一个选择" class="headerlink" title="一个选择"></a>一个选择</h4><p>我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？</p><p>我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。</p><p>判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。</p><p>大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？</p><p>所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。</p><p>注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。</p><h4 id="博客的内容"><a href="#博客的内容" class="headerlink" title="博客的内容"></a>博客的内容</h4><p>写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的：</p><ol><li>不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……；</li><li>有目的地写，要务实，追求质量；</li><li>承认真实的自己，不要吹嘘，不要装逼，无需讨好读者；</li><li>记录自己学习、思考、总结的过程；</li><li>分享你的故事、所得、感想、经验；<br>值得写的原因</li></ol><p>以下是一个清单，可以根据自己的情况匹配，然后选择。</p><h4 id="重新认识自己"><a href="#重新认识自己" class="headerlink" title="重新认识自己"></a>重新认识自己</h4><p>是不是很久没有跟自己对话了？</p><p>你可以尝试从回答一些问题开始，将你过去要回避的问题写下来，例如就可以从这个九个问题开始：</p><p>1、请你介绍一下你自己，你是个什么样的人？</p><p>2、你有什么理想吗？这个理想是怎么形成的？</p><p>3、你理想的伴侣关系是什么样的？你自己在这个伴侣关系中扮演什么样的角色？要承担什么样的责任？</p><p>4、你理想的事业是什么，你正在做的工作符合你的事业理想吗？这份工作对你的意义是什么？</p><p>5、你对亲子关系怎么看？对你来说，什么是一个理想的父亲（母亲），你期望自己成为这样一个理想父亲（母亲）吗？</p><p>6、你对钱怎么看，你认为赚到多少钱是足够的？如果你明天一早醒来，已经有足够的钱，你将会如何继续安排自己的生活？</p><p>7、对你来说，什么是理想的性生活？什么是理想的性道德，在你的性道德观中，什么样的性生活是禁忌的，需要避免的，什么样的性生活是美好的，需要得到鼓励和发展的？</p><p>8、你的择友标准是什么？什么样的人你会愿意交往，什么样的人你会拒绝和他交往？</p><p>9、你对死亡怎么看？你希望自己活到多少岁，你准备怎么度过从现在到死亡的这段时间？如果你要立遗嘱，这份遗嘱会怎么写？</p><p>以上的这九个问题摘自《很少人能顺畅回答这9个问题——心理治疗刚开始医生常常会先问你的 》by 李孟潮。</p><p>这些问题的答案你可以选择不发，但是我强烈地建议写下来，只有在写的时候你才可以慎重地思考这些问题，而不会回避跳过或者留下空白，这是接受自己的第一步。</p><h4 id="提供持续学习的动力"><a href="#提供持续学习的动力" class="headerlink" title="提供持续学习的动力"></a>提供持续学习的动力</h4><p>例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。</p><p>详细的知识管理可以看我的这篇文章：《个人知识管理的方法》，回复「知识」可见</p><p>积累更多的知识</p><p>写并不是单纯的写。</p><p>例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。</p><p>例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。</p><h4 id="提高将事情讲清楚的能力"><a href="#提高将事情讲清楚的能力" class="headerlink" title="提高将事情讲清楚的能力"></a>提高将事情讲清楚的能力</h4><p>很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。</p><p>如果一件事情你不能讲清楚，十有八九你还没有完全理解。</p><p>将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。</p><h4 id="分享带来的连锁反应"><a href="#分享带来的连锁反应" class="headerlink" title="分享带来的连锁反应"></a>分享带来的连锁反应</h4><p>“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》</p><p>互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。</p><h4 id="帮你找到志同道合的人"><a href="#帮你找到志同道合的人" class="headerlink" title="帮你找到志同道合的人"></a>帮你找到志同道合的人</h4><p>在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。</p><p>如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。</p><p>即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》</p><h4 id="记录成长"><a href="#记录成长" class="headerlink" title="记录成长"></a>记录成长</h4><p>隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。</p><p>更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！</p><p>培养持续做一件事情的能力</p><p>开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」</p><p>让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。</p><p>你不相信？你不试试你怎么知道？</p><p>默默地持续做一件事是一种难得的能力，也是一种难得的品质。</p><h4 id="讨论反思"><a href="#讨论反思" class="headerlink" title="讨论反思"></a>讨论反思</h4><p>每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。</p><p>互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。</p><p>搜寻到你意想不到东西</p><p>世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。</p><p>例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。</p><h4 id="一个人在做一件属于自己的事"><a href="#一个人在做一件属于自己的事" class="headerlink" title="一个人在做一件属于自己的事"></a>一个人在做一件属于自己的事</h4><p>很多你认为自己很牛逼的事情都是自己一个人做出来。</p><p>别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？</p><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》</p><h4 id="互联网的身份识别："><a href="#互联网的身份识别：" class="headerlink" title="互联网的身份识别："></a>互联网的身份识别：</h4><p>一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。</p><p>这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>你可能想不到在白纸的左边（不值得写博客的原因）写什么了，想不到写个「博客时代已经过去」或者「我没有时间」也可以，但与此同时，你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」。</p><p>如果你不想思考，也可以回复「价值」看看别人的建议。</p><p>推荐写作平台：</p><p>简书（推荐）<br>自己搭建一个独立博客<br>新浪博客</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：陈素封&lt;br&gt;链接：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/19743861&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://zhuanlan.zhihu.com/p/19743861&lt;/a&gt;&lt;br&gt;来源：知乎&lt;/p&gt;
&lt;p&gt;为什么你要写博客？&lt;br&gt;
    
    </summary>
    
      <category term="转载" scheme="https://lowape.github.io/didiaoyuan.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="随笔" scheme="https://lowape.github.io/didiaoyuan.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
